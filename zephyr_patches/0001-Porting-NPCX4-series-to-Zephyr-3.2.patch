From f1c925b0c9fc843f6a3e6013ab5084905c694d71 Mon Sep 17 00:00:00 2001
From: BrookLiu <brookliu888@gmail.com>
Date: Fri, 29 Dec 2023 08:52:40 +0800
Subject: [PATCH 1/2] Porting NPCX4 series to Zephyr 3.2

---
 boards/arm/npcx4m8f_evb/Kconfig.board         |    6 +
 boards/arm/npcx4m8f_evb/Kconfig.defconfig     |   16 +
 boards/arm/npcx4m8f_evb/board.cmake           |    6 +
 boards/arm/npcx4m8f_evb/doc/index.rst         |  131 ++
 boards/arm/npcx4m8f_evb/doc/npcx4m8f_evb.jpg  |  Bin 0 -> 96434 bytes
 .../npcx4m8f_evb/npcx4m8f_evb-pinctrl.dtsi    |   16 +
 boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts      |  122 ++
 boards/arm/npcx4m8f_evb/npcx4m8f_evb.yaml     |   26 +
 .../arm/npcx4m8f_evb/npcx4m8f_evb_defconfig   |   38 +
 boards/arm/npcx4m8f_evb/support/openocd.cfg   |   16 +
 drivers/adc/Kconfig.npcx                      |   16 +
 drivers/adc/adc_npcx.c                        |  253 ++--
 drivers/bbram/bbram_npcx.c                    |    9 +-
 drivers/clock_control/Kconfig.npcx            |   12 +
 .../clock_control/clock_control_mchp_xec.c    |   12 +-
 drivers/clock_control/clock_control_npcx.c    |   69 +-
 drivers/console/uart_console.c                |    2 +-
 drivers/crypto/CMakeLists.txt                 |    1 +
 drivers/crypto/Kconfig                        |    1 +
 drivers/crypto/Kconfig.npcx                   |   11 +
 drivers/crypto/crypto_npcx_sha.c              |  216 +++
 drivers/espi/CMakeLists.txt                   |    6 +-
 drivers/espi/Kconfig                          |   17 +-
 drivers/espi/Kconfig.npcx                     |   51 +
 drivers/espi/Kconfig.xec                      |  125 +-
 drivers/espi/espi_mchp_xec.c                  |   41 +-
 drivers/espi/espi_npcx.c                      |  159 ++-
 drivers/espi/espi_saf_mchp_xec_v2.c           | 1175 +++++++++++++++++
 drivers/espi/espi_taf_npcx.c                  |  491 +++++++
 drivers/espi/host_subs_npcx.c                 |  126 +-
 drivers/flash/CMakeLists.txt                  |    3 +-
 drivers/flash/Kconfig                         |    2 +
 drivers/flash/Kconfig.npcx_fiu                |   73 +
 drivers/flash/flash_npcx_fiu_nor.c            |  623 +++++++++
 drivers/flash/flash_npcx_fiu_qspi.c           |  340 +++++
 drivers/flash/flash_npcx_fiu_qspi.h           |   88 ++
 drivers/gpio/gpio_npcx.c                      |   20 +-
 drivers/i2c/CMakeLists.txt                    |    2 +-
 drivers/i2c/Kconfig.npcx                      |   29 +-
 drivers/i2c/i2c_npcx_controller.c             |  933 ++++++++++---
 drivers/i2c/i2c_npcx_controller.h             |   26 +
 drivers/i2c/i2c_npcx_port.c                   |   38 +-
 drivers/interrupt_controller/Kconfig          |   13 +
 .../interrupt_controller/intc_mchp_ecia_xec.c |    2 +-
 drivers/interrupt_controller/intc_miwu.c      |  151 +--
 drivers/led/CMakeLists.txt                    |    1 +
 drivers/led/Kconfig                           |    1 +
 drivers/led/Kconfig.xec                       |   11 +
 drivers/led/led_mchp_xec.c                    |  292 ++++
 drivers/peci/peci_mchp_xec.c                  |    3 +
 drivers/peci/peci_npcx.c                      |    8 +-
 drivers/pinctrl/pinctrl_npcx.c                |   41 +-
 drivers/ps2/Kconfig.npcx                      |    3 +-
 drivers/ps2/ps2_npcx_controller.c             |    4 +-
 drivers/pwm/pwm_npcx.c                        |    8 +-
 drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig   |   28 +
 .../nuvoton_adc_cmp_npcx/adc_cmp_npcx.c       |   41 +-
 .../nuvoton_tach_npcx/tach_nuvoton_npcx.c     |   10 +-
 drivers/serial/uart_npcx.c                    |  112 +-
 drivers/spi/CMakeLists.txt                    |    2 +-
 drivers/spi/Kconfig                           |    2 +-
 drivers/timer/npcx_itim_timer.c               |   11 +-
 drivers/watchdog/wdt_npcx.c                   |   30 +-
 dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi  |    2 +-
 dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi  |    3 -
 dts/arm/nuvoton/npcx/npcx.dtsi                |  681 ++++++++++
 dts/arm/nuvoton/npcx/npcx4.dtsi               |  325 +++++
 .../nuvoton/npcx/npcx4/npcx4-alts-map.dtsi    |  184 +++
 .../npcx/npcx4/npcx4-espi-vws-map.dtsi        |   58 +
 .../npcx/npcx4/npcx4-lvol-ctrl-map.dtsi       |  183 +++
 .../npcx/npcx4/npcx4-miwus-int-map.dtsi       |   76 ++
 .../npcx/npcx4/npcx4-miwus-wui-map.dtsi       |   99 ++
 dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi |  558 ++++++++
 dts/arm/nuvoton/npcx4m3f.dtsi                 |   42 +
 dts/arm/nuvoton/npcx4m8f.dtsi                 |   42 +
 dts/bindings/clock/nuvoton,npcx-pcc.yaml      |  385 +++---
 dts/bindings/espi/nuvoton,npcx-espi.yaml      |   54 +-
 dts/bindings/iio/adc/nuvoton,npcx-adc.yaml    |   42 +-
 include/zephyr/dt-bindings/clock/npck_clock.h |   32 +
 include/zephyr/dt-bindings/clock/npcx_clock.h |    2 +
 .../flash_controller/npcx_fiu_qspi.h          |   28 +
 .../dt-bindings/gpio/nuvoton-npcx-gpio.h      |   30 +
 soc/arm/nuvoton_npcx/Kconfig                  |    6 +-
 soc/arm/nuvoton_npcx/common/ecst/ecst.py      |    6 +-
 soc/arm/nuvoton_npcx/common/ecst/ecst_args.py |    5 +-
 soc/arm/nuvoton_npcx/common/pinctrl_soc.h     |   37 +
 soc/arm/nuvoton_npcx/common/reg/reg_access.h  |    4 +
 soc/arm/nuvoton_npcx/common/reg/reg_def.h     |  767 +++++++----
 soc/arm/nuvoton_npcx/common/registers.c       |   46 +-
 soc/arm/nuvoton_npcx/common/scfg.c            |   42 +-
 soc/arm/nuvoton_npcx/common/soc_clock.h       |   55 +-
 soc/arm/nuvoton_npcx/common/soc_dbg.h         |   26 +
 soc/arm/nuvoton_npcx/common/soc_espi_taf.h    |  138 ++
 soc/arm/nuvoton_npcx/common/soc_miwu.h        |   84 +-
 soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt     |   10 +
 .../npcx4/Kconfig.defconfig.npcx4m3f          |   11 +
 .../npcx4/Kconfig.defconfig.npcx4m8f          |   11 +
 .../npcx4/Kconfig.defconfig.series            |   28 +
 soc/arm/nuvoton_npcx/npcx4/Kconfig.series     |   16 +
 soc/arm/nuvoton_npcx/npcx4/Kconfig.soc        |   16 +
 soc/arm/nuvoton_npcx/npcx4/linker.ld          |    9 +
 soc/arm/nuvoton_npcx/npcx4/soc.c              |   36 +
 soc/arm/nuvoton_npcx/npcx4/soc.h              |   70 +
 103 files changed, 9213 insertions(+), 1157 deletions(-)
 create mode 100644 boards/arm/npcx4m8f_evb/Kconfig.board
 create mode 100644 boards/arm/npcx4m8f_evb/Kconfig.defconfig
 create mode 100644 boards/arm/npcx4m8f_evb/board.cmake
 create mode 100644 boards/arm/npcx4m8f_evb/doc/index.rst
 create mode 100644 boards/arm/npcx4m8f_evb/doc/npcx4m8f_evb.jpg
 create mode 100644 boards/arm/npcx4m8f_evb/npcx4m8f_evb-pinctrl.dtsi
 create mode 100644 boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts
 create mode 100644 boards/arm/npcx4m8f_evb/npcx4m8f_evb.yaml
 create mode 100644 boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig
 create mode 100644 boards/arm/npcx4m8f_evb/support/openocd.cfg
 create mode 100644 drivers/crypto/Kconfig.npcx
 create mode 100644 drivers/crypto/crypto_npcx_sha.c
 create mode 100644 drivers/espi/espi_saf_mchp_xec_v2.c
 create mode 100644 drivers/espi/espi_taf_npcx.c
 create mode 100644 drivers/flash/Kconfig.npcx_fiu
 create mode 100644 drivers/flash/flash_npcx_fiu_nor.c
 create mode 100644 drivers/flash/flash_npcx_fiu_qspi.c
 create mode 100644 drivers/flash/flash_npcx_fiu_qspi.h
 create mode 100644 drivers/led/Kconfig.xec
 create mode 100644 drivers/led/led_mchp_xec.c
 create mode 100644 dts/arm/nuvoton/npcx/npcx.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
 create mode 100644 dts/arm/nuvoton/npcx4m3f.dtsi
 create mode 100644 dts/arm/nuvoton/npcx4m8f.dtsi
 create mode 100644 include/zephyr/dt-bindings/clock/npck_clock.h
 create mode 100644 include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h
 create mode 100644 include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h
 mode change 100755 => 100644 soc/arm/nuvoton_npcx/common/ecst/ecst.py
 mode change 100755 => 100644 soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
 create mode 100644 soc/arm/nuvoton_npcx/common/soc_dbg.h
 create mode 100644 soc/arm/nuvoton_npcx/common/soc_espi_taf.h
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.series
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.soc
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/linker.ld
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/soc.c
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/soc.h

diff --git a/boards/arm/npcx4m8f_evb/Kconfig.board b/boards/arm/npcx4m8f_evb/Kconfig.board
new file mode 100644
index 0000000000..093faa1cad
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/Kconfig.board
@@ -0,0 +1,6 @@
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config BOARD_NPCX4M8F_EVB
+	bool "Nuvoton NPCX4M8F EVB Development board"
+	depends on SOC_NPCX4M8F
diff --git a/boards/arm/npcx4m8f_evb/Kconfig.defconfig b/boards/arm/npcx4m8f_evb/Kconfig.defconfig
new file mode 100644
index 0000000000..4ecd726fbd
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/Kconfig.defconfig
@@ -0,0 +1,16 @@
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if BOARD_NPCX4M8F_EVB
+
+config BOARD
+	default "npcx4m8f_evb"
+
+endif # BOARD_NPCX4M8F_EVB
+
+config SYS_CLOCK_TICKS_PER_SEC
+	default 1000
+
+config INPUT
+	bool "Input configuration option"
+	default y if KSCAN
diff --git a/boards/arm/npcx4m8f_evb/board.cmake b/boards/arm/npcx4m8f_evb/board.cmake
new file mode 100644
index 0000000000..51e7fd4c66
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/board.cmake
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: Apache-2.0
+
+board_runner_args(openocd --cmd-load "npcx_write_image")
+board_runner_args(openocd --cmd-verify "npcx_verify_image")
+
+include(${ZEPHYR_BASE}/boards/common/openocd.board.cmake)
diff --git a/boards/arm/npcx4m8f_evb/doc/index.rst b/boards/arm/npcx4m8f_evb/doc/index.rst
new file mode 100644
index 0000000000..a73d65d33d
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/doc/index.rst
@@ -0,0 +1,131 @@
+.. _npcx4m8f_evb:
+
+Nuvoton NPCX4M8F_EVB
+####################
+
+Overview
+********
+
+The NPCX4M8F_EVB kit is a development platform to evaluate the
+Nuvoton NPCX4 series microcontrollers. This board needs to be mated with
+part number NPCX498F.
+
+.. image:: npcx4m8f_evb.jpg
+     :align: center
+     :alt: NPCX4M8F Evaluation Board
+
+Hardware
+********
+
+- ARM Cortex-M4F Processor
+- 512 KB RAM and 64 KB boot ROM
+- ADC & GPIO headers
+- UART0 and UART1
+- FAN PWM interface
+- Jtag interface
+- Intel Modular Embedded Controller Card (MECC) headers
+
+Supported Features
+==================
+
+The following features are supported:
+
++-----------+------------+-------------------------------------+
+| Interface | Controller | Driver/Component                    |
++===========+============+=====================================+
+| NVIC      | on-chip    | nested vector interrupt controller  |
++-----------+------------+-------------------------------------+
+| ADC       | on-chip    | adc controller                      |
++-----------+------------+-------------------------------------+
+| CLOCK     | on-chip    | reset and clock control             |
++-----------+------------+-------------------------------------+
+| GPIO      | on-chip    | gpio                                |
++-----------+------------+-------------------------------------+
+| I2C       | on-chip    | i2c port/controller                 |
++-----------+------------+-------------------------------------+
+| PINMUX    | on-chip    | pinmux                              |
++-----------+------------+-------------------------------------+
+| PM        | on-chip    | power management                    |
++-----------+------------+-------------------------------------+
+| PSL       | on-chip    | power switch logic                  |
++-----------+------------+-------------------------------------+
+| PWM       | on-chip    | pulse width modulator               |
++-----------+------------+-------------------------------------+
+| TACH      | on-chip    | tachometer sensor                   |
++-----------+------------+-------------------------------------+
+| UART      | on-chip    | serial port-polling;                |
+|           |            | serial port-interrupt               |
++-----------+------------+-------------------------------------+
+| WDT       | on-chip    | watchdog                            |
++-----------+------------+-------------------------------------+
+
+Other hardware features are not currently supported by Zephyr (at the moment)
+
+The default configuration can be found in the defconfig file:
+``boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig``
+
+
+Connections and IOs
+===================
+
+Nuvoton to provide the schematic for this board.
+
+System Clock
+============
+
+The NPCX4M8F MCU is configured to use the 120Mhz internal oscillator with the
+on-chip PLL to generate a resulting EC clock rate of 15 MHz. See Processor clock
+control register (chapter 4 in user manual)
+
+Serial Port
+===========
+
+UART1 is configured for serial logs.
+
+Programming and Debugging
+*************************
+
+This board comes with a Cortex ETM port which facilitates tracing and debugging
+using a single physical connection. In addition, it comes with sockets for
+JTAG-only sessions.
+
+Flashing
+========
+
+If the correct headers are installed, this board supports both J-TAG and also
+the ChromiumOS servo.
+
+To flash using Servo V2, Î¼Servo, or Servo V4 (CCD), see the
+`Chromium EC Flashing Documentation`_ for more information.
+
+To flash with J-TAG, install the drivers for your programmer, for example:
+SEGGER J-link's drivers are at https://www.segger.com/downloads/jlink/
+
+The openocd from Zephyr SDK 0.16.1 doesn't include npcx4 support, so build openocd from source.::
+
+  sudo apt-get install libftdi-dev libusb-1.0.0-dev
+  git clone https://git.code.sf.net/p/openocd/code ~/openocd
+  cd ~/openocd
+  ./bootstrap
+  ./configure --enable-jlink --enable-ftdi
+  make clean
+  make
+  sudo make install
+
+Build and flash the blinky sample.::
+
+  west build -t clean && \
+    west build -c -p auto -b npcx4m8f_evb samples/basic/blinky && \
+    west flash --openocd /usr/local/bin/openocd
+
+Debugging
+=========
+
+Use JTAG/SWD with a J-Link
+
+References
+**********
+.. target-notes::
+
+.. _Chromium EC Flashing Documentation:
+   https://chromium.googlesource.com/chromiumos/platform/ec#Flashing-via-the-servo-debug-board
diff --git a/boards/arm/npcx4m8f_evb/doc/npcx4m8f_evb.jpg b/boards/arm/npcx4m8f_evb/doc/npcx4m8f_evb.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..369dd8b015015a7b505c28b3295c344f7ae55e51
GIT binary patch
literal 96434
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%0Dh<aikjN}F#Acg
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
VDQ=jsMK7~<R%jLJiTeLp_<y>?Xczzh

literal 0
HcmV?d00001

diff --git a/boards/arm/npcx4m8f_evb/npcx4m8f_evb-pinctrl.dtsi b/boards/arm/npcx4m8f_evb/npcx4m8f_evb-pinctrl.dtsi
new file mode 100644
index 0000000000..ab9df9c474
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/npcx4m8f_evb-pinctrl.dtsi
@@ -0,0 +1,16 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi>
+
+&i2c0_0_sda_scl_gpb4_b5 {
+	bias-pull-up; /* Enable internal pull-up for i2c0_0 */
+	pinmux-locked; /* Lock pinmuxing */
+};
+
+&pwm6_gpc0 {
+	drive-open-drain;
+};
diff --git a/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts b/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts
new file mode 100644
index 0000000000..c7aa5e4e62
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/npcx4m8f_evb.dts
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/dts-v1/;
+
+#include <nuvoton/npcx4m8f.dtsi>
+#include "npcx4m8f_evb-pinctrl.dtsi"
+
+/ {
+	model = "Nuvoton NPCX4M8F evaluation board";
+
+	chosen {
+		zephyr,sram = &sram0;
+		zephyr,console = &uart1;
+		zephyr,flash = &flash0;
+		zephyr,keyboard-scan = &kscan_input;
+	};
+
+	aliases {
+		pwm-led0 = &pwm_led0_green;
+		led0 = &gpio_led_red;
+		pwm-0 = &pwm6;
+		i2c-0 = &i2c0_0;
+		watchdog0 = &twd0;
+		peci-0 = &peci0;
+		spi-flash0 = &int_flash;
+		taf-flash = &int_flash;
+		/* For kscan test suites */
+		kscan0 = &kscan_input;
+	};
+
+	leds-pwm {
+		compatible = "pwm-leds";
+		pwm_led0_green: pwm_led_0 {
+			pwms = <&pwm6 0 PWM_MSEC(20) PWM_POLARITY_INVERTED>;
+			label = "User D7 green";
+		};
+	};
+
+	leds-gpio {
+		compatible = "gpio-leds";
+		gpio_led_red: led_0 {
+			gpios = <&gpio6 0 GPIO_ACTIVE_LOW>;
+			label = "User D8 red";
+		};
+	};
+};
+
+/* Overwrite default device properties with overlays in board dt file here. */
+&uart1 {
+	status = "okay";
+	current-speed = <115200>;
+	/* Use UART1_SL2 ie. PIN64.65 */
+	pinctrl-0 = <&uart1_2_sin_gp64 &uart1_2_sout_gp65>;
+	pinctrl-names = "default";
+};
+
+&pwm6 {
+	status = "okay";
+	pinctrl-0 = <&pwm6_gpc0>;
+	pinctrl-names = "default";
+};
+
+&adc0 {
+	status = "okay";
+	/* Use adc0 channel 0 and 2 for 'adc_api' driver tests */
+	pinctrl-0 = <&adc0_chan0_gp45 &adc0_chan2_gp43>;
+	pinctrl-names = "default";
+};
+
+&espi0 {
+	status = "okay";
+	pinctrl-0 = <&espi_lpc_gp46_47_51_52_53_54_55_57>;
+	pinctrl-names = "default";
+};
+
+&i2c0_0 {
+	status = "okay";
+	pinctrl-0 = <&i2c0_0_sda_scl_gpb4_b5>;
+	pinctrl-names = "default";
+	clock-frequency = <I2C_BITRATE_FAST>;
+};
+
+&i2c_ctrl0 {
+	status = "okay";
+};
+
+&tach1 {
+	status = "okay";
+	pinctrl-0 = <&ta1_1_in_gp40>;
+	pinctrl-names = "default";
+	port = <NPCX_TACH_PORT_A>;
+	sample-clk = <NPCX_TACH_FREQ_LFCLK>;
+	pulses-per-round = <1>;
+};
+
+&peci0 {
+	status = "okay";
+	pinctrl-0 = <&peci_dat_gp81>;
+	pinctrl-names = "default";
+};
+
+&kbd {
+	/* Demonstrate a 13 x 8 keyboard matrix on evb */
+	pinctrl-0 = <&ksi0_gp31 &ksi1_gp30 &ksi2_gp27 &ksi3_gp26
+		     &ksi4_gp25 &ksi5_gp24 &ksi6_gp23 &ksi7_gp22
+		     &kso00_gp21 &kso01_gp20 &kso02_gp17 &kso03_gp16
+		     &kso04_gp15 &kso05_gp14 &kso06_gp13 &kso07_gp12
+		     &kso08_gp11 &kso09_gp10 &kso10_gp07 &kso11_gp06
+		     &kso12_gp05>;
+	pinctrl-names = "default";
+	row-size = <8>;
+	col-size = <13>;
+	status = "okay";
+
+	kscan_input: kscan-input {
+		compatible = "zephyr,kscan-input";
+	};
+};
diff --git a/boards/arm/npcx4m8f_evb/npcx4m8f_evb.yaml b/boards/arm/npcx4m8f_evb/npcx4m8f_evb.yaml
new file mode 100644
index 0000000000..9e225f6163
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/npcx4m8f_evb.yaml
@@ -0,0 +1,26 @@
+#
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+identifier: npcx4m8f_evb
+name: Nuvoton NPCX4M8F EVB
+type: mcu
+arch: arm
+toolchain:
+  - zephyr
+  - gnuarmemb
+ram: 114
+flash: 384
+supported:
+  - adc
+  - clock
+  - gpio
+  - i2c
+  - pm
+  - pwm
+  - psl
+  - tach
+  - uart
+  - watchdog
diff --git a/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig b/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig
new file mode 100644
index 0000000000..4ec779de48
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/npcx4m8f_evb_defconfig
@@ -0,0 +1,38 @@
+#
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+CONFIG_SOC_NPCX4M8F=y
+CONFIG_SOC_SERIES_NPCX4=y
+CONFIG_BOARD_NPCX4M8F_EVB=y
+
+# Enable NPCX firmware header
+CONFIG_NPCX_HEADER=y
+CONFIG_NPCX_IMAGE_OUTPUT_HEX=y
+CONFIG_NPCX_HEADER_SPI_MAX_CLOCK_50=y
+CONFIG_NPCX_HEADER_SPI_READ_MODE_DUAL=y
+
+# Enable MPU
+CONFIG_ARM_MPU=y
+
+# Clock configuration
+CONFIG_CLOCK_CONTROL=y
+
+# General Kernel Options
+CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=15000000
+
+# UART Driver
+CONFIG_SERIAL=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
+
+# GPIO Driver
+CONFIG_GPIO=y
+
+# Pin Controller Driver
+CONFIG_PINCTRL=y
+
+# Console Driver
+CONFIG_CONSOLE=y
+CONFIG_UART_CONSOLE=y
diff --git a/boards/arm/npcx4m8f_evb/support/openocd.cfg b/boards/arm/npcx4m8f_evb/support/openocd.cfg
new file mode 100644
index 0000000000..cc9a73dc44
--- /dev/null
+++ b/boards/arm/npcx4m8f_evb/support/openocd.cfg
@@ -0,0 +1,16 @@
+# script for Nuvoton NPCX Cortex-M4 Series
+
+source [find interface/jlink.cfg]
+transport select swd
+
+set CHIPNAME npcx_v2
+set FIUNAME npcx_v2.fiu
+source [find target/npcx.cfg]
+
+proc npcx_write_image {target_image} {
+    flash write_image erase $target_image 0x64000000 ihex
+}
+
+proc npcx_verify_image {target_image} {
+    verify_image $target_image 0x64000000 ihex
+}
diff --git a/drivers/adc/Kconfig.npcx b/drivers/adc/Kconfig.npcx
index 8f48aefe76..0209fd845d 100644
--- a/drivers/adc/Kconfig.npcx
+++ b/drivers/adc/Kconfig.npcx
@@ -11,3 +11,19 @@ config ADC_NPCX
 	  This option enables the ADC driver for NPCX family of
 	  processors.
 	  Say y if you wish to use ADC channels on NPCX MCU.
+
+if ADC_NPCX
+
+config ADC_NPCX_CMP_V1
+	bool "ADC comparator version 1 support"
+	default y if SOC_SERIES_NPCX7 || SOC_SERIES_NPCX9
+	help
+	  This option enables ADC comparator V1 support.
+
+config ADC_NPCX_CMP_V2
+	bool "ADC comparator version 2 support"
+	default y if SOC_SERIES_NPCX4
+	help
+	  This option enables ADC comparator V2 support.
+
+endif #ADC_NPCX
diff --git a/drivers/adc/adc_npcx.c b/drivers/adc/adc_npcx.c
index aeae39fdef..cfbcb929d0 100644
--- a/drivers/adc/adc_npcx.c
+++ b/drivers/adc/adc_npcx.c
@@ -19,42 +19,48 @@
 #include "adc_context.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(adc_npcx, CONFIG_ADC_LOG_LEVEL);
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+/* ADC speed/delay values during initialization */
+#define ADC_REGULAR_DLY_VAL	0x02
+#define ADC_REGULAR_ADCCNF2_VAL	0x8901
+#define ADC_REGULAR_GENDLY_VAL	0x0100
+#define ADC_REGULAR_MEAST_VAL	0x0405
+#else
 /* ADC speed/delay values during initialization */
 #define ADC_REGULAR_DLY_VAL	0x03
 #define ADC_REGULAR_ADCCNF2_VAL	0x8B07
 #define ADC_REGULAR_GENDLY_VAL	0x0100
 #define ADC_REGULAR_MEAST_VAL	0x0001
-
-/* ADC channel number */
-#define NPCX_ADC_CH_COUNT DT_INST_PROP(0, channel_count)
+#endif
 
 /* ADC targeted operating frequency (2MHz) */
 #define NPCX_ADC_CLK 2000000
 
-/* ADC internal reference voltage (Unit:mV) */
-#define NPCX_ADC_VREF_VOL 2816
-
 /* ADC conversion mode */
 #define NPCX_ADC_CHN_CONVERSION_MODE	0
 #define NPCX_ADC_SCAN_CONVERSION_MODE	1
 
+/* Max channel number to be converted in ADCCS */
+#define NPCX_ADCCS_MAX_CHANNEL_COUNT	16
+
 #define ADC_NPCX_THRVAL_RESOLUTION	10
 #define ADC_NPCX_THRVAL_MAX		BIT_MASK(ADC_NPCX_THRVAL_RESOLUTION)
 
-#define THRCTL(dev, ctl_no) (*((volatile uint16_t *) npcx_thrctl_reg(dev, ctl_no)))
-
 /* Device config */
 struct adc_npcx_config {
 	/* adc controller base address */
 	uintptr_t base;
 	/* clock configuration */
 	struct npcx_clk_cfg clk_cfg;
+	/* the number of ADC channels */
+	const uint8_t channel_count;
 	/* amount of thresholds supported */
 	const uint8_t threshold_count;
-	/* threshold control register offset */
-	const uint16_t threshold_reg_offset;
+	/* routine for configuring ADC's ISR */
+	void (*irq_cfg_func)(void);
 	const struct pinctrl_dev_config *pcfg;
 };
 
@@ -74,7 +80,7 @@ struct adc_npcx_threshold_control {
 	/* Sets the threshold value to which measured data is compared. */
 	uint16_t thrval;
 	/*
-	 * Pointer of work queue thread to be notified when threshold assertion
+	 * Pointer of work queue item to be notified when threshold assertion
 	 * occurs.
 	 */
 	struct k_work *work;
@@ -87,7 +93,7 @@ struct adc_npcx_threshold_data {
 	 * channels being used in repetitive mode in order to set ADC registers
 	 * back to threshold detection when adc_npcx_read is completed.
 	 */
-	uint16_t repetitive_channels;
+	uint32_t repetitive_channels;
 	/*
 	 * While threshold interruption is enabled, adc_npcx_read must disable
 	 * all active threshold running to avoid race condition, this variable
@@ -109,7 +115,7 @@ struct adc_npcx_data {
 	 * Bit-mask indicating the channels to be included in each sampling
 	 * of this sequence.
 	 */
-	uint16_t channels;
+	uint32_t channels;
 	/* ADC Device pointer used in api functions */
 	const struct device *adc_dev;
 	uint16_t *buffer;
@@ -123,6 +129,12 @@ struct adc_npcx_data {
 #endif
 };
 
+/*
+ * Pointer of internal work queue thread to be notified when threshold assertion
+ * occurs if CONFIG_ADC_CMP_NPCX_WORKQUEUE is enabled.
+ */
+struct k_work_q *work_q;
+
 /* Driver convenience defines */
 #define HAL_INSTANCE(dev) ((struct adc_reg *)((const struct adc_npcx_config *)(dev)->config)->base)
 
@@ -144,12 +156,39 @@ static void adc_npcx_pm_policy_state_lock_put(struct adc_npcx_data *data)
 }
 #endif
 
-static inline uint32_t npcx_thrctl_reg(const struct device *dev,
-				       uint32_t ctl_no)
+static inline void adc_npcx_config_channels(const struct device *dev, uint32_t channels)
 {
 	const struct adc_npcx_config *config = dev->config;
+	struct adc_reg *const inst = HAL_INSTANCE(dev);
+
+	inst->ADCCS = channels & BIT_MASK(NPCX_ADCCS_MAX_CHANNEL_COUNT);
 
-	return (config->base + config->threshold_reg_offset) + (ctl_no - 1) * 2;
+	/* Only npcx4 and later series support over 16 ADC channels */
+	if (config->channel_count > NPCX_ADCCS_MAX_CHANNEL_COUNT) {
+		inst->ADCCS2 = (channels >> NPCX_ADCCS_MAX_CHANNEL_COUNT) &
+			       BIT_MASK(NPCX_ADCCS_MAX_CHANNEL_COUNT);
+	}
+}
+
+static inline void adc_npcx_enable_threshold_detect(const struct device *dev, uint8_t th_sel,
+						    bool enable)
+{
+	const struct adc_npcx_config *config = dev->config;
+
+	if (enable) {
+#ifdef CONFIG_ADC_NPCX_CMP_V2
+		THEN(config->base) |= BIT(th_sel);
+#else /* CONFIG_ADC_NPCX_CMP_V1 */
+		THRCTL(config->base, th_sel) |= BIT(NPCX_THRCTL_THEN);
+#endif
+
+	} else {
+#ifdef CONFIG_ADC_NPCX_CMP_V2
+		THEN(config->base) &= ~BIT(th_sel);
+#else /* CONFIG_ADC_NPCX_CMP_V1 */
+		THRCTL(config->base, th_sel) &= ~BIT(NPCX_THRCTL_THEN);
+#endif
+	}
 }
 
 static void adc_npcx_isr(const struct device *dev)
@@ -192,12 +231,12 @@ static void adc_npcx_isr(const struct device *dev)
 		if (IS_ENABLED(CONFIG_ADC_CMP_NPCX) &&
 		    t_data->active_thresholds) {
 			/* Set repetitive channels back */
-			inst->ADCCS = t_data->repetitive_channels;
+			adc_npcx_config_channels(dev, t_data->repetitive_channels);
 			/* Start conversion */
 			inst->ADCCNF |= BIT(NPCX_ADCCNF_START);
 		} else {
 			/* Disable all channels */
-			inst->ADCCS = 0;
+			adc_npcx_config_channels(dev, 0);
 			/* Turn off ADC */
 			inst->ADCCNF &= ~(BIT(NPCX_ADCCNF_ADCEN));
 
@@ -223,9 +262,10 @@ static void adc_npcx_isr(const struct device *dev)
 			/* Clear threshold status */
 			thrcts |= BIT(i);
 			inst->THRCTS = thrcts;
-			/* Notify work thread */
 			if (t_data->control[i].work) {
-				k_work_submit(t_data->control[i].work);
+				/* Notify work thread */
+				k_work_submit_to_queue(work_q ? work_q : &k_sys_work_q,
+						       t_data->control[i].work);
 			}
 		}
 	}
@@ -238,11 +278,12 @@ static void adc_npcx_isr(const struct device *dev)
 static int adc_npcx_validate_buffer_size(const struct device *dev,
 					const struct adc_sequence *sequence)
 {
+	const struct adc_npcx_config *config = dev->config;
 	uint8_t channels = 0;
 	uint32_t mask;
 	size_t needed;
 
-	for (mask = BIT(NPCX_ADC_CH_COUNT - 1); mask != 0; mask >>= 1) {
+	for (mask = BIT(config->channel_count - 1); mask != 0; mask >>= 1) {
 		if (mask & sequence->channels) {
 			channels++;
 		}
@@ -262,6 +303,7 @@ static int adc_npcx_validate_buffer_size(const struct device *dev,
 
 static void adc_npcx_start_scan(const struct device *dev)
 {
+	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_data *const data = dev->data;
 	struct adc_reg *const inst = HAL_INSTANCE(dev);
 
@@ -278,7 +320,7 @@ static void adc_npcx_start_scan(const struct device *dev)
 	inst->ADCSTS |= BIT(NPCX_ADCSTS_EOCCEV);
 
 	/* Update selected channels in scan mode by channels mask */
-	inst->ADCCS |= data->channels;
+	adc_npcx_config_channels(dev, data->channels);
 
 	/* Select 'Scan' Conversion mode. */
 	SET_FIELD(inst->ADCCNF, NPCX_ADCCNF_ADCMD_FIELD,
@@ -290,18 +332,24 @@ static void adc_npcx_start_scan(const struct device *dev)
 	/* Start conversion */
 	inst->ADCCNF |= BIT(NPCX_ADCCNF_START);
 
-	LOG_DBG("Start ADC scan conversion and ADCCNF,ADCCS are (%04X,%04X)\n",
+	if (config->channel_count > NPCX_ADCCS_MAX_CHANNEL_COUNT) {
+		LOG_DBG("Start ADC scan conversion and ADCCNF,ADCCS, ADCCS2 are "
+			"(%04X,%04X,%04X)\n", inst->ADCCNF, inst->ADCCS, inst->ADCCS2);
+	} else {
+		LOG_DBG("Start ADC scan conversion and ADCCNF,ADCCS are (%04X,%04X)\n",
 			inst->ADCCNF, inst->ADCCS);
+	}
 }
 
 static int adc_npcx_start_read(const struct device *dev,
 					const struct adc_sequence *sequence)
 {
+	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_data *const data = dev->data;
 	int error = 0;
 
 	if (!sequence->channels ||
-	    (sequence->channels & ~BIT_MASK(NPCX_ADC_CH_COUNT))) {
+	    (sequence->channels & ~BIT_MASK(config->channel_count))) {
 		LOG_ERR("Invalid ADC channels");
 		return -EINVAL;
 	}
@@ -356,9 +404,10 @@ static void adc_context_update_buffer_pointer(struct adc_context *ctx,
 static int adc_npcx_channel_setup(const struct device *dev,
 				 const struct adc_channel_cfg *channel_cfg)
 {
+	const struct adc_npcx_config *config = dev->config;
 	uint8_t channel_id = channel_cfg->channel_id;
 
-	if (channel_id >= NPCX_ADC_CH_COUNT) {
+	if (channel_id >= config->channel_count) {
 		LOG_ERR("Invalid channel %d", channel_id);
 		return -EINVAL;
 	}
@@ -435,18 +484,21 @@ static void adc_npcx_set_repetitive(const struct device *dev, int chnsel,
 		/* Set ADC conversion code to SW conversion mode */
 		SET_FIELD(inst->ADCCNF, NPCX_ADCCNF_ADCMD_FIELD,
 			  NPCX_ADC_SCAN_CONVERSION_MODE);
-		/* Update number of channel to be converted */
-		inst->ADCCS |= BIT(chnsel);
+
+		/* Add selected ADC channel to be converted */
+		t_data->repetitive_channels |= BIT(chnsel);
+		adc_npcx_config_channels(dev, t_data->repetitive_channels);
+
 		/* Set conversion type to repetitive (runs continuously) */
 		inst->ADCCNF |= BIT(NPCX_ADCCNF_ADCRPTC);
 
-		t_data->repetitive_channels |= BIT(chnsel);
 		/* Start conversion */
 		inst->ADCCNF |= BIT(NPCX_ADCCNF_START);
 	} else {
-		inst->ADCCS &= ~BIT(chnsel);
-
+		/* Remove selected ADC channel to be converted */
 		t_data->repetitive_channels &= ~BIT(chnsel);
+		adc_npcx_config_channels(dev, t_data->repetitive_channels);
+
 		if (!t_data->repetitive_channels) {
 			/* No thesholdd active left, disable repetitive mode */
 			inst->ADCCNF &= ~BIT(NPCX_ADCCNF_ADCRPTC);
@@ -485,7 +537,7 @@ int adc_npcx_threshold_ctrl_set_param(const struct device *dev,
 	adc_context_lock(&data->ctx, false, NULL);
 	switch (param->type) {
 	case ADC_NPCX_THRESHOLD_PARAM_CHNSEL:
-		if (param->val >= NPCX_ADC_CH_COUNT) {
+		if (param->val >= config->channel_count) {
 			ret = -EINVAL;
 			break;
 		}
@@ -522,6 +574,7 @@ static int adc_npcx_threshold_ctrl_setup(const struct device *dev,
 					 const uint8_t th_sel)
 {
 	struct adc_npcx_data *const data = dev->data;
+	struct adc_driver_api *api = (struct adc_driver_api *)dev->api;
 	struct adc_npcx_threshold_data *const t_data = data->threshold_data;
 	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_threshold_control *const t_ctrl =
@@ -540,24 +593,24 @@ static int adc_npcx_threshold_ctrl_setup(const struct device *dev,
 		return -EBUSY;
 	}
 
-	if (t_ctrl->chnsel >= NPCX_ADC_CH_COUNT ||
-	    t_ctrl->thrval >= NPCX_ADC_VREF_VOL ||
+	if (t_ctrl->chnsel >= config->channel_count ||
+	    t_ctrl->thrval >= api->ref_internal ||
 	    t_ctrl->thrval == 0 || t_ctrl->work == 0) {
 		adc_context_release(&data->ctx, 0);
 		LOG_ERR("Threshold selected (%d) is not configured!", th_sel);
 		return -EINVAL;
 	}
 
-	SET_FIELD(THRCTL(dev, (th_sel + 1)),
+	SET_FIELD(THRCTL(config->base, th_sel),
 		  NPCX_THRCTL_CHNSEL, t_ctrl->chnsel);
 
 	if (t_ctrl->l_h) {
-		THRCTL(dev, (th_sel + 1)) |= BIT(NPCX_THRCTL_L_H);
+		THRCTL(config->base, th_sel) |= BIT(NPCX_THRCTL_L_H);
 	} else {
-		THRCTL(dev, (th_sel + 1)) &= ~BIT(NPCX_THRCTL_L_H);
+		THRCTL(config->base, th_sel) &= ~BIT(NPCX_THRCTL_L_H);
 	}
 	/* Set the threshold value. */
-	SET_FIELD(THRCTL(dev, (th_sel + 1)), NPCX_THRCTL_THRVAL,
+	SET_FIELD(THRCTL(config->base, th_sel), NPCX_THRCTL_THRVAL,
 		  t_ctrl->thrval);
 
 	adc_context_release(&data->ctx, 0);
@@ -568,6 +621,7 @@ static int adc_npcx_threshold_enable_irq(const struct device *dev,
 				  const uint8_t th_sel)
 {
 	struct adc_reg *const inst = HAL_INSTANCE(dev);
+	struct adc_driver_api *api = (struct adc_driver_api *)dev->api;
 	struct adc_npcx_data *const data = dev->data;
 	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_threshold_data *const t_data = data->threshold_data;
@@ -581,8 +635,8 @@ static int adc_npcx_threshold_enable_irq(const struct device *dev,
 	}
 
 	adc_context_lock(&data->ctx, false, NULL);
-	if (t_ctrl->chnsel >= NPCX_ADC_CH_COUNT ||
-	    t_ctrl->thrval >= NPCX_ADC_VREF_VOL ||
+	if (t_ctrl->chnsel >= config->channel_count ||
+	    t_ctrl->thrval >= api->ref_internal ||
 	    t_ctrl->thrval == 0 || t_ctrl->work == 0) {
 		adc_context_release(&data->ctx, 0);
 		LOG_ERR("Threshold selected (%d) is not configured!", th_sel);
@@ -596,7 +650,7 @@ static int adc_npcx_threshold_enable_irq(const struct device *dev,
 	thrcts = inst->THRCTS & ~GENMASK(config->threshold_count - 1, 0);
 
 	/* Enable threshold detection */
-	THRCTL(dev, (th_sel + 1)) |= BIT(NPCX_THRCTL_THEN);
+	adc_npcx_enable_threshold_detect(dev, th_sel, true);
 
 	/* clear threshold status */
 	thrcts |= BIT(th_sel);
@@ -644,7 +698,7 @@ int adc_npcx_threshold_disable_irq(const struct device *dev,
 	inst->THRCTS = thrcts;
 
 	/* Disable threshold detection */
-	THRCTL(dev, (th_sel + 1)) &= ~BIT(NPCX_THRCTL_THEN);
+	adc_npcx_enable_threshold_detect(dev, th_sel, false);
 
 	/* Update active threshold */
 	t_data->active_thresholds &= ~BIT(th_sel);
@@ -679,59 +733,48 @@ int adc_npcx_threshold_ctrl_enable(const struct device *dev, uint8_t th_sel,
 	return ret;
 }
 
-int adc_npcx_threshold_mv_to_thrval(uint32_t val_mv, uint32_t *thrval)
+int adc_npcx_threshold_mv_to_thrval(const struct device *dev, uint32_t val_mv,
+								uint32_t *thrval)
 {
+	struct adc_driver_api *api = (struct adc_driver_api *)dev->api;
+
 	if (!IS_ENABLED(CONFIG_ADC_CMP_NPCX)) {
 		return -EOPNOTSUPP;
 	}
 
-	if (val_mv >= NPCX_ADC_VREF_VOL) {
+	if (val_mv >= api->ref_internal) {
 		return -EINVAL;
 	}
 
 	*thrval = (val_mv << ADC_NPCX_THRVAL_RESOLUTION) /
-		NPCX_ADC_VREF_VOL;
+		api->ref_internal;
 	return 0;
 }
 
-/* ADC driver registration */
-static const struct adc_driver_api adc_npcx_driver_api = {
-	.channel_setup = adc_npcx_channel_setup,
-	.read = adc_npcx_read,
-#if defined(CONFIG_ADC_ASYNC)
-	.read_async = adc_npcx_read_async,
-#endif
-	.ref_internal = NPCX_ADC_VREF_VOL,
-};
-
-static int adc_npcx_init(const struct device *dev);
+#if defined(CONFIG_ADC_CMP_NPCX_WORKQUEUE)
+struct k_work_q adc_npcx_work_q;
 
-PINCTRL_DT_INST_DEFINE(0);
-BUILD_ASSERT(DT_NUM_INST_STATUS_OKAY(DT_DRV_COMPAT) == 1,
-	"only one 'nuvoton_npcx_adc' compatible node may be present");
+static K_KERNEL_STACK_DEFINE(adc_npcx_work_q_stack,
+			CONFIG_ADC_CMP_NPCX_WORKQUEUE_STACK_SIZE);
 
-static const struct adc_npcx_config adc_npcx_cfg_0 = {
-	.base = DT_INST_REG_ADDR(0),
-	.clk_cfg = NPCX_DT_CLK_CFG_ITEM(0),
-	.threshold_count = DT_INST_PROP(0, threshold_count),
-	.threshold_reg_offset = DT_INST_PROP(0, threshold_reg_offset),
-	.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(0),
-};
+static int adc_npcx_init_cmp_work_q(void)
+{
+	struct k_work_queue_config cfg = {
+		.name = "adc_cmp_work",
+		.no_yield = false,
+	};
 
-static struct adc_npcx_threshold_data threshold_data_0;
+	k_work_queue_start(&adc_npcx_work_q,
+			   adc_npcx_work_q_stack,
+			   K_KERNEL_STACK_SIZEOF(adc_npcx_work_q_stack),
+			   CONFIG_ADC_CMP_NPCX_WORKQUEUE_PRIORITY, &cfg);
 
-static struct adc_npcx_data adc_npcx_data_0 = {
-	ADC_CONTEXT_INIT_TIMER(adc_npcx_data_0, ctx),
-	ADC_CONTEXT_INIT_LOCK(adc_npcx_data_0, ctx),
-	ADC_CONTEXT_INIT_SYNC(adc_npcx_data_0, ctx),
-};
+	work_q = &adc_npcx_work_q;
+	return 0;
+}
 
-DEVICE_DT_INST_DEFINE(0,
-		    adc_npcx_init, NULL,
-		    &adc_npcx_data_0, &adc_npcx_cfg_0,
-		    PRE_KERNEL_1,
-		    CONFIG_ADC_INIT_PRIORITY,
-		    &adc_npcx_driver_api);
+SYS_INIT(adc_npcx_init_cmp_work_q, POST_KERNEL, CONFIG_SENSOR_INIT_PRIORITY);
+#endif
 
 static int adc_npcx_init(const struct device *dev)
 {
@@ -750,14 +793,14 @@ static int adc_npcx_init(const struct device *dev)
 	data->adc_dev = dev;
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on ADC clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&config->clk_cfg, &data->input_clk);
 	if (ret < 0) {
 		LOG_ERR("Get ADC clock rate error %d", ret);
@@ -765,7 +808,7 @@ static int adc_npcx_init(const struct device *dev)
 	}
 
 	/* Configure the ADC clock */
-	prescaler = ceiling_fraction(data->input_clk, NPCX_ADC_CLK);
+	prescaler = DIV_ROUND_UP(data->input_clk, NPCX_ADC_CLK);
 	if (prescaler > 0x40) {
 		prescaler = 0x40;
 	}
@@ -781,14 +824,8 @@ static int adc_npcx_init(const struct device *dev)
 	inst->GENDLY = ADC_REGULAR_GENDLY_VAL;
 	inst->MEAST = ADC_REGULAR_MEAST_VAL;
 
-	if (IS_ENABLED(CONFIG_ADC_CMP_NPCX)) {
-		data->threshold_data = &threshold_data_0;
-	}
-
 	/* Configure ADC interrupt and enable it */
-	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority), adc_npcx_isr,
-			    DEVICE_DT_INST_GET(0), 0);
-	irq_enable(DT_INST_IRQN(0));
+	config->irq_cfg_func();
 
 	/* Initialize mutex of ADC channels */
 	adc_context_unlock_unconditionally(&data->ctx);
@@ -802,3 +839,45 @@ static int adc_npcx_init(const struct device *dev)
 
 	return 0;
 }
+
+#define NPCX_ADC_INIT(n)							\
+										\
+	static void adc_npcx_irq_cfg_func_##n(void)				\
+	{									\
+		IRQ_CONNECT(DT_INST_IRQN(n), DT_INST_IRQ(n, priority),		\
+			    adc_npcx_isr, DEVICE_DT_INST_GET(n), 0);		\
+		irq_enable(DT_INST_IRQN(n));					\
+	}									\
+										\
+	static const struct adc_driver_api adc_npcx_driver_api_##n = {		\
+		.channel_setup = adc_npcx_channel_setup,			\
+		.read = adc_npcx_read,						\
+		.ref_internal = DT_INST_PROP(n, vref_mv),			\
+		IF_ENABLED(CONFIG_ADC_ASYNC,					\
+			(.read_async = adc_npcx_read_async,))			\
+	};									\
+										\
+	PINCTRL_DT_INST_DEFINE(n);						\
+										\
+	static const struct adc_npcx_config adc_npcx_cfg_##n = {		\
+		.base = DT_INST_REG_ADDR(n),					\
+		.clk_cfg = NPCX_DT_CLK_CFG_ITEM(n),				\
+		.channel_count = DT_INST_PROP(n, channel_count),		\
+		.threshold_count = DT_INST_PROP(n, threshold_count),		\
+		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),			\
+		.irq_cfg_func = adc_npcx_irq_cfg_func_##n,			\
+	};									\
+	static struct adc_npcx_threshold_data threshold_data_##n;		\
+	static struct adc_npcx_data adc_npcx_data_##n = {			\
+		ADC_CONTEXT_INIT_TIMER(adc_npcx_data_##n, ctx),			\
+		ADC_CONTEXT_INIT_LOCK(adc_npcx_data_##n, ctx),			\
+		ADC_CONTEXT_INIT_SYNC(adc_npcx_data_##n, ctx),			\
+		.threshold_data = &threshold_data_##n,				\
+	};									\
+	DEVICE_DT_INST_DEFINE(n,						\
+			     adc_npcx_init, NULL,				\
+			     &adc_npcx_data_##n, &adc_npcx_cfg_##n,		\
+			     PRE_KERNEL_1, CONFIG_ADC_INIT_PRIORITY,		\
+			     &adc_npcx_driver_api_##n);
+
+DT_INST_FOREACH_STATUS_OKAY(NPCX_ADC_INIT)
diff --git a/drivers/bbram/bbram_npcx.c b/drivers/bbram/bbram_npcx.c
index 87c5166b77..b9b02f90eb 100644
--- a/drivers/bbram/bbram_npcx.c
+++ b/drivers/bbram/bbram_npcx.c
@@ -99,13 +99,6 @@ static const struct bbram_driver_api bbram_npcx_driver_api = {
 	.write = bbram_npcx_write,
 };
 
-static int bbram_npcx_init(const struct device *dev)
-{
-	ARG_UNUSED(dev);
-
-	return 0;
-}
-
 #define BBRAM_INIT(inst)                                                                           \
 	static struct {                                                                            \
 	} bbram_data_##inst;                                                                       \
@@ -114,7 +107,7 @@ static int bbram_npcx_init(const struct device *dev)
 		.size = DT_INST_REG_SIZE_BY_NAME(inst, memory),                                    \
 		.status_reg_addr = DT_INST_REG_ADDR_BY_NAME(inst, status),                         \
 	};                                                                                         \
-	DEVICE_DT_INST_DEFINE(inst, bbram_npcx_init, NULL, &bbram_data_##inst, &bbram_cfg_##inst,  \
+	DEVICE_DT_INST_DEFINE(inst, NULL, NULL, &bbram_data_##inst, &bbram_cfg_##inst,             \
 			      PRE_KERNEL_1, CONFIG_BBRAM_INIT_PRIORITY, &bbram_npcx_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(BBRAM_INIT);
diff --git a/drivers/clock_control/Kconfig.npcx b/drivers/clock_control/Kconfig.npcx
index b4b91d5f8d..76e5acf985 100644
--- a/drivers/clock_control/Kconfig.npcx
+++ b/drivers/clock_control/Kconfig.npcx
@@ -18,3 +18,15 @@ config CLOCK_CONTROL_NPCX_EXTERNAL_SRC
 	  is generated by the on-chip Crystal Oscillator (XTOSC).
 	  This includes an on-chip oscillator, to which an external crystal
 	  and the related passive components are connected.
+
+config CLOCK_CONTROL_NPCX_SUPP_APB4
+	bool "Indicates that the clock controller supports APB4 bus"
+	default y if !SOC_SERIES_NPCX7
+	help
+	  Selected if NPCX series supports APB4 bus.
+
+config CLOCK_CONTROL_NPCX_SUPP_FIU1
+	bool "Indicates that the clock controller supports FIU1 bus"
+	default y if SOC_SERIES_NPCX4
+	help
+	  Selected if NPCX series supports FIU1 bus.
diff --git a/drivers/clock_control/clock_control_mchp_xec.c b/drivers/clock_control/clock_control_mchp_xec.c
index a8731704a8..42a9e5b57e 100644
--- a/drivers/clock_control/clock_control_mchp_xec.c
+++ b/drivers/clock_control/clock_control_mchp_xec.c
@@ -559,11 +559,19 @@ static int xec_clock_control_get_subsys_rate(const struct device *dev,
 	switch (bus) {
 	case MCHP_XEC_PCR_CLK_CORE:
 	case MCHP_XEC_PCR_CLK_PERIPH_FAST:
-		*rate = MHZ(96);
+		if (pcr->TURBO_CLK & MCHP_PCR_TURBO_CLK_96M) {
+			*rate = MHZ(96);
+		} else {
+			*rate = MHZ(48);
+		}
 		break;
 	case MCHP_XEC_PCR_CLK_CPU:
 		/* if PCR PROC_CLK_CTRL is 0 the chip is not running */
-		*rate = MHZ(96) / pcr->PROC_CLK_CTRL;
+		if (pcr->TURBO_CLK & MCHP_PCR_TURBO_CLK_96M) {
+			*rate = MHZ(96) / pcr->PROC_CLK_CTRL;
+		} else {
+			*rate = MHZ(48) / pcr->PROC_CLK_CTRL;
+		}
 		break;
 	case MCHP_XEC_PCR_CLK_BUS:
 	case MCHP_XEC_PCR_CLK_PERIPH:
diff --git a/drivers/clock_control/clock_control_npcx.c b/drivers/clock_control/clock_control_npcx.c
index 82199d6111..345e575646 100644
--- a/drivers/clock_control/clock_control_npcx.c
+++ b/drivers/clock_control/clock_control_npcx.c
@@ -8,8 +8,11 @@
 
 #include <soc.h>
 #include <zephyr/drivers/clock_control.h>
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+#include <zephyr/dt-bindings/clock/npck_clock.h>
+#else /* NPCX7, NPCX9 and so on NPCX series */
 #include <zephyr/dt-bindings/clock/npcx_clock.h>
-
+#endif
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(clock_control_npcx, LOG_LEVEL_ERR);
 
@@ -28,6 +31,8 @@ struct npcx_pcc_config {
 #define HAL_PMC_INST(dev) \
 	((struct pmc_reg *)((const struct npcx_pcc_config *)(dev)->config)->base_pmc)
 
+static uint8_t pddwn_ctl_val[] = {NPCX_PWDWN_CTL_INIT};
+
 /* Clock controller local functions */
 static inline int npcx_clock_control_on(const struct device *dev,
 					 clock_control_subsys_t sub_system)
@@ -89,6 +94,11 @@ static int npcx_clock_control_get_subsys_rate(const struct device *dev,
 	case NPCX_CLOCK_BUS_FIU:
 		*rate = CORE_CLK/(FIUDIV_VAL + 1);
 		break;
+#if defined(FIU1DIV_VAL)
+	case NPCX_CLOCK_BUS_FIU1:
+		*rate = CORE_CLK/(FIU1DIV_VAL + 1);
+		break;
+#endif
 	case NPCX_CLOCK_BUS_CORE:
 		*rate = CORE_CLK;
 		break;
@@ -144,30 +154,36 @@ static struct clock_control_driver_api npcx_clock_control_api = {
 };
 
 /* valid clock frequency check */
-BUILD_ASSERT(CORE_CLK <= MHZ(100) && CORE_CLK >= MHZ(4) &&
+BUILD_ASSERT(OFMCLK <= MAX_OFMCLK, "Exceed maximum OFMCLK setting");
+BUILD_ASSERT(CORE_CLK <= MAX_OFMCLK && CORE_CLK >= MHZ(4) &&
 	     OFMCLK % CORE_CLK == 0 &&
 	     OFMCLK / CORE_CLK <= 10,
 	     "Invalid CORE_CLK setting");
-BUILD_ASSERT(CORE_CLK / (FIUDIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(CORE_CLK / (FIUDIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     CORE_CLK / (FIUDIV_VAL + 1) >= MHZ(4),
 	     "Invalid FIUCLK setting");
-BUILD_ASSERT(CORE_CLK / (AHB6DIV_VAL + 1) <= MHZ(50) &&
+#if defined(FIU1DIV_VAL)
+BUILD_ASSERT(CORE_CLK / (FIU1DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
+	     CORE_CLK / (FIU1DIV_VAL + 1) >= MHZ(4),
+	     "Invalid FIU1CLK setting");
+#endif
+BUILD_ASSERT(CORE_CLK / (AHB6DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     CORE_CLK / (AHB6DIV_VAL + 1) >= MHZ(4),
 	     "Invalid AHB6_CLK setting");
-BUILD_ASSERT(APBSRC_CLK / (APB1DIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(APBSRC_CLK / (APB1DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     APBSRC_CLK / (APB1DIV_VAL + 1) >= MHZ(4) &&
 	     (APB1DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB1_CLK setting");
-BUILD_ASSERT(APBSRC_CLK / (APB2DIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(APBSRC_CLK / (APB2DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     APBSRC_CLK / (APB2DIV_VAL + 1) >= MHZ(8) &&
 	     (APB2DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB2_CLK setting");
-BUILD_ASSERT(APBSRC_CLK / (APB3DIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(APBSRC_CLK / (APB3DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     APBSRC_CLK / (APB3DIV_VAL + 1) >= KHZ(12500) &&
 	     (APB3DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB3_CLK setting");
 #if defined(APB4DIV_VAL)
-BUILD_ASSERT(APBSRC_CLK / (APB4DIV_VAL + 1) <= MHZ(100) &&
+BUILD_ASSERT(APBSRC_CLK / (APB4DIV_VAL + 1) <= MAX_OFMCLK &&
 	     APBSRC_CLK / (APB4DIV_VAL + 1) >= MHZ(8) &&
 	     (APB4DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB4_CLK setting");
@@ -205,36 +221,23 @@ static int npcx_clock_control_init(const struct device *dev)
 	}
 
 	/* Set all clock prescalers of core and peripherals. */
-	inst_cdcg->HFCGP   = ((FPRED_VAL << 4) | AHB6DIV_VAL);
-	inst_cdcg->HFCBCD  = (FIUDIV_VAL << 4);
-	inst_cdcg->HFCBCD1 = (APB1DIV_VAL | (APB2DIV_VAL << 4));
-#if defined(APB4DIV_VAL)
-	inst_cdcg->HFCBCD2 = (APB3DIV_VAL | (APB4DIV_VAL << 4));
-#else
-	inst_cdcg->HFCBCD2 = APB3DIV_VAL;
-#endif
+	inst_cdcg->HFCGP   = VAL_HFCGP;
+	inst_cdcg->HFCBCD  = VAL_HFCBCD;
+	inst_cdcg->HFCBCD1 = VAL_HFCBCD1;
+	inst_cdcg->HFCBCD2 = VAL_HFCBCD2;
 
 	/*
 	 * Power-down (turn off clock) the modules initially for better
 	 * power consumption.
 	 */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL1) = 0xFB; /* No SDP_PD/FIU_PD */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL2) = 0xFF;
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL3) = 0x1F; /* No GDMA_PD */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL4) = 0xFF;
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL5) = 0xFA;
-#if CONFIG_ESPI
-	/* Don't gate the clock of the eSPI module if eSPI interface is required */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL6) = 0x7F;
-#else
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL6) = 0xFF;
-#endif
-#if defined(CONFIG_SOC_SERIES_NPCX7)
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL7) = 0xE7;
-#elif defined(CONFIG_SOC_SERIES_NPCX9)
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL7) = 0xFF;
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL8) = 0x31;
-#endif
+	for (int i = 0; i < ARRAY_SIZE(pddwn_ctl_val); i++) {
+		NPCX_PWDWN_CTL(pmc_base, i) = pddwn_ctl_val[i];
+	}
+
+	/* Turn off the clock of the eSPI module only if eSPI isn't required */
+	if (!IS_ENABLED(CONFIG_ESPI)) {
+		NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL6) |= BIT(7);
+	}
 
 	return 0;
 }
diff --git a/drivers/console/uart_console.c b/drivers/console/uart_console.c
index 0515e31e83..1be0863ab0 100644
--- a/drivers/console/uart_console.c
+++ b/drivers/console/uart_console.c
@@ -490,7 +490,7 @@ static void uart_console_isr(const struct device *unused, void *user_data)
 		}
 
 		/* Handle special control characters */
-		if (!isprint(byte)) {
+		if (isprint(byte) == 0) {
 			switch (byte) {
 			case BS:
 			case DEL:
diff --git a/drivers/crypto/CMakeLists.txt b/drivers/crypto/CMakeLists.txt
index 3887f67599..5bccb12ff8 100644
--- a/drivers/crypto/CMakeLists.txt
+++ b/drivers/crypto/CMakeLists.txt
@@ -7,4 +7,5 @@ zephyr_library_sources_ifdef(CONFIG_CRYPTO_MBEDTLS_SHIM		crypto_mtls_shim.c)
 zephyr_library_sources_ifdef(CONFIG_CRYPTO_STM32			crypto_stm32.c)
 zephyr_library_sources_ifdef(CONFIG_CRYPTO_NRF_ECB		crypto_nrf_ecb.c)
 zephyr_library_sources_ifdef(CONFIG_CRYPTO_INTEL_SHA		crypto_intel_sha.c)
+zephyr_library_sources_ifdef(CONFIG_CRYPTO_NPCX_SHA		crypto_npcx_sha.c)
 zephyr_library_link_libraries_ifdef(CONFIG_MBEDTLS mbedTLS)
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index f257c53231..c9c5a203bd 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -76,5 +76,6 @@ source "drivers/crypto/Kconfig.ataes132a"
 source "drivers/crypto/Kconfig.stm32"
 source "drivers/crypto/Kconfig.nrf_ecb"
 source "drivers/crypto/Kconfig.intel"
+source "drivers/crypto/Kconfig.npcx"
 
 endif # CRYPTO
diff --git a/drivers/crypto/Kconfig.npcx b/drivers/crypto/Kconfig.npcx
new file mode 100644
index 0000000000..80ce1b28f6
--- /dev/null
+++ b/drivers/crypto/Kconfig.npcx
@@ -0,0 +1,11 @@
+# NPCX SHA driver configuration options
+
+# Copyright (c) 2022 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config CRYPTO_NPCX_SHA
+	bool "NPCX SHA driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_SHA_ENABLED
+	help
+	  Enable NPCX SHA driver.
diff --git a/drivers/crypto/crypto_npcx_sha.c b/drivers/crypto/crypto_npcx_sha.c
new file mode 100644
index 0000000000..2640359936
--- /dev/null
+++ b/drivers/crypto/crypto_npcx_sha.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2022 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_sha
+
+#include <errno.h>
+#include <zephyr/kernel.h>
+#include <zephyr/crypto/crypto.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(sha_npcx, CONFIG_CRYPTO_LOG_LEVEL);
+
+#define NPCX_HASH_CAPS_SUPPORT	(CAP_SEPARATE_IO_BUFS | CAP_SYNC_OPS)
+#define NPCX_SHA256_HANDLE_SIZE DT_INST_PROP(0, context_buffer_size)
+#define NPCX_SHA_MAX_SESSION	1
+
+/* The status code returns from Nuvoton Cryptographic Library ROM APIs */
+enum ncl_status {
+	NCL_STATUS_OK = 0xA5A5,
+	NCL_STATUS_FAIL = 0x5A5A,
+	NCL_STATUS_INVALID_PARAM = 0x02,
+	NCL_STATUS_PARAM_NOT_SUPPORTED,
+	NCL_STATUS_SYSTEM_BUSY,
+	NCL_STATUS_AUTHENTICATION_FAIL,
+	NCL_STATUS_NO_RESPONSE,
+	NCL_STATUS_HARDWARE_ERROR,
+};
+enum ncl_sha_type {
+	NCL_SHA_TYPE_2_256 = 0,
+	NCL_SHA_TYPE_2_384 = 1,
+	NCL_SHA_TYPE_2_512 = 2,
+	NCL_SHA_TYPE_NUM
+};
+
+/* The following table holds the function pointer for each SHA API in NPCX ROM. */
+struct npcx_ncl_sha {
+	/* Get the SHA context size required by SHA APIs. */
+	uint32_t (*get_context_size)(void);
+	/* Initial SHA context. */
+	enum ncl_status (*init_context)(void *ctx);
+	/* Finalize SHA context. */
+	enum ncl_status (*finalize_context)(void *ctx);
+	/* Initiate the SHA hardware module and setups needed parameters. */
+	enum ncl_status (*init)(void *ctx);
+	/*
+	 * Prepare the context buffer for a SHA calculation -  by loading the
+	 * initial SHA-256/384/512 parameters.
+	 */
+	enum ncl_status (*start)(void *ctx, enum ncl_sha_type type);
+	/*
+	 * Updates the SHA calculation with the additional data. When the
+	 * function returns, the hardware and memory buffer shall be ready to
+	 * accept new data * buffers for SHA calculation and changes to the data
+	 * in data buffer should no longer effect the SHA calculation.
+	 */
+	enum ncl_status (*update)(void *ctx, const uint8_t *data, uint32_t Len);
+	/* Return the SHA result (digest.) */
+	enum ncl_status (*finish)(void *ctx, uint8_t *hashDigest);
+	/* Perform a complete SHA calculation */
+	enum ncl_status (*calc)(void *ctx, enum ncl_sha_type type, const uint8_t *data,
+				uint32_t Len, uint8_t *hashDigest);
+	/* Power on/off the SHA module. */
+	enum ncl_status (*power)(void *ctx, uint8_t enable);
+	/* Reset the SHA hardware and terminate any in-progress operations. */
+	enum ncl_status (*reset)(void *ctx);
+};
+
+/* The start address of the SHA API table. */
+#define NPCX_NCL_SHA ((const struct npcx_ncl_sha *)DT_INST_REG_ADDR(0))
+
+struct npcx_sha_context {
+	uint8_t handle[NPCX_SHA256_HANDLE_SIZE];
+} __aligned(4);
+
+struct npcx_sha_session {
+	struct npcx_sha_context npcx_sha_ctx;
+	enum hash_algo algo;
+	bool in_use;
+};
+
+struct npcx_sha_session npcx_sessions[NPCX_SHA_MAX_SESSION];
+
+static int npcx_get_unused_session_index(void)
+{
+	int i;
+
+	for (i = 0; i < NPCX_SHA_MAX_SESSION; i++) {
+		if (!npcx_sessions[i].in_use) {
+			npcx_sessions[i].in_use = true;
+			return i;
+		}
+	}
+
+	return -1;
+}
+static int npcx_sha_compute(struct hash_ctx *ctx, struct hash_pkt *pkt, bool finish)
+{
+	enum ncl_status ret;
+	struct npcx_sha_session *npcx_session = ctx->drv_sessn_state;
+	struct npcx_sha_context *npcx_ctx = &npcx_session->npcx_sha_ctx;
+	enum ncl_sha_type sha_type;
+
+	switch (npcx_session->algo) {
+	case CRYPTO_HASH_ALGO_SHA256:
+		sha_type = NCL_SHA_TYPE_2_256;
+		break;
+	case CRYPTO_HASH_ALGO_SHA384:
+		sha_type = NCL_SHA_TYPE_2_384;
+		break;
+	case CRYPTO_HASH_ALGO_SHA512:
+		sha_type = NCL_SHA_TYPE_2_512;
+		break;
+	default:
+		LOG_ERR("Unexpected algo: %d", npcx_session->algo);
+		return -EINVAL;
+	}
+
+	if (!ctx->started) {
+		ret = NPCX_NCL_SHA->start(npcx_ctx->handle, sha_type);
+		if (ret != NCL_STATUS_OK) {
+			LOG_ERR("Could not compute the hash, err:%d", ret);
+			return -EINVAL;
+		}
+		ctx->started = true;
+	}
+
+	if (pkt->in_len != 0) {
+		ret = NPCX_NCL_SHA->update(npcx_ctx->handle, pkt->in_buf, pkt->in_len);
+		if (ret != NCL_STATUS_OK) {
+			LOG_ERR("Could not update the hash, err:%d", ret);
+			ctx->started = false;
+			return -EINVAL;
+		}
+	}
+
+	if (finish) {
+		ctx->started = false;
+		ret = NPCX_NCL_SHA->finish(npcx_ctx->handle, pkt->out_buf);
+		if (ret != NCL_STATUS_OK) {
+			LOG_ERR("Could not compute the hash, err:%d", ret);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int npcx_hash_session_setup(const struct device *dev, struct hash_ctx *ctx,
+				   enum hash_algo algo)
+{
+	int ctx_idx;
+	struct npcx_sha_context *npcx_ctx;
+
+	if (ctx->flags & ~(NPCX_HASH_CAPS_SUPPORT)) {
+		LOG_ERR("Unsupported flag");
+		return -EINVAL;
+	}
+
+	if ((algo != CRYPTO_HASH_ALGO_SHA256) && (algo != CRYPTO_HASH_ALGO_SHA384) &&
+	    (algo != CRYPTO_HASH_ALGO_SHA512)) {
+		LOG_ERR("Unsupported algo: %d", algo);
+		return -EINVAL;
+	}
+
+	ctx_idx = npcx_get_unused_session_index();
+	if (ctx_idx < 0) {
+		LOG_ERR("No free session for now");
+		return -ENOSPC;
+	}
+
+	npcx_sessions[ctx_idx].algo = algo;
+
+	ctx->drv_sessn_state = &npcx_sessions[ctx_idx];
+	ctx->started = false;
+	ctx->hash_hndlr = npcx_sha_compute;
+
+	npcx_ctx = &npcx_sessions[ctx_idx].npcx_sha_ctx;
+	NPCX_NCL_SHA->init_context(npcx_ctx->handle);
+	NPCX_NCL_SHA->power(npcx_ctx->handle, 1);
+	NPCX_NCL_SHA->init(npcx_ctx->handle);
+	NPCX_NCL_SHA->reset(npcx_ctx->handle);
+
+	return 0;
+}
+
+static int npcx_hash_session_free(const struct device *dev, struct hash_ctx *ctx)
+{
+	struct npcx_sha_session *npcx_session = ctx->drv_sessn_state;
+	struct npcx_sha_context *npcx_ctx = &npcx_session->npcx_sha_ctx;
+
+	NPCX_NCL_SHA->reset(npcx_ctx->handle);
+	NPCX_NCL_SHA->power(npcx_ctx->handle, 0);
+	NPCX_NCL_SHA->finalize_context(npcx_ctx->handle);
+	npcx_session->in_use = false;
+
+	return 0;
+}
+
+static int npcx_query_caps(const struct device *dev)
+{
+	return NPCX_HASH_CAPS_SUPPORT;
+}
+
+static struct crypto_driver_api npcx_crypto_api = {
+	.hash_begin_session = npcx_hash_session_setup,
+	.hash_free_session = npcx_hash_session_free,
+	.query_hw_caps = npcx_query_caps,
+};
+
+DEVICE_DT_INST_DEFINE(0, NULL, NULL, NULL, NULL, POST_KERNEL, CONFIG_CRYPTO_INIT_PRIORITY,
+		      &npcx_crypto_api);
+BUILD_ASSERT(DT_NUM_INST_STATUS_OKAY(DT_DRV_COMPAT) == 1,
+	     "only one 'nuvoton,npcx-sha' compatible node can be supported");
diff --git a/drivers/espi/CMakeLists.txt b/drivers/espi/CMakeLists.txt
index 82e257098f..5379d00ea2 100644
--- a/drivers/espi/CMakeLists.txt
+++ b/drivers/espi/CMakeLists.txt
@@ -1,13 +1,17 @@
 # SPDX-License-Identifier: Apache-2.0
 
+zephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/drivers/espi.h)
+
 zephyr_library()
 
 zephyr_library_sources_ifdef(CONFIG_ESPI_XEC		espi_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_NPCX		espi_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_NPCX		host_subs_npcx.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_TAF_NPCX	espi_taf_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_USERSPACE		espi_handlers.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_EMUL		espi_emul.c)
-zephyr_library_sources_ifdef(CONFIG_ESPI_SAF		espi_saf_mchp_xec.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_SAF_XEC	espi_saf_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_XEC_V2		espi_mchp_xec_v2.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_XEC_V2		espi_mchp_xec_host_v2.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_IT8XXX2	espi_it8xxx2.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_SAF_XEC_V2	espi_saf_mchp_xec_v2.c)
diff --git a/drivers/espi/Kconfig b/drivers/espi/Kconfig
index 3c4de413c8..f8ee937af5 100644
--- a/drivers/espi/Kconfig
+++ b/drivers/espi/Kconfig
@@ -12,8 +12,6 @@ if ESPI
 
 source "drivers/espi/Kconfig.xec"
 
-source "drivers/espi/Kconfig.xec_v2"
-
 source "drivers/espi/Kconfig.npcx"
 
 source "drivers/espi/Kconfig.espi_emul"
@@ -178,4 +176,19 @@ config ESPI_OOB_CHANNEL_RX_ASYNC
 	  Enables asynchronous handling for host-initiated OOB traffic.
 	  Otherwise OOB traffic is assumed to be always client-initiated.
 
+config ESPI_SAF
+	bool "ESPI SAF driver"
+	depends on ESPI_FLASH_CHANNEL
+	help
+	  Enable Slave Attached Flash eSPI driver. SAF depends upon ESPI driver
+	  and flash channel.
+
+config ESPI_SAF_INIT_PRIORITY
+	int "ESPI SAF driver initialization priority"
+	depends on ESPI_SAF
+	default 4
+	help
+	  Driver initialization priority for eSPI SAF driver. SAF driver must
+	  initialize after the ESPI driver.
+
 endif # ESPI
diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index f19d7ee46b..516adf4397 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -41,6 +41,51 @@ config ESPI_NPCX_BYPASS_CH_ENABLE_FATAL_ERROR
 	  a wrong state and therefore response with FATAL_ERROR on an incoming
 	  transaction.
 
+config ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	bool "Host can write 1/2/4 bytes of Port80 data in a eSPI transaction"
+	depends on SOC_SERIES_NPCX9 && ESPI_PERIPHERAL_DEBUG_PORT_80
+	help
+	  EC can accept 1/2/4 bytes of Port 80 data written from the Host in an
+	  eSPI transaction.
+
+config ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_RING_BUF_SIZE
+	int "Debug Port80 ring buffer size"
+	depends on ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	default 256
+	help
+	  The size of the ring buffer in byte used by the Port80 ISR to store
+	  Postcodes from Host.
+
+config ESPI_TAF_NPCX
+	bool "Nuvoton NPCX embedded controller (EC) ESPI TAF driver"
+	depends on SOC_SERIES_NPCX4 || SOC_SERIES_NPCK3
+	help
+	  This option enables the Intel Enhanced Serial Peripheral Interface
+	  Target Attached Flash (eSPI TAF) for NPCX4 family of processors.
+
+choice ESPI_TAF_ACCESS_MODE_CHOICE
+	prompt "set TX/RX mode for eSPI TAF"
+	default ESPI_TAF_DIRECT_ACCESS
+
+config ESPI_TAF_DIRECT_ACCESS
+	bool "eSPI TAF access buffer directly"
+	help
+	  This is the setting to use direct mode for eSPI TAF.
+
+config ESPI_TAF_INDIRECT_ACCESS
+	bool "eSPI TAF access buffer indirectly"
+	help
+	  This is the setting to use indirect mode for eSPI TAF.
+
+endchoice
+
+config ESPI_TAF_PR_NUM
+	int "Sets of protection region settings"
+	default 16
+	help
+	  This size is display how many group of slave attached flash protection
+	  region.
+
 # The default value 'y' for the existing options if ESPI_NPCX is selected.
 if ESPI_NPCX
 
@@ -65,4 +110,10 @@ config ESPI_PERIPHERAL_ACPI_SHM_REGION
 config ESPI_PERIPHERAL_CUSTOM_OPCODE
 	default y
 
+config ESPI_NPCX_SUPP_VW_GPIO
+	bool "Indicates that the eSPI hardware supports virtual wire GPIOs"
+	default y if SOC_SERIES_NPCX9 || SOC_SERIES_NPCX4
+	help
+	  Selected if NPCX series supports virtual wire GPIOs in eSPI module.
+
 endif #ESPI_NPCX
diff --git a/drivers/espi/Kconfig.xec b/drivers/espi/Kconfig.xec
index b6fde723b7..7c9285dbf3 100644
--- a/drivers/espi/Kconfig.xec
+++ b/drivers/espi/Kconfig.xec
@@ -5,11 +5,17 @@
 
 config ESPI_XEC
 	bool "XEC Microchip ESPI driver"
-	depends on SOC_SERIES_MEC1501X
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_ENABLED
 	help
 	  Enable the Microchip XEC ESPI driver for MEC15xx family.
 
-if ESPI_XEC
+config ESPI_XEC_V2
+	bool "XEC Microchip ESPI V2 driver"
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_V2_ENABLED
+	help
+	  Enable the Microchip XEC ESPI driver for MEC172x series.
+
+if ESPI_XEC || ESPI_XEC_V2
 
 config ESPI_OOB_CHANNEL
 	default y
@@ -55,6 +61,97 @@ config ESPI_FLASH_BUFFER_SIZE
 	  Use maximum RAM buffer size defined by spec but allow applications
 	  to override if eSPI host doesn't support it.
 
+config ESPI_SAF_XEC
+	bool "XEC Microchip ESPI SAF driver"
+	default y
+	depends on SOC_SERIES_MEC1501X
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_ENABLED
+	help
+	  Enable the Microchip XEC SAF ESPI driver for MEC15xx family.
+
+config ESPI_SAF_XEC_V2
+	bool "XEC Microchip ESPI SAF V2 driver"
+	default y
+	depends on SOC_SERIES_MEC172X
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_V2_ENABLED
+	help
+	  Enable the Microchip XEC SAF ESPI driver for MEC172x series.
+
+endif #ESPI_XEC
+
+if ESPI_XEC_V2
+
+config ESPI_XEC_PERIPHERAL_ACPI_SHD_MEM_SIZE
+	int "Host I/O peripheral port size for shared memory in MEC172X series"
+	depends on ESPI_XEC_V2 || ESPI_PERIPHERAL_ACPI_SHM_REGION
+	default 256
+	help
+	  This is the port size used by the Host and EC to communicate over
+	  the shared memory region to return the ACPI response data.
+
+config ESPI_XEC_PERIPHERAL_HOST_CMD_PARAM_SIZE
+	int "Host I/O peripheral port size for ec host command in MEC172X series"
+	depends on ESPI_XEC_V2 || ESPI_PERIPHERAL_EC_HOST_CMD
+	default 256
+	help
+	  This is the port size used by the Host and EC to communicate over
+	  the shared memory region to return the host command parameter data.
+
+config ESPI_PERIPHERAL_8042_KBC
+	default y
+
+if ESPI_PERIPHERAL_CHANNEL
+
+config ESPI_PERIPHERAL_XEC_MAILBOX
+	bool "SoC Mailbox over eSPI"
+	help
+	  Enable a 32 byte mailbox interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_EC2
+	bool "SoC ACPI EC 2 over eSPI"
+	help
+	  Enable ACPI EC2 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_EC3
+	bool "SoC ACPI EC 3 over eSPI"
+	help
+	  Enable ACPI EC3 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_EC4
+	bool "SoC ACPI EC 4 over eSPI"
+	help
+	  Enable ACPI EC4 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_PM1
+	bool "SoC ACPI PM1 over eSPI"
+	help
+	  Enable ACPI PM1 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_EMI0
+	bool "SoC EMI 0 over eSPI"
+	help
+	  Enable EMI 0 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_EMI1
+	bool "SoC EMI 1 over eSPI"
+	help
+	  Enable EMI 1 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_EMI2
+	bool "SoC EMI 2 over eSPI"
+	help
+	  Enable EMI 2 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+endif #ESPI_PERIPHERAL_CHANNEL
+
 config ESPI_SAF
 	bool "XEC Microchip ESPI SAF driver"
 	depends on ESPI_FLASH_CHANNEL
@@ -69,4 +166,26 @@ config ESPI_SAF_INIT_PRIORITY
 	help
 	  Driver initialization priority for eSPI SAF driver.
 
-endif #ESPI_XEC
+config ESPI_PERIPHERAL_ACPI_EC_IBF_EVT_DATA
+	bool "Read ACPI EC Event Data in IBF ISR"
+	depends on ESPI_PERIPHERAL_CHANNEL
+	help
+	  Enable reading event data in ACPI EC IBF ISR. This is used in OS
+	  environment where application expects IBF ISR to read data and pass
+	  to callback.
+
+endif #ESPI_XEC_V2
+
+if ESPI_XEC_V2 && ESPI_PERIPHERAL_8042_KBC
+
+config ESPI_PERIPHERAL_KBC_IBF_EVT_DATA
+	bool "KBC event data format in IBF"
+	help
+	  Enable espi_evt_data_kbc format for encoding event in KBC IBF ISR
+
+config ESPI_PERIPHERAL_KBC_OBE_CBK
+	bool "KBC OBE Callback"
+	help
+	  Enable KBC OBE callback from OBE ISR
+
+endif #ESPI_XEC_V2 && ESPI_PERIPHERAL_8042_KBC
diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index f04c910fe1..027c1b1033 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -434,7 +434,26 @@ static int espi_xec_write_lpc_request(const struct device *dev,
 
 	return 0;
 }
+static int espi_xec_send_ltr(const struct device *dev, struct ltr_cfg_pkt *req)
+{
+	if (!(ESPI_PC_REGS->PC_STATUS & MCHP_ESPI_PC_STS_BM_EN)) {
+		return -ENOTSUP;
+	}
 
+	if (req->ltr_req) {
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_VAL |
+				(req->latency << MCHP_ESPI_LTR_MSG_VAL_POS) |
+				(req->ltr_scale << MCHP_ESPI_LTR_MSG_SC_POS);
+	} else {
+		/* set infinite latency tolrated */
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_INF;
+	}
+
+	/* Send LTR Packet */
+	ESPI_LTR_REGS->LTR_CTRL = MCHP_ESPI_LTR_CTRL_START;
+
+	return 0;
+}
 static int espi_xec_send_vwire(const struct device *dev,
 			       enum espi_vwire_signal signal, uint8_t level)
 {
@@ -965,6 +984,10 @@ static void setup_espi_io_config(const struct device *dev,
 static void espi_pc_isr(const struct device *dev)
 {
 	uint32_t status = ESPI_PC_REGS->PC_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_CHANNEL_READY,
+				  .evt_details = ESPI_CHANNEL_PERIPHERAL,
+				  .evt_data = 0 };
+	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
 
 	if (status & MCHP_ESPI_PC_STS_EN_CHG) {
 		if (status & MCHP_ESPI_PC_STS_EN) {
@@ -972,6 +995,13 @@ static void espi_pc_isr(const struct device *dev)
 		}
 
 		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
+	} else if (status & MCHP_ESPI_PC_STS_BM_EN_CHG) {
+		if (status & MCHP_ESPI_PC_STS_BM_EN) {
+			evt.evt_data = ESPI_PC_EVT_BUS_MASTER_ENABLE;
+			espi_send_callbacks(&data->callbacks, dev, evt);
+		}
+
+		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_BM_EN_CHG;
 	}
 }
 
@@ -1371,6 +1401,7 @@ static void espi_xec_vw_isr(const struct device *dev)
 	uint32_t girq_result;
 
 	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_ids[0]);
+	MCHP_GIRQ_SRC(config->vw_girq_ids[0]) = girq_result;
 
 	for (int i = 0; i < m2s_vwires_isr_cnt; i++) {
 		struct espi_isr entry = m2s_vwires_isr[i];
@@ -1381,8 +1412,6 @@ static void espi_xec_vw_isr(const struct device *dev)
 			}
 		}
 	}
-
-	REG32(MCHP_GIRQ_SRC_ADDR(config->vw_girq_ids[0])) = girq_result;
 }
 
 #if DT_INST_PROP_HAS_IDX(0, vw_girqs, 1)
@@ -1454,6 +1483,7 @@ static const struct espi_driver_api espi_xec_driver_api = {
 	.manage_callback = espi_xec_manage_callback,
 	.read_lpc_request = espi_xec_read_lpc_request,
 	.write_lpc_request = espi_xec_write_lpc_request,
+	.send_ltr = espi_xec_send_ltr,
 };
 
 static struct espi_xec_data espi_xec_data;
@@ -1527,8 +1557,11 @@ static int espi_xec_init(const struct device *dev)
 	/* Clear reset interrupt status and enable interrupts */
 	ESPI_CAP_REGS->ERST_STS = MCHP_ESPI_RST_ISTS;
 	ESPI_CAP_REGS->ERST_IEN |= MCHP_ESPI_RST_IEN;
-	ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
-	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG;
+	ESPI_PC_REGS->PC_STATUS |= MCHP_ESPI_PC_STS_EN_CHG |
+				 MCHP_ESPI_PC_STS_BM_EN_CHG;
+	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG |
+				MCHP_ESPI_PC_IEN_BM_EN_CHG;
+
 
 	/* Enable VWires interrupts */
 	for (int i = 0; i < sizeof(vw_wires_int_en); i++) {
diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 5085905ba8..173072af52 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -7,6 +7,7 @@
 #define DT_DRV_COMPAT nuvoton_npcx_espi
 
 #include <assert.h>
+#include <stdlib.h>
 #include <zephyr/drivers/espi.h>
 #include <zephyr/drivers/gpio.h>
 #include <zephyr/drivers/clock_control.h>
@@ -21,6 +22,7 @@
 #include "soc_miwu.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(espi, CONFIG_ESPI_LOG_LEVEL);
 
 struct espi_npcx_config {
@@ -38,7 +40,7 @@ struct espi_npcx_data {
 	uint8_t plt_rst_asserted;
 	uint8_t espi_rst_asserted;
 	uint8_t sx_state;
-#if defined(CONFIG_ESPI_OOB_CHANNEL)
+#if defined(CONFIG_ESPI_OOB_CHANNEL) && !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	struct k_sem oob_rx_lock;
 #endif
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
@@ -73,8 +75,8 @@ struct espi_npcx_data {
 							((hdr & 0xf0000) >> 8))
 
 /* Flash channel maximum payload size */
-#define NPCX_ESPI_FLASH_MAX_RX_PAYLOAD 64
-#define NPCX_ESPI_FLASH_MAX_TX_PAYLOAD 16
+#define NPCX_ESPI_FLASH_MAX_RX_PAYLOAD DT_INST_PROP(0, rx_plsize)
+#define NPCX_ESPI_FLASH_MAX_TX_PAYLOAD DT_INST_PROP(0, tx_plsize)
 
 /* eSPI cycle type field for OOB and FLASH channels */
 #define ESPI_FLASH_READ_CYCLE_TYPE                 0x00
@@ -162,6 +164,8 @@ static const struct npcx_vw_out_config vw_out_tbl[] = {
 
 /*  Virtual wire GPIOs for platform level usage (High at Reset state) */
 static const struct npcx_vw_out_config vw_out_gpio_tbl1[] = {
+/* Only NPCX9 and later series support this feature */
+#if defined(CONFIG_ESPI_NPCX_SUPP_VW_GPIO)
 	/* index 50h (Out) */
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_0, vw_slv_gpio_0),
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_1, vw_slv_gpio_1),
@@ -172,11 +176,12 @@ static const struct npcx_vw_out_config vw_out_gpio_tbl1[] = {
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_5, vw_slv_gpio_5),
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_6, vw_slv_gpio_6),
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_7, vw_slv_gpio_7),
+#endif
 };
 
 /* Callbacks for eSPI bus reset and Virtual Wire signals. */
-static struct miwu_dev_callback espi_rst_callback;
-static struct miwu_dev_callback vw_in_callback[ARRAY_SIZE(vw_in_tbl)];
+static struct miwu_callback espi_rst_callback;
+static struct miwu_callback vw_in_callback[ARRAY_SIZE(vw_in_tbl)];
 
 /* eSPI VW service function forward declarations */
 static int espi_npcx_receive_vwire(const struct device *dev,
@@ -187,7 +192,7 @@ static void espi_vw_send_bootload_done(const struct device *dev);
 
 /* eSPI local initialization functions */
 static void espi_init_wui_callback(const struct device *dev,
-		struct miwu_dev_callback *callback, const struct npcx_wui *wui,
+		struct miwu_callback *callback, const struct npcx_wui *wui,
 		miwu_dev_callback_handler_t handler)
 {
 	/* VW signal which has no wake-up input source */
@@ -196,12 +201,11 @@ static void espi_init_wui_callback(const struct device *dev,
 
 	/* Install callback function */
 	npcx_miwu_init_dev_callback(callback, wui, handler, dev);
-	npcx_miwu_manage_dev_callback(callback, 1);
+	npcx_miwu_manage_callback(callback, 1);
 
 	/* Configure MIWU setting and enable its interrupt */
 	npcx_miwu_interrupt_configure(wui, NPCX_MIWU_MODE_EDGE,
 							NPCX_MIWU_TRIG_BOTH);
-	npcx_miwu_irq_enable(wui);
 }
 
 /* eSPI local bus interrupt service functions */
@@ -278,19 +282,122 @@ static void espi_bus_cfg_update_isr(const struct device *dev)
 static void espi_bus_oob_rx_isr(const struct device *dev)
 {
 	struct espi_npcx_data *const data = dev->data;
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_OOB_RECEIVED,
+				  .evt_details = 0,
+				  .evt_data = 0 };
 
-	LOG_DBG("%s", __func__);
+	/* Notify upper layer the length of OOB received package */
+	evt.evt_details = NPCX_OOB_RX_PACKAGE_LEN(inst->OOBRXBUF[0]);
+	espi_send_callbacks(&data->callbacks, dev, evt);
+#else
 	k_sem_give(&data->oob_rx_lock);
+#endif
 }
 #endif
 
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
+
+void espi_release_flash_np_free(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp = inst->FLASHCTL;
+
+	/* release FLASH_NP_FREE */
+	tmp |= BIT(NPCX_FLASHCTL_FLASH_NP_FREE);
+	inst->FLASHCTL = tmp;
+}
+
+#if defined(CONFIG_ESPI_SAF)
+static struct espi_taf_pckt taf_pckt;
+
+static uint32_t espi_taf_parse(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t taf_hdr, taf_addr;
+	uint8_t i, roundsize;
+
+	/* Get type, length and tag from RX buffer */
+	if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) {
+		taf_hdr = inst->FLASHRXBUF[0];
+	} else {
+		taf_hdr = inst->FLASHRXRDHEAD;
+	}
+
+	taf_hdr = sys_cpu_to_be32(taf_hdr);
+	taf_pckt.type = MSB1(taf_hdr);
+	taf_pckt.len = ((uint16_t)(taf_hdr)) & 0xFFF;
+	taf_pckt.tag = MSN(MSB2(taf_hdr));
+
+	if ((taf_pckt.len == 0) && ((taf_pckt.type & 0xF) == ESPI_FLASH_TAF_REQ_READ)) {
+		taf_pckt.len = _4KB_;
+	}
+
+	/* Get address from RX buffer */
+	if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) {
+		taf_addr = inst->FLASHRXBUF[1];
+	} else {
+		taf_addr = inst->FLASHRXRDHEAD;
+	}
+	taf_pckt.addr = sys_cpu_to_be32(taf_addr);
+
+	/* Get written data if eSPI TAF write */
+	if ((taf_pckt.type & 0xF) == ESPI_FLASH_TAF_REQ_WRITE) {
+		roundsize = DIV_ROUND_UP(taf_pckt.len, sizeof(uint32_t));
+		for (i = 0; i < roundsize; i++) {
+			if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) {
+				taf_pckt.src[i] = inst->FLASHRXBUF[2 + i];
+			} else {
+				taf_pckt.src[i] = inst->FLASHRXRDHEAD;
+			}
+		}
+	}
+
+	return (uint32_t)&taf_pckt;
+}
+#endif /* CONFIG_ESPI_SAF */
+
 static void espi_bus_flash_rx_isr(const struct device *dev)
 {
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
 	struct espi_npcx_data *const data = dev->data;
 
-	LOG_DBG("%s", __func__);
-	k_sem_give(&data->flash_rx_lock);
+	/* Controller Attached Flash Access */
+	if ((inst->ESPICFG & BIT(NPCX_ESPICFG_FLCHANMODE)) == 0) {
+		k_sem_give(&data->flash_rx_lock);
+	} else { /* Target Attached Flash Access */
+#if defined(CONFIG_ESPI_SAF)
+		struct espi_event evt
+			= { .evt_type = ESPI_BUS_SAF_NOTIFICATION,
+			    .evt_details = ESPI_CHANNEL_FLASH,
+			    .evt_data = espi_taf_parse(dev),
+			  };
+		espi_send_callbacks(&data->callbacks, dev, evt);
+#else
+		LOG_DBG("ESPI TAF not supported");
+#endif
+	}
+}
+
+static void espi_bus_completion_sent_isr(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	/* check that ESPISTS.FLNACS is clear. */
+	if (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_FLNACS)) {
+		LOG_ERR("ESPISTS_FLNACS not clear\r\n");
+	}
+
+	/* flash operation is done, Make sure the TAFS transmit buffer is empty */
+	if (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL)) {
+		LOG_ERR("FLASH_TX_AVAIL not clear\r\n");
+	}
+
+	/* In auto mode, release FLASH_NP_FREE here to get next SAF request.*/
+	if (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_SAF_AUTO_READ)) {
+		espi_release_flash_np_free(dev);
+	}
 }
 #endif
 
@@ -304,6 +411,7 @@ const struct espi_bus_isr espi_bus_isr_tbl[] = {
 #endif
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
 	NPCX_ESPI_BUS_INT_ITEM(FLASHRX, espi_bus_flash_rx_isr),
+	NPCX_ESPI_BUS_INT_ITEM(FLNACS, espi_bus_completion_sent_isr),
 #endif
 };
 
@@ -799,7 +907,7 @@ static int espi_npcx_send_oob(const struct device *dev,
 
 	/*
 	 * Notify host a new OOB packet is ready. Please don't write OOB_FREE
-	 * to 1 at the same tiem in case clear it unexpectedly.
+	 * to 1 at the same time in case clear it unexpectedly.
 	 */
 	oob_data = inst->OOBCTL & ~(BIT(NPCX_OOBCTL_OOB_FREE));
 	oob_data |= BIT(NPCX_OOBCTL_OOB_AVAIL);
@@ -816,10 +924,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 				struct espi_oob_packet *pckt)
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
-	struct espi_npcx_data *const data = dev->data;
 	uint8_t *oob_buf = pckt->buf;
 	uint32_t oob_data;
-	int idx_rx_buf, sz_oob_rx, ret;
+	int idx_rx_buf, sz_oob_rx;
 
 	/* Check eSPI bus status first */
 	if (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_BERR)) {
@@ -827,16 +934,15 @@ static int espi_npcx_receive_oob(const struct device *dev,
 		return -EIO;
 	}
 
-	/* Notify host that OOB received buffer is free now. */
-	inst->OOBCTL |= BIT(NPCX_OOBCTL_OOB_FREE);
+#ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	struct espi_npcx_data *const data = dev->data;
 
 	/* Wait until get oob package or timeout */
-	ret = k_sem_take(&data->oob_rx_lock, K_MSEC(ESPI_OOB_MAX_TIMEOUT));
-	if (ret == -EAGAIN) {
+	if (k_sem_take(&data->oob_rx_lock, K_MSEC(ESPI_OOB_MAX_TIMEOUT)) == -EAGAIN) {
 		LOG_ERR("%s: Timeout", __func__);
 		return -ETIMEDOUT;
 	}
-
+#endif
 	/*
 	 * PUT_OOB header (first 4 bytes) in npcx 32-bits rx buffer
 	 *
@@ -877,6 +983,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 		for (i = 0; i < sz_oob_rx % 4; i++)
 			*(oob_buf++) = (oob_data >> (8 * i)) & 0xFF;
 	}
+
+	/* Notify host that OOB received buffer is free now. */
+	inst->OOBCTL |= BIT(NPCX_OOBCTL_OOB_FREE);
 	return 0;
 }
 #endif
@@ -1120,7 +1229,7 @@ static int espi_npcx_flash_erase(const struct device *dev,
 /* Platform specific espi module functions */
 void npcx_espi_enable_interrupts(const struct device *dev)
 {
-	ARG_UNUSED(dev);
+	const struct espi_npcx_config *const config = dev->config;
 
 	/* Enable eSPI bus interrupt */
 	irq_enable(DT_INST_IRQN(0));
@@ -1129,11 +1238,13 @@ void npcx_espi_enable_interrupts(const struct device *dev)
 	for (int idx = 0; idx < ARRAY_SIZE(vw_in_tbl); idx++) {
 		npcx_miwu_irq_enable(&(vw_in_tbl[idx].vw_wui));
 	}
+
+	npcx_miwu_irq_enable(&config->espi_rst_wui);
 }
 
 void npcx_espi_disable_interrupts(const struct device *dev)
 {
-	ARG_UNUSED(dev);
+	const struct espi_npcx_config *const config = dev->config;
 
 	/* Disable eSPI bus interrupt */
 	irq_disable(DT_INST_IRQN(0));
@@ -1142,6 +1253,8 @@ void npcx_espi_disable_interrupts(const struct device *dev)
 	for (int idx = 0; idx < ARRAY_SIZE(vw_in_tbl); idx++) {
 		npcx_miwu_irq_disable(&(vw_in_tbl[idx].vw_wui));
 	}
+
+	npcx_miwu_irq_disable(&config->espi_rst_wui);
 }
 
 /* eSPI driver registration */
@@ -1203,7 +1316,7 @@ static int espi_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on eSPI device clock first */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on eSPI clock fail %d", ret);
@@ -1224,7 +1337,7 @@ static int espi_npcx_init(const struct device *dev)
 		inst->ESPIWE |= BIT(espi_bus_isr_tbl[i].wake_en_bit);
 	}
 
-#if defined(CONFIG_ESPI_OOB_CHANNEL)
+#if defined(CONFIG_ESPI_OOB_CHANNEL) && !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	k_sem_init(&data->oob_rx_lock, 0, 1);
 #endif
 
diff --git a/drivers/espi/espi_saf_mchp_xec_v2.c b/drivers/espi/espi_saf_mchp_xec_v2.c
new file mode 100644
index 0000000000..aa7ea69058
--- /dev/null
+++ b/drivers/espi/espi_saf_mchp_xec_v2.c
@@ -0,0 +1,1175 @@
+/*
+ * Copyright (c) 2019 Intel Corporation
+ * Copyright (c) 2022 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT microchip_xec_espi_saf_v2
+
+#include <zephyr/kernel.h>
+#include <soc.h>
+#include <errno.h>
+#include <zephyr/drivers/clock_control/mchp_xec_clock_control.h>
+#include <zephyr/drivers/espi.h>
+#include <zephyr/drivers/espi_saf.h>
+#include <zephyr/drivers/interrupt_controller/intc_mchp_xec_ecia.h>
+#include <zephyr/dt-bindings/interrupt-controller/mchp-xec-ecia.h>
+#include <zephyr/logging/log.h>
+
+#include "espi_mchp_xec_v2.h"
+#include "espi_utils.h"
+LOG_MODULE_REGISTER(espi_saf, CONFIG_ESPI_LOG_LEVEL);
+
+/* common clock control device node for all Microchip XEC chips */
+#define MCHP_XEC_CLOCK_CONTROL_NODE	DT_NODELABEL(pcr)
+
+/* SAF EC Portal read/write flash access limited to 1-64 bytes */
+#define MAX_SAF_ECP_BUFFER_SIZE 64ul
+
+/* 1 second maximum for flash operations */
+#define MAX_SAF_FLASH_TIMEOUT 125000ul /* 1000ul */
+
+#define MAX_SAF_FLASH_TIMEOUT_MS 1000ul
+
+/* 64 bytes @ 24MHz quad is approx. 6 us */
+#define SAF_WAIT_INTERVAL 8
+
+/* After 8 wait intervals yield */
+#define SAF_YIELD_THRESHOLD 64
+
+/* Get QMSPI 0 encoded GIRQ information */
+#define XEC_QMSPI_ENC_GIRQ						\
+	DT_PROP_BY_IDX(DT_INST(0, microchip_xec_qmspi_ldma), girqs, 0)
+
+#define XEC_QMSPI_GIRQ MCHP_XEC_ECIA_GIRQ(XEC_QMSPI_ENC_GIRQ)
+#define XEC_QMSPI_GIRQ_POS MCHP_XEC_ECIA_GIRQ_POS(XEC_QMSPI_ENC_GIRQ)
+
+#define XEC_SAF_DONE_ENC_GIRQ DT_INST_PROP_BY_IDX(0, girqs, 0)
+#define XEC_SAF_ERR_ENC_GIRQ DT_INST_PROP_BY_IDX(0, girqs, 1)
+
+#define XEC_SAF_DONE_GIRQ MCHP_XEC_ECIA_GIRQ(XEC_SAF_DONE_ENC_GIRQ)
+#define XEC_SAF_DONE_GIRQ_POS MCHP_XEC_ECIA_GIRQ_POS(XEC_SAF_ERR_ENC_GIRQ)
+
+/*
+ * SAF configuration from Device Tree
+ * SAF controller register block base address
+ * QMSPI controller register block base address
+ * SAF communications register block base address
+ * Flash STATUS1 poll timeout in 32KHz periods
+ * Flash consecutive read timeout in units of 20 ns
+ * Delay before first Poll-1 command after suspend in 20 ns units
+ * Hold off suspend for this interval if erase or program in 32KHz periods.
+ * Add delay between Poll STATUS1 commands in 20 ns units.
+ */
+struct espi_saf_xec_config {
+	struct mchp_espi_saf * const saf_base;
+	struct qmspi_regs * const qmspi_base;
+	struct mchp_espi_saf_comm * const saf_comm_base;
+	struct espi_iom_regs * const iom_base;
+	void (*irq_config_func)(void);
+	uint32_t poll_timeout;
+	uint32_t consec_rd_timeout;
+	uint32_t sus_chk_delay;
+	uint16_t sus_rsm_interval;
+	uint16_t poll_interval;
+	uint8_t pcr_idx;
+	uint8_t pcr_pos;
+	uint8_t irq_info_size;
+	uint8_t rsvd1;
+	const struct espi_xec_irq_info *irq_info_list;
+};
+
+struct espi_saf_xec_data {
+	struct k_sem ecp_lock;
+	uint32_t hwstatus;
+	sys_slist_t callbacks;
+};
+
+/* EC portal local flash r/w buffer */
+static uint32_t slave_mem[MAX_SAF_ECP_BUFFER_SIZE];
+
+/*
+ * @brief eSPI SAF configuration
+ */
+
+static inline void mchp_saf_cs_descr_wr(struct mchp_espi_saf *regs, uint8_t cs,
+					uint32_t val)
+{
+	regs->SAF_CS_OP[cs].OP_DESCR = val;
+}
+
+static inline void mchp_saf_poll2_mask_wr(struct mchp_espi_saf *regs, uint8_t cs,
+					  uint16_t val)
+{
+	LOG_DBG("%s cs: %d mask %x", __func__, cs, val);
+	if (cs == 0) {
+		regs->SAF_CS0_CFG_P2M = val;
+	} else {
+		regs->SAF_CS1_CFG_P2M = val;
+	}
+}
+
+static inline void mchp_saf_cm_prefix_wr(struct mchp_espi_saf *regs, uint8_t cs,
+					 uint16_t val)
+{
+	if (cs == 0) {
+		regs->SAF_CS0_CM_PRF = val;
+	} else {
+		regs->SAF_CS1_CM_PRF = val;
+	}
+}
+
+/*
+ * Initialize SAF flash protection regions.
+ * SAF HW implements 17 protection regions.
+ * At least one protection region must be configured to allow
+ * EC access to the local flash through the EC Portal.
+ * Each protection region is composed of 4 32-bit registers
+ * Start bits[19:0] = bits[31:12] region start address (4KB boundaries)
+ * Limit bits[19:0] = bits[31:12] region limit address (4KB boundaries)
+ * Write protect b[7:0] = masters[7:0] allow write/erase. 1=allowed
+ * Read protetc b[7:0] = masters[7:0] allow read. 1=allowed
+ *
+ * This routine configures protection region 0 for full flash array
+ * address range and read-write-erase for all masters.
+ * This routine must be called AFTER the flash configuration size/limit and
+ * threshold registers have been programmed.
+ *
+ * POR default values:
+ * Start = 0x7ffff
+ * Limit = 0
+ * Write Prot = 0x01 Master 0 always granted write/erase
+ * Read Prot = 0x01 Master 0 always granted read
+ *
+ * Sample code configures PR[0]
+ * Start = 0
+ * Limit = 0x7ffff
+ * WR = 0xFF
+ * RD = 0xFF
+ */
+static void saf_protection_regions_init(struct mchp_espi_saf *regs)
+{
+	LOG_DBG("%s", __func__);
+
+	for (size_t n = 0; n < MCHP_ESPI_SAF_PR_MAX; n++) {
+		if (n == 0) {
+			regs->SAF_PROT_RG[0].START = 0U;
+			regs->SAF_PROT_RG[0].LIMIT =
+				regs->SAF_FL_CFG_SIZE_LIM >> 12;
+			regs->SAF_PROT_RG[0].WEBM = MCHP_SAF_MSTR_ALL;
+			regs->SAF_PROT_RG[0].RDBM = MCHP_SAF_MSTR_ALL;
+		} else {
+			regs->SAF_PROT_RG[n].START =
+				MCHP_SAF_PROT_RG_START_DFLT;
+			regs->SAF_PROT_RG[n].LIMIT =
+				MCHP_SAF_PROT_RG_LIMIT_DFLT;
+			regs->SAF_PROT_RG[n].WEBM = 0U;
+			regs->SAF_PROT_RG[n].RDBM = 0U;
+		}
+
+		LOG_DBG("PROT[%d] START %x", n, regs->SAF_PROT_RG[n].START);
+		LOG_DBG("PROT[%d] LIMIT %x", n, regs->SAF_PROT_RG[n].LIMIT);
+		LOG_DBG("PROT[%d] WEBM %x", n, regs->SAF_PROT_RG[n].WEBM);
+		LOG_DBG("PROT[%d] RDBM %x", n, regs->SAF_PROT_RG[n].RDBM);
+	}
+}
+
+static int qmspi_freq_div(uint32_t freqhz, uint32_t *fdiv)
+{
+	clock_control_subsys_t clkss =
+		(clock_control_subsys_t)(MCHP_XEC_PCR_CLK_PERIPH_FAST);
+	uint32_t clk = 0u;
+
+	if (!fdiv) {
+		return -EINVAL;
+	}
+
+	if (clock_control_get_rate(DEVICE_DT_GET(MCHP_XEC_CLOCK_CONTROL_NODE),
+				    (clock_control_subsys_t)clkss, &clk)) {
+		return -EIO;
+	}
+
+	*fdiv = 0u; /* maximum divider = 0x10000 */
+	if (freqhz) {
+		*fdiv = clk / freqhz;
+	}
+
+	return 0u;
+}
+
+static int qmspi_freq_div_from_mhz(uint32_t freqmhz, uint32_t *fdiv)
+{
+	uint32_t freqhz = freqmhz * 1000000u;
+
+	return qmspi_freq_div(freqhz, fdiv);
+}
+
+/*
+ * Take over and re-initialize QMSPI for use by SAF HW engine.
+ * When SAF is activated, QMSPI registers are controlled by SAF
+ * HW engine. CPU no longer has access to QMSPI registers.
+ * 1. Save QMSPI driver frequency divider, SPI signalling mode, and
+ *    chip select timing.
+ * 2. Put QMSPI controller in a known state by performing a soft reset.
+ * 3. Clear QMSPI GIRQ status
+ * 4. Configure QMSPI interface control for SAF.
+ * 5. Load flash device independent (generic) descriptors.
+ * 6. Enable transfer done interrupt in QMSPI
+ * 7. Enable QMSPI SAF mode
+ * 8. If user configuration overrides frequency, signalling mode,
+ *    or chip select timing derive user values.
+ * 9. Program QMSPI MODE and CSTIM registers with activate set.
+ */
+static int saf_qmspi_init(const struct espi_saf_xec_config *xcfg,
+			  const struct espi_saf_cfg *cfg)
+{
+	uint32_t qmode, qfdiv, cstim, n;
+	struct qmspi_regs * const qregs = xcfg->qmspi_base;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	qmode = qregs->MODE;
+	if (!(qmode & MCHP_QMSPI_M_ACTIVATE)) {
+		return -EAGAIN;
+	}
+
+	qmode = qregs->MODE & (MCHP_QMSPI_M_FDIV_MASK | MCHP_QMSPI_M_SIG_MASK);
+	cstim = qregs->CSTM;
+	qregs->MODE = MCHP_QMSPI_M_SRST;
+	qregs->STS = MCHP_QMSPI_STS_RW1C_MASK;
+
+	mchp_soc_ecia_girq_src_dis(XEC_QMSPI_GIRQ, XEC_QMSPI_GIRQ_POS);
+	mchp_soc_ecia_girq_src_clr(XEC_QMSPI_GIRQ, XEC_QMSPI_GIRQ_POS);
+
+	qregs->IFCTRL =
+		(MCHP_QMSPI_IFC_WP_OUT_HI | MCHP_QMSPI_IFC_WP_OUT_EN |
+		 MCHP_QMSPI_IFC_HOLD_OUT_HI | MCHP_QMSPI_IFC_HOLD_OUT_EN);
+
+	for (n = 0; n < MCHP_SAF_NUM_GENERIC_DESCR; n++) {
+		qregs->DESCR[MCHP_SAF_CM_EXIT_START_DESCR + n] =
+			hwcfg->generic_descr[n];
+	}
+
+	/* SAF HW uses QMSPI interrupt signal */
+	qregs->IEN = MCHP_QMSPI_IEN_XFR_DONE;
+
+	qmode |= (MCHP_QMSPI_M_SAF_DMA_MODE_EN | MCHP_QMSPI_M_CS0 |
+		  MCHP_QMSPI_M_ACTIVATE);
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_CPHA) {
+		qmode = (qmode & ~(MCHP_QMSPI_M_SIG_MASK)) |
+			((hwcfg->qmspi_cpha << MCHP_QMSPI_M_SIG_POS) &
+			 MCHP_QMSPI_M_SIG_MASK);
+	}
+
+
+	/* Copy QMSPI frequency divider into SAF CS0 and CS1 QMSPI frequency
+	 * dividers. SAF HW uses CS0/CS1 divider register fields to overwrite
+	 * QMSPI frequency divider in QMSPI.Mode register. Later we will update
+	 * SAF CS0/CS1 SPI frequency dividers based on flash configuration.
+	 */
+	qfdiv = (qmode & MCHP_QMSPI_M_FDIV_MASK) >> MCHP_QMSPI_M_FDIV_POS;
+	qfdiv = qfdiv | (qfdiv << 16); /* read and rest clock dividers */
+	regs->SAF_CLKDIV_CS0 = qfdiv;
+	regs->SAF_CLKDIV_CS1 = qfdiv;
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_CSTM) {
+		cstim = hwcfg->qmspi_cs_timing;
+	}
+
+	/* MEC172x SAF uses TX LDMA channel 0 in non-descriptor mode.
+	 * SAF HW writes QMSPI.Control and TX LDMA channel 0 registers
+	 * to transmit opcode, address, and data. We configure must
+	 * configure TX LDMA channel 0 control register. We believe SAF
+	 * HW will set bit[6] to 1.
+	 */
+	qregs->LDTX[0].CTRL = MCHP_QMSPI_LDC_EN | MCHP_QMSPI_LDC_RS_EN | MCHP_QMSPI_LDC_ASZ_4;
+
+	qmode |= MCHP_QMSPI_M_LDMA_RX_EN | MCHP_QMSPI_M_LDMA_TX_EN;
+
+	qregs->MODE = qmode;
+	qregs->CSTM = cstim;
+
+	return 0;
+}
+
+/*
+ * Registers at offsets:
+ * SAF Poll timeout @ 0x194.  Hard coded to 0x28000. Default value = 0.
+ *	recommended value = 0x28000 32KHz clocks (5 seconds). b[17:0]
+ * SAF Poll interval @ 0x198.  Hard coded to 0
+ *	Default value = 0. Recommended = 0. b[15:0]
+ * SAF Suspend/Resume Interval @ 0x19c.  Hard coded to 0x8
+ *	Default value = 0x01. Min time erase/prog in 32KHz units.
+ * SAF Consecutive Read Timeout @ 0x1a0. Hard coded to 0x2. b[15:0]
+ *	Units of MCLK. Recommend < 20us. b[19:0]
+ * SAF Suspend Check Delay @ 0x1ac. Not touched.
+ *	Default = 0. Recommend = 20us. Units = MCLK. b[19:0]
+ */
+static void saf_flash_timing_init(struct mchp_espi_saf * const regs,
+				  const struct espi_saf_xec_config *cfg)
+{
+	LOG_DBG("%s\n", __func__);
+	regs->SAF_POLL_TMOUT = cfg->poll_timeout;
+	regs->SAF_POLL_INTRVL = cfg->poll_interval;
+	regs->SAF_SUS_RSM_INTRVL = cfg->sus_rsm_interval;
+	regs->SAF_CONSEC_RD_TMOUT = cfg->consec_rd_timeout;
+	regs->SAF_SUS_CHK_DLY = cfg->sus_chk_delay;
+	LOG_DBG("SAF_POLL_TMOUT %x\n", regs->SAF_POLL_TMOUT);
+	LOG_DBG("SAF_POLL_INTRVL %x\n", regs->SAF_POLL_INTRVL);
+	LOG_DBG("SAF_SUS_RSM_INTRVL %x\n", regs->SAF_SUS_RSM_INTRVL);
+	LOG_DBG("SAF_CONSEC_RD_TMOUT %x\n", regs->SAF_CONSEC_RD_TMOUT);
+	LOG_DBG("SAF_SUS_CHK_DLY %x\n", regs->SAF_SUS_CHK_DLY);
+}
+
+/*
+ * Disable DnX bypass feature.
+ */
+static void saf_dnx_bypass_init(struct mchp_espi_saf * const regs)
+{
+	regs->SAF_DNX_PROT_BYP = 0;
+	regs->SAF_DNX_PROT_BYP = 0xffffffff;
+}
+
+/*
+ * Bitmap of flash erase size from 1KB up to 128KB.
+ * eSPI SAF specification requires 4KB erase support.
+ * MCHP SAF supports 4KB, 32KB, and 64KB.
+ * Only report 32KB and 64KB to Host if supported by both
+ * flash devices.
+ */
+static int saf_init_erase_block_size(const struct device *dev, const struct espi_saf_cfg *cfg)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_iom_regs * const espi_iom = xcfg->iom_base;
+	struct espi_saf_flash_cfg *fcfg = cfg->flash_cfgs;
+	uint32_t opb = fcfg->opb;
+	uint8_t erase_bitmap = MCHP_ESPI_SERASE_SZ_4K;
+
+	LOG_DBG("%s\n", __func__);
+
+	if (cfg->nflash_devices > 1) {
+		fcfg++;
+		opb &= fcfg->opb;
+	}
+
+	if ((opb & MCHP_SAF_CS_OPB_ER0_MASK) == 0) {
+		/* One or both do not support 4KB erase! */
+		return -EINVAL;
+	}
+
+	if (opb & MCHP_SAF_CS_OPB_ER1_MASK) {
+		erase_bitmap |= MCHP_ESPI_SERASE_SZ_32K;
+	}
+
+	if (opb & MCHP_SAF_CS_OPB_ER2_MASK) {
+		erase_bitmap |= MCHP_ESPI_SERASE_SZ_64K;
+	}
+
+	espi_iom->SAFEBS = erase_bitmap;
+
+	return 0;
+}
+
+/*
+ * Set the continuous mode prefix and 4-byte address mode bits
+ * based upon the flash configuration information.
+ * Updates:
+ * SAF Flash Config Poll2 Mask @ 0x1A4
+ * SAF Flash Config Special Mode @ 0x1B0
+ * SAF Flash Misc Config @ 0x38
+ */
+static void saf_flash_misc_cfg(struct mchp_espi_saf * const regs, uint8_t cs,
+			       const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t d, v;
+
+	d = regs->SAF_FL_CFG_MISC;
+
+	v = MCHP_SAF_FL_CFG_MISC_CS0_CPE;
+	if (cs) {
+		v = MCHP_SAF_FL_CFG_MISC_CS1_CPE;
+	}
+
+	/* Does this flash device require a prefix for continuous mode? */
+	if (fcfg->cont_prefix != 0) {
+		d |= v;
+	} else {
+		d &= ~v;
+	}
+
+	v = MCHP_SAF_FL_CFG_MISC_CS0_4BM;
+	if (cs) {
+		v = MCHP_SAF_FL_CFG_MISC_CS1_4BM;
+	}
+
+	/* Use 32-bit addressing for this flash device? */
+	if (fcfg->flags & MCHP_FLASH_FLAG_ADDR32) {
+		d |= v;
+	} else {
+		d &= ~v;
+	}
+
+	regs->SAF_FL_CFG_MISC = d;
+	LOG_DBG("%s SAF_FL_CFG_MISC: %x", __func__, d);
+}
+
+static void saf_flash_pd_cfg(struct mchp_espi_saf * const regs, uint8_t cs,
+			     const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t pdval = 0u;
+	uint32_t msk = 0u;
+
+	if (cs == 0) {
+		msk = BIT(SAF_PWRDN_CTRL_CS0_PD_EN_POS) | BIT(SAF_PWRDN_CTRL_CS0_PD_EN_POS);
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS0_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS0_PD_EN_POS);
+		}
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS0_EC_WK_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS0_WPA_EN_POS);
+		}
+	} else {
+		msk = BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS) | BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS);
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS1_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS);
+		}
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS1_EC_WK_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS);
+		}
+	}
+
+	regs->SAF_PWRDN_CTRL = (regs->SAF_PWRDN_CTRL & ~msk) | pdval;
+}
+
+/* Configure SAF per chip select QMSPI clock dividers.
+ * SAF HW implements two QMSP clock divider registers per chip select:
+ * Each divider register is composed of two 16-bit fields:
+ *   b[15:0] = QMSPI clock divider for SPI read
+ *   b[31:16] = QMSPI clock divider for all other SPI commands
+ */
+static int saf_flash_freq_cfg(struct mchp_espi_saf * const regs, uint8_t cs,
+			       const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t fmhz, fdiv, saf_qclk;
+
+	if (cs == 0) {
+		saf_qclk = regs->SAF_CLKDIV_CS0;
+	} else {
+		saf_qclk = regs->SAF_CLKDIV_CS1;
+	}
+
+	fmhz = fcfg->rd_freq_mhz;
+	if (fmhz) {
+		fdiv = 0u;
+		if (qmspi_freq_div_from_mhz(fmhz, &fdiv)) {
+			LOG_ERR("%s SAF CLKDIV CS0 bad freq MHz %u",
+				__func__, fmhz);
+			return -EIO;
+		}
+		if (fdiv) {
+			saf_qclk = (saf_qclk & ~SAF_CLKDIV_CS_MSK0) |
+				   (fdiv & SAF_CLKDIV_CS_MSK0);
+		}
+	}
+
+	fmhz = fcfg->freq_mhz;
+	if (fmhz) {
+		fdiv = 0u;
+		if (qmspi_freq_div_from_mhz(fmhz, &fdiv)) {
+			LOG_ERR("%s SAF CLKDIV CS1 bad freq MHz %u",
+				__func__, fmhz);
+			return -EIO;
+		}
+		if (fdiv) {
+			saf_qclk &= ~(SAF_CLKDIV_CS_MSK0 << 16);
+			saf_qclk |= (fdiv & SAF_CLKDIV_CS_MSK0) << 16;
+		}
+	}
+
+	if (cs == 0) {
+		regs->SAF_CLKDIV_CS0 = saf_qclk;
+	} else {
+		regs->SAF_CLKDIV_CS1 = saf_qclk;
+	}
+
+	return 0;
+}
+
+/*
+ * Program flash device specific SAF and QMSPI registers.
+ *
+ * CS0 OpA @ 0x4c or CS1 OpA @ 0x5C
+ * CS0 OpB @ 0x50 or CS1 OpB @ 0x60
+ * CS0 OpC @ 0x54 or CS1 OpC @ 0x64
+ * Poll 2 Mask @ 0x1a4
+ * Continuous Prefix @ 0x1b0
+ * CS0: QMSPI descriptors 0-5 or CS1 QMSPI descriptors 6-11
+ * CS0 Descrs @ 0x58 or CS1 Descrs @ 0x68
+ * SAF CS0 QMSPI frequency dividers (read/all other) commands
+ * SAF CS1 QMSPI frequency dividers (read/all other) commands
+ */
+static int saf_flash_cfg(const struct device *dev,
+			 const struct espi_saf_flash_cfg *fcfg, uint8_t cs)
+{
+	uint32_t d, did;
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	struct qmspi_regs * const qregs = xcfg->qmspi_base;
+
+	LOG_DBG("%s cs=%u", __func__, cs);
+
+	regs->SAF_CS_OP[cs].OPA = fcfg->opa;
+	regs->SAF_CS_OP[cs].OPB = fcfg->opb;
+	regs->SAF_CS_OP[cs].OPC = fcfg->opc;
+	regs->SAF_CS_OP[cs].OP_DESCR = (uint32_t)fcfg->cs_cfg_descr_ids;
+
+	did = MCHP_SAF_QMSPI_CS0_START_DESCR;
+	if (cs != 0) {
+		did = MCHP_SAF_QMSPI_CS1_START_DESCR;
+	}
+
+	for (size_t i = 0; i < MCHP_SAF_QMSPI_NUM_FLASH_DESCR; i++) {
+		d = fcfg->descr[i] & ~(MCHP_QMSPI_C_NEXT_DESCR_MASK);
+		d |= (((did + 1) << MCHP_QMSPI_C_NEXT_DESCR_POS) &
+		      MCHP_QMSPI_C_NEXT_DESCR_MASK);
+		qregs->DESCR[did++] = d;
+	}
+
+	mchp_saf_poll2_mask_wr(regs, cs, fcfg->poll2_mask);
+	mchp_saf_cm_prefix_wr(regs, cs, fcfg->cont_prefix);
+	saf_flash_misc_cfg(regs, cs, fcfg);
+	saf_flash_pd_cfg(regs, cs, fcfg);
+
+	return saf_flash_freq_cfg(regs, cs, fcfg);
+}
+
+static const uint32_t tag_map_dflt[MCHP_ESPI_SAF_TAGMAP_MAX] = {
+	MCHP_SAF_TAG_MAP0_DFLT, MCHP_SAF_TAG_MAP1_DFLT, MCHP_SAF_TAG_MAP2_DFLT
+};
+
+static void saf_tagmap_init(struct mchp_espi_saf * const regs,
+			    const struct espi_saf_cfg *cfg)
+{
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	for (int i = 0; i < MCHP_ESPI_SAF_TAGMAP_MAX; i++) {
+		if (hwcfg->tag_map[i] & MCHP_SAF_HW_CFG_TAGMAP_USE) {
+			regs->SAF_TAG_MAP[i] = hwcfg->tag_map[i];
+		} else {
+			regs->SAF_TAG_MAP[i] = tag_map_dflt[i];
+		}
+	}
+
+	LOG_DBG("SAF TAG0 %x", regs->SAF_TAG_MAP[0]);
+	LOG_DBG("SAF TAG1 %x", regs->SAF_TAG_MAP[1]);
+	LOG_DBG("SAF TAG2 %x", regs->SAF_TAG_MAP[2]);
+}
+
+#define SAF_QSPI_LDMA_CTRL						\
+	(MCHP_QMSPI_LDC_EN | MCHP_QMSPI_LDC_RS_EN |			\
+	 MCHP_QMSPI_LDC_ASZ_4)
+
+static void saf_qmspi_ldma_cfg(const struct espi_saf_xec_config * const xcfg)
+{
+	struct qmspi_regs * const qregs = xcfg->qmspi_base;
+	uint32_t qmode = qregs->MODE;
+	uint32_t n, temp, chan;
+
+	qregs->MODE = qmode & ~(MCHP_QMSPI_M_ACTIVATE);
+
+	for (n = 0u; n < MCHP_QMSPI_MAX_DESCR; n++) {
+		temp = qregs->DESCR[n];
+		if (temp & MCHP_QMSPI_C_TX_MASK) {
+			chan = (temp & MCHP_QMSPI_C_TX_DMA_MASK) >> MCHP_QMSPI_C_TX_DMA_POS;
+			if (chan) { /* zero is disabled */
+				chan--; /* register array index starts at 0 */
+				qregs->LDMA_TX_DESCR_BM |= BIT(n);
+				qregs->LDTX[chan].CTRL = SAF_QSPI_LDMA_CTRL;
+			}
+		}
+		if (temp & MCHP_QMSPI_C_RX_EN) {
+			chan = (temp & MCHP_QMSPI_C_RX_DMA_MASK) >> MCHP_QMSPI_C_RX_DMA_POS;
+			if (chan) {
+				chan--;
+				qregs->LDMA_RX_DESCR_BM |= BIT(n);
+				qregs->LDRX[chan].CTRL = SAF_QSPI_LDMA_CTRL;
+			}
+		}
+	}
+
+	qregs->MODE = qmode;
+}
+
+/*
+ * Configure SAF and QMSPI for SAF operation based upon the
+ * number and characteristics of local SPI flash devices.
+ * NOTE: SAF is configured but not activated. SAF should be
+ * activated only when eSPI master sends Flash Channel enable
+ * message with MAF/SAF select flag.
+ */
+static int espi_saf_xec_configuration(const struct device *dev,
+				      const struct espi_saf_cfg *cfg)
+{
+	int ret = 0;
+	uint32_t totalsz = 0;
+	uint32_t u = 0;
+
+	LOG_DBG("%s", __func__);
+
+	if ((dev == NULL) || (cfg == NULL)) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	struct mchp_espi_saf_comm * const comm_regs = xcfg->saf_comm_base;
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+	const struct espi_saf_flash_cfg *fcfg = cfg->flash_cfgs;
+
+	if ((fcfg == NULL) || (cfg->nflash_devices == 0U) ||
+	    (cfg->nflash_devices > MCHP_SAF_MAX_FLASH_DEVICES)) {
+		return -EINVAL;
+	}
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return -EAGAIN;
+	}
+
+	saf_qmspi_init(xcfg, cfg);
+
+	regs->SAF_CS0_CFG_P2M = 0;
+	regs->SAF_CS1_CFG_P2M = 0;
+
+	regs->SAF_FL_CFG_GEN_DESCR = MCHP_SAF_FL_CFG_GEN_DESCR_STD;
+
+	/* global flash power down activity counter and interval time */
+	regs->SAF_AC_RELOAD = hwcfg->flash_pd_timeout;
+	regs->SAF_FL_PWR_TMOUT = hwcfg->flash_pd_min_interval;
+
+	/* flash device connected to CS0 required */
+	totalsz = fcfg->flashsz;
+	regs->SAF_FL_CFG_THRH = totalsz;
+	ret = saf_flash_cfg(dev, fcfg, 0);
+	if (ret) {
+		return ret;
+	}
+
+	/* optional second flash device connected to CS1 */
+	if (cfg->nflash_devices > 1) {
+		fcfg++;
+		totalsz += fcfg->flashsz;
+	}
+	/* Program CS1 configuration (same as CS0 if only one device) */
+	ret = saf_flash_cfg(dev, fcfg, 1);
+	if (ret) {
+		return ret;
+	}
+
+	if (totalsz == 0) {
+		return -EAGAIN;
+	}
+
+	regs->SAF_FL_CFG_SIZE_LIM = totalsz - 1;
+
+	LOG_DBG("SAF_FL_CFG_THRH = %x SAF_FL_CFG_SIZE_LIM = %x",
+		regs->SAF_FL_CFG_THRH, regs->SAF_FL_CFG_SIZE_LIM);
+
+	saf_tagmap_init(regs, cfg);
+
+	saf_protection_regions_init(regs);
+
+	saf_dnx_bypass_init(regs);
+
+	saf_flash_timing_init(regs, xcfg);
+
+	ret = saf_init_erase_block_size(dev, cfg);
+	if (ret != 0) {
+		LOG_ERR("SAF Config bad flash erase config");
+		return ret;
+	}
+
+	/* Default or expedited prefetch? */
+	u = MCHP_SAF_FL_CFG_MISC_PFOE_DFLT;
+	if (cfg->hwcfg.flags & MCHP_SAF_HW_CFG_FLAG_PFEXP) {
+		u = MCHP_SAF_FL_CFG_MISC_PFOE_EXP;
+	}
+
+	regs->SAF_FL_CFG_MISC =
+		(regs->SAF_FL_CFG_MISC & ~(MCHP_SAF_FL_CFG_MISC_PFOE_MASK)) | u;
+
+	/* enable prefetch ? */
+	if (cfg->hwcfg.flags & MCHP_SAF_HW_CFG_FLAG_PFEN) {
+		comm_regs->SAF_COMM_MODE |= MCHP_SAF_COMM_MODE_PF_EN;
+	} else {
+		comm_regs->SAF_COMM_MODE &= ~(MCHP_SAF_COMM_MODE_PF_EN);
+	}
+
+	LOG_DBG("%s SAF_FL_CFG_MISC: %x", __func__, regs->SAF_FL_CFG_MISC);
+	LOG_DBG("%s Aft MCHP_SAF_COMM_MODE_REG: %x", __func__,
+		comm_regs->SAF_COMM_MODE);
+
+	saf_qmspi_ldma_cfg(xcfg);
+
+	return 0;
+}
+
+static int espi_saf_xec_set_pr(const struct device *dev,
+			       const struct espi_saf_protection *pr)
+{
+	if ((dev == NULL) || (pr == NULL)) {
+		return -EINVAL;
+	}
+
+	if (pr->nregions >= MCHP_ESPI_SAF_PR_MAX) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return -EAGAIN;
+	}
+
+	const struct espi_saf_pr *preg = pr->pregions;
+	size_t n = pr->nregions;
+
+	while (n--) {
+		uint8_t regnum = preg->pr_num;
+
+		if (regnum >= MCHP_ESPI_SAF_PR_MAX) {
+			return -EINVAL;
+		}
+
+		/* NOTE: If previously locked writes have no effect */
+		if (preg->flags & MCHP_SAF_PR_FLAG_ENABLE) {
+			regs->SAF_PROT_RG[regnum].START = preg->start >> 12U;
+			regs->SAF_PROT_RG[regnum].LIMIT =
+				(preg->start + preg->size - 1U) >> 12U;
+			regs->SAF_PROT_RG[regnum].WEBM = preg->master_bm_we;
+			regs->SAF_PROT_RG[regnum].RDBM = preg->master_bm_rd;
+		} else {
+			regs->SAF_PROT_RG[regnum].START = 0x7FFFFU;
+			regs->SAF_PROT_RG[regnum].LIMIT = 0U;
+			regs->SAF_PROT_RG[regnum].WEBM = 0U;
+			regs->SAF_PROT_RG[regnum].RDBM = 0U;
+		}
+
+		if (preg->flags & MCHP_SAF_PR_FLAG_LOCK) {
+			regs->SAF_PROT_LOCK |= (1UL << regnum);
+		}
+
+		preg++;
+	}
+
+	return 0;
+}
+
+static bool espi_saf_xec_channel_ready(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return true;
+	}
+
+	return false;
+}
+
+/*
+ * MCHP SAF hardware supports a range of flash block erase
+ * sizes from 1KB to 128KB. The eSPI Host specification requires
+ * 4KB must be supported. The MCHP SAF QMSPI HW interface only
+ * supported three erase sizes. Most SPI flash devices chosen for
+ * SAF support 4KB, 32KB, and 64KB.
+ * Get flash erase sizes driver has configured from eSPI capabilities
+ * registers. We assume driver flash tables have opcodes to match
+ * capabilities configuration.
+ * Check requested erase size is supported.
+ */
+struct erase_size_encoding {
+	uint8_t hwbitpos;
+	uint8_t encoding;
+};
+
+static const struct erase_size_encoding ersz_enc[] = {
+	{ MCHP_ESPI_SERASE_SZ_4K_BITPOS, 0 },
+	{ MCHP_ESPI_SERASE_SZ_32K_BITPOS, 1 },
+	{ MCHP_ESPI_SERASE_SZ_64K_BITPOS, 2 }
+};
+
+#define SAF_ERASE_ENCODING_MAX_ENTRY                                           \
+	(sizeof(ersz_enc) / sizeof(struct erase_size_encoding))
+
+static uint32_t get_erase_size_encoding(const struct device *dev, uint32_t erase_size)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_iom_regs * const espi_iom = xcfg->iom_base;
+	uint8_t supsz = espi_iom->SAFEBS;
+
+	LOG_DBG("%s\n", __func__);
+	for (int i = 0; i < SAF_ERASE_ENCODING_MAX_ENTRY; i++) {
+		uint32_t sz = MCHP_ESPI_SERASE_SZ(ersz_enc[i].hwbitpos);
+
+		if ((sz == erase_size) &&
+		    (supsz & (1 << ersz_enc[i].hwbitpos))) {
+			return ersz_enc[i].encoding;
+		}
+	}
+
+	return 0xffffffffU;
+}
+
+static int check_ecp_access_size(uint32_t reqlen)
+{
+	if ((reqlen < MCHP_SAF_ECP_CMD_RW_LEN_MIN) ||
+	    (reqlen > MCHP_SAF_ECP_CMD_RW_LEN_MAX)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+/*
+ * EC access to SAF atttached flash array
+ * Allowed commands:
+ * MCHP_SAF_ECP_CMD_READ(0x0), MCHP_SAF_ECP_CMD_WRITE(0x01),
+ * MCHP_SAF_ECP_CMD_ERASE(0x02), MCHP_SAF_ECP_CMD_RPMC_OP1_CS0(0x03),
+ * MCHP_SAF_ECP_CMD_RPMC_OP2_CS0(0x04), MCHP_SAF_ECP_CMD_RPMC_OP1_CS1(0x83),
+ * MCHP_SAF_ECP_CMD_RPMC_OP2_CS1(0x84)
+ */
+static int saf_ecp_access(const struct device *dev,
+			  struct espi_saf_packet *pckt, uint8_t cmd)
+{
+	uint32_t scmd, err_mask, n;
+	int rc, counter;
+	struct espi_saf_xec_data *xdat = dev->data;
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[0];
+
+	counter = 0;
+	err_mask = MCHP_SAF_ECP_STS_ERR_MASK;
+
+	LOG_DBG("%s", __func__);
+
+	if (!(regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN)) {
+		LOG_ERR("SAF is disabled");
+		return -EIO;
+	}
+
+	n = regs->SAF_ECP_BUSY;
+	if (n & (MCHP_SAF_ECP_EC0_BUSY | MCHP_SAF_ECP_EC1_BUSY)) {
+		LOG_ERR("SAF EC Portal is busy: 0x%08x", n);
+		return -EBUSY;
+	}
+
+	switch (cmd) {
+	case MCHP_SAF_ECP_CMD_READ:
+	case MCHP_SAF_ECP_CMD_WRITE:
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal size out of bounds");
+			return rc;
+		}
+
+		if (cmd == MCHP_SAF_ECP_CMD_WRITE) {
+			memcpy(slave_mem, pckt->buf, pckt->len);
+		}
+
+		n = pckt->len;
+		break;
+	case MCHP_SAF_ECP_CMD_ERASE:
+		n = get_erase_size_encoding(dev, pckt->len);
+		if (n == UINT32_MAX) {
+			LOG_ERR("SAF EC Portal unsupported erase size");
+			return -EAGAIN;
+		}
+		break;
+	case MCHP_SAF_ECP_CMD_RPMC_OP1_CS0:
+	case MCHP_SAF_ECP_CMD_RPMC_OP2_CS0:
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal RPMC size out of bounds");
+			return rc;
+		}
+		if (!(regs->SAF_CFG_CS0_OPD & SAF_CFG_CS_OPC_RPMC_OP2_MSK)) {
+			LOG_ERR("SAF CS0 RPMC opcode not configured");
+			return -EIO;
+		}
+		n = pckt->len;
+		break;
+	case MCHP_SAF_ECP_CMD_RPMC_OP1_CS1:
+	case MCHP_SAF_ECP_CMD_RPMC_OP2_CS1:
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal RPMC size out of bounds");
+			return rc;
+		}
+		if (!(regs->SAF_CFG_CS1_OPD & SAF_CFG_CS_OPC_RPMC_OP2_MSK)) {
+			LOG_ERR("SAF CS1 RPMC opcode not configured");
+			return -EIO;
+		}
+		n = pckt->len;
+		break;
+	default:
+		LOG_ERR("SAF EC Portal bad cmd");
+		return -EAGAIN;
+	}
+
+	LOG_DBG("%s params val done", __func__);
+
+	regs->SAF_ECP_INTEN = 0;
+	regs->SAF_ECP_STATUS = MCHP_SAF_ECP_STS_MASK;
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	regs->SAF_ECP_INTEN = BIT(MCHP_SAF_ECP_INTEN_DONE_POS);
+
+	regs->SAF_ECP_FLAR = pckt->flash_addr;
+	regs->SAF_ECP_BFAR = (uint32_t)&slave_mem[0];
+
+	scmd = MCHP_SAF_ECP_CMD_PUT_FLASH_NP |
+		((uint32_t)cmd << MCHP_SAF_ECP_CMD_CTYPE_POS) |
+		((n << MCHP_SAF_ECP_CMD_LEN_POS) & MCHP_SAF_ECP_CMD_LEN_MASK);
+
+	LOG_DBG("%s ECP_FLAR=0x%x", __func__, regs->SAF_ECP_FLAR);
+	LOG_DBG("%s ECP_BFAR=0x%x", __func__, regs->SAF_ECP_BFAR);
+	LOG_DBG("%s ECP_CMD=0x%x", __func__, scmd);
+
+	regs->SAF_ECP_CMD = scmd;
+	regs->SAF_ECP_START = MCHP_SAF_ECP_START;
+
+	rc = k_sem_take(&xdat->ecp_lock, K_MSEC(MAX_SAF_FLASH_TIMEOUT_MS));
+	if (rc == -EAGAIN) {
+		LOG_ERR("%s timeout", __func__);
+		return -ETIMEDOUT;
+	}
+
+	LOG_DBG("%s wake on semaphore", __func__);
+
+	n = regs->SAF_ECP_STATUS;
+	/* clear hardware status and check for errors */
+	if (n & err_mask) {
+		regs->SAF_ECP_STATUS = n;
+		LOG_ERR("%s error %x", __func__, n);
+		return -EIO;
+	}
+
+	if (cmd == MCHP_SAF_ECP_CMD_READ) {
+		memcpy(pckt->buf, slave_mem, pckt->len);
+	}
+
+	return rc;
+}
+
+/* Flash read using SAF EC Portal */
+static int saf_xec_flash_read(const struct device *dev,
+			      struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_READ);
+}
+
+/* Flash write using SAF EC Portal */
+static int saf_xec_flash_write(const struct device *dev,
+			       struct espi_saf_packet *pckt)
+{
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_WRITE);
+}
+
+/* Flash erase using SAF EC Portal */
+static int saf_xec_flash_erase(const struct device *dev,
+			       struct espi_saf_packet *pckt)
+{
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_ERASE);
+}
+
+static int espi_saf_xec_manage_callback(const struct device *dev,
+					struct espi_callback *callback,
+					bool set)
+{
+	struct espi_saf_xec_data *data = dev->data;
+
+	return espi_manage_callback(&data->callbacks, callback, set);
+}
+
+static int espi_saf_xec_activate(const struct device *dev)
+{
+	if (dev == NULL) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[1];
+
+	regs->SAF_ESPI_MON_STATUS = MCHP_SAF_ESPI_MON_STS_IEN_MSK;
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	regs->SAF_FL_CFG_MISC |= MCHP_SAF_FL_CFG_MISC_SAF_EN;
+	regs->SAF_ESPI_MON_INTEN = (BIT(MCHP_SAF_ESPI_MON_STS_IEN_TMOUT_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_OOR_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_AV_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_BND_4K_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_ERSZ_POS));
+
+	k_busy_wait(1000); /* TODO FIXME get estimate of time interval */
+
+	return 0;
+}
+
+static void espi_saf_done_isr(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_saf_xec_data *data = dev->data;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[0];
+	uint32_t ecp_status = regs->SAF_ECP_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_SAF_NOTIFICATION,
+				  .evt_details = BIT(0),
+				  .evt_data = ecp_status };
+
+	regs->SAF_ECP_INTEN = 0u;
+	regs->SAF_ECP_STATUS = BIT(MCHP_SAF_ECP_STS_DONE_POS);
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	data->hwstatus = ecp_status;
+
+	LOG_DBG("SAF Done ISR: status=0x%x", ecp_status);
+
+	espi_send_callbacks(&data->callbacks, dev, evt);
+
+	k_sem_give(&data->ecp_lock);
+}
+
+static void espi_saf_err_isr(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_saf_xec_data *data = dev->data;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[1];
+	uint32_t mon_status = regs->SAF_ESPI_MON_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_PERIPHERAL_NOTIFICATION,
+				  .evt_details = BIT(7),
+				  .evt_data = mon_status };
+
+	regs->SAF_ESPI_MON_STATUS = mon_status;
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	data->hwstatus = mon_status;
+	espi_send_callbacks(&data->callbacks, dev, evt);
+}
+
+static const struct espi_saf_driver_api espi_saf_xec_driver_api = {
+	.config = espi_saf_xec_configuration,
+	.set_protection_regions = espi_saf_xec_set_pr,
+	.activate = espi_saf_xec_activate,
+	.get_channel_status = espi_saf_xec_channel_ready,
+	.flash_read = saf_xec_flash_read,
+	.flash_write = saf_xec_flash_write,
+	.flash_erase = saf_xec_flash_erase,
+	.manage_callback = espi_saf_xec_manage_callback,
+};
+
+static int espi_saf_xec_init(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_saf_xec_data * const data = dev->data;
+	struct espi_iom_regs * const espi_iom = xcfg->iom_base;
+
+	/* ungate SAF clocks by disabling PCR sleep enable */
+	z_mchp_xec_pcr_periph_sleep(xcfg->pcr_idx, xcfg->pcr_pos, 0);
+
+	/* Configure the channels and its capabilities based on build config */
+	espi_iom->CAP0 |= MCHP_ESPI_GBL_CAP0_FC_SUPP;
+	espi_iom->CAPFC &= ~(MCHP_ESPI_FC_CAP_SHARE_MASK);
+	espi_iom->CAPFC |= MCHP_ESPI_FC_CAP_SHARE_MAF_SAF;
+
+	xcfg->irq_config_func();
+
+	k_sem_init(&data->ecp_lock, 0, 1);
+
+	return 0;
+}
+
+
+/* n = node-id, p = property, i = index */
+#define XEC_SAF_IRQ_INFO(n, p, i)					    \
+	{								    \
+		.gid = MCHP_XEC_ECIA_GIRQ(DT_PROP_BY_IDX(n, p, i)),	    \
+		.gpos = MCHP_XEC_ECIA_GIRQ_POS(DT_PROP_BY_IDX(n, p, i)),    \
+		.anid = MCHP_XEC_ECIA_NVIC_AGGR(DT_PROP_BY_IDX(n, p, i)),   \
+		.dnid = MCHP_XEC_ECIA_NVIC_DIRECT(DT_PROP_BY_IDX(n, p, i)), \
+	},
+
+#define ESPI_SAF_XEC_DEVICE(n)								\
+											\
+	static struct espi_saf_xec_data espisaf_xec_data_##n;				\
+											\
+	static void espi_saf_xec_connect_irqs_##n(void);				\
+											\
+	static const struct espi_xec_irq_info espi_saf_xec_irq_info_##n[] = {		\
+		DT_INST_FOREACH_PROP_ELEM(n, girqs, XEC_SAF_IRQ_INFO)			\
+	};										\
+											\
+	static const struct espi_saf_xec_config espisaf_xec_config_##n = {		\
+		.saf_base = (struct mchp_espi_saf * const)(				\
+					DT_INST_REG_ADDR_BY_IDX(n, 0)),			\
+		.qmspi_base = (struct qmspi_regs * const)(				\
+						DT_INST_REG_ADDR_BY_IDX(n, 1)),		\
+		.saf_comm_base = (struct mchp_espi_saf_comm * const)(			\
+							DT_INST_REG_ADDR_BY_IDX(n, 2)),	\
+		.iom_base = (struct espi_iom_regs * const)(				\
+					DT_REG_ADDR_BY_NAME(DT_INST_PARENT(n), io)),	\
+		.poll_timeout = DT_INST_PROP_OR(n, poll_timeout,			\
+						MCHP_SAF_FLASH_POLL_TIMEOUT),		\
+		.consec_rd_timeout = DT_INST_PROP_OR(					\
+			n, consec_rd_timeout, MCHP_SAF_FLASH_CONSEC_READ_TIMEOUT),	\
+		.sus_chk_delay = DT_INST_PROP_OR(n, sus_chk_delay,			\
+						 MCHP_SAF_FLASH_SUS_CHK_DELAY),		\
+		.sus_rsm_interval = DT_INST_PROP_OR(n, sus_rsm_interval,		\
+						    MCHP_SAF_FLASH_SUS_RSM_INTERVAL),	\
+		.poll_interval = DT_INST_PROP_OR(n, poll_interval,			\
+						 MCHP_SAF_FLASH_POLL_INTERVAL),		\
+		.pcr_idx = DT_INST_PROP_BY_IDX(n, pcrs, 0),				\
+		.pcr_pos = DT_INST_PROP_BY_IDX(n, pcrs, 1),				\
+		.irq_config_func = espi_saf_xec_connect_irqs_##n,			\
+		.irq_info_size = ARRAY_SIZE(espi_saf_xec_irq_info_##n),			\
+		.irq_info_list = espi_saf_xec_irq_info_##n,				\
+	};										\
+	DEVICE_DT_INST_DEFINE(0, &espi_saf_xec_init, NULL,				\
+				  &espisaf_xec_data_##n,				\
+				  &espisaf_xec_config_##n, POST_KERNEL,			\
+				  CONFIG_ESPI_SAF_INIT_PRIORITY,			\
+				  &espi_saf_xec_driver_api);				\
+											\
+	static void espi_saf_xec_connect_irqs_##n(void)					\
+	{										\
+		uint8_t girq, gpos;							\
+											\
+		/* SAF Done */								\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),				\
+				DT_INST_IRQ_BY_IDX(n, 0, priority),			\
+				espi_saf_done_isr,					\
+				DEVICE_DT_INST_GET(n), 0);				\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));				\
+											\
+		girq = MCHP_XEC_ECIA_GIRQ(DT_INST_PROP_BY_IDX(n, girqs, 0));		\
+		gpos = MCHP_XEC_ECIA_GIRQ_POS(DT_INST_PROP_BY_IDX(n, girqs, 0));	\
+		mchp_xec_ecia_girq_src_en(girq, gpos);					\
+											\
+		/* SAF Error */								\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 1, irq),				\
+				DT_INST_IRQ_BY_IDX(n, 1, priority),			\
+				espi_saf_err_isr,					\
+				DEVICE_DT_INST_GET(n), 0);				\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 1, irq));				\
+											\
+		girq = MCHP_XEC_ECIA_GIRQ(DT_INST_PROP_BY_IDX(n, girqs, 1));		\
+		gpos = MCHP_XEC_ECIA_GIRQ_POS(DT_INST_PROP_BY_IDX(n, girqs, 1));	\
+		mchp_xec_ecia_girq_src_en(girq, gpos);					\
+	}
+
+DT_INST_FOREACH_STATUS_OKAY(ESPI_SAF_XEC_DEVICE)
diff --git a/drivers/espi/espi_taf_npcx.c b/drivers/espi/espi_taf_npcx.c
new file mode 100644
index 0000000000..01c7ce97d8
--- /dev/null
+++ b/drivers/espi/espi_taf_npcx.c
@@ -0,0 +1,491 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_espi_taf
+
+#include <soc.h>
+#include <zephyr/drivers/espi.h>
+#include <zephyr/drivers/espi_saf.h>
+#include <zephyr/drivers/flash.h>
+#include <zephyr/kernel.h>
+#include <zephyr/logging/log.h>
+
+LOG_MODULE_REGISTER(espi_taf, CONFIG_ESPI_LOG_LEVEL);
+
+static const struct device *const spi_dev = DEVICE_DT_GET(DT_ALIAS(taf_flash));
+
+struct espi_taf_npcx_config {
+	uintptr_t base;
+	uintptr_t mapped_addr;
+	enum ESPI_FLASH_TAF_ERASE_BLOCK_SIZE erase_sz;
+	enum ESPI_FLASH_TAF_MAX_READ_REQ max_rd_sz;
+};
+
+struct espi_taf_npcx_data {
+	sys_slist_t callbacks;
+};
+
+#define HAL_INSTANCE(dev)						\
+	((struct espi_reg *)((const struct espi_taf_npcx_config *)	\
+	(dev)->config)->base)
+
+#define DT_INST_ERASE_SZ_PROP_OR(inst)					\
+	COND_CODE_1(DT_INST_NODE_HAS_PROP(inst, erase_sz),		\
+		    (_CONCAT(ESPI_FLASH_TAF_ERASE_BLOCK_,		\
+		     DT_INST_STRING_TOKEN(inst, erase_sz))),		\
+		    ((ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_4KB)))
+
+#define DT_INST_MAX_READ_SZ_PROP_OR(inst)				\
+	COND_CODE_1(DT_INST_NODE_HAS_PROP(inst, max_read_sz),		\
+		    (_CONCAT(ESPI_FLASH_TAF_MAX_READ_REQ_,		\
+		     DT_INST_STRING_TOKEN(inst, max_read_sz))),		\
+		    ((ESPI_FLASH_TAF_MAX_READ_REQ_64B)))
+
+/* Check access region of read request is protected or not */
+bool espi_taf_check_read_protect(const struct device *dev, uint32_t addr, uint32_t len,
+				 uint8_t tag)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint8_t i = 0;
+	uint16_t override_rd;
+	uint32_t flash_addr = addr;
+	uint32_t base, high;
+	bool rdpr;
+
+	flash_addr +=
+		GET_FIELD(inst->FLASHBASE, NPCX_FLASHBASE_FLBASE_ADDR)
+		<< GET_POS(NPCX_FLASHBASE_FLBASE_ADDR);
+
+	for (i = 0; i < CONFIG_ESPI_TAF_PR_NUM; i++) {
+		base = GET_FIELD(inst->FLASH_PRTR_BADDR[i],
+				 NPCX_FLASH_PRTR_BADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_BADDR);
+		high = GET_FIELD(inst->FLASH_PRTR_HADDR[i],
+				 NPCX_FLASH_PRTR_HADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_HADDR);
+		high |= 0xFFF;
+
+		rdpr = IS_BIT_SET(inst->FLASH_PRTR_BADDR[i], NPCX_FRGN_RPR) ? true : false;
+		override_rd = GET_FIELD(inst->FLASH_RGN_TAG_OVR[i], NPCX_FLASH_TAG_OVR_RPR);
+
+		if (rdpr && !IS_BIT_SET(override_rd, tag) &&
+		    (base <= flash_addr + len - 1 && flash_addr <= high)) {
+			return true;
+		}
+	}
+
+	return false;
+}
+
+/* Check access region of write request is protected or not */
+bool espi_taf_check_write_protect(const struct device *dev, uint32_t addr,
+				  uint32_t len, uint8_t tag)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint8_t i = 0;
+	uint16_t override_wr;
+	uint32_t base, high;
+	uint32_t flash_addr = addr;
+	bool wrpr;
+
+	flash_addr +=
+		GET_FIELD(inst->FLASHBASE, NPCX_FLASHBASE_FLBASE_ADDR)
+		<< GET_POS(NPCX_FLASHBASE_FLBASE_ADDR);
+
+	for (i = 0; i < CONFIG_ESPI_TAF_PR_NUM; i++) {
+		base = GET_FIELD(inst->FLASH_PRTR_BADDR[i], NPCX_FLASH_PRTR_BADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_BADDR);
+		high = GET_FIELD(inst->FLASH_PRTR_HADDR[i], NPCX_FLASH_PRTR_HADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_HADDR);
+		high |= 0xFFF;
+
+		wrpr = IS_BIT_SET(inst->FLASH_PRTR_BADDR[i], NPCX_FRGN_WPR) ? true : false;
+		override_wr = GET_FIELD(inst->FLASH_RGN_TAG_OVR[i], NPCX_FLASH_TAG_OVR_WPR);
+
+		if (wrpr && !IS_BIT_SET(override_wr, tag) &&
+		    (base <= flash_addr + len - 1 && flash_addr <= high)) {
+			return true;
+		}
+	}
+
+	return false;
+}
+
+int espi_taf_npcx_configuration(const struct device *dev, const struct espi_saf_cfg *cfg)
+{
+	LOG_INF("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	if (hwcfg->mode == ESPI_TAF_STANDARD_MODE) {
+		inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_SAF_AUTO_READ);
+	} else {
+		inst->FLASHCTL |= BIT(NPCX_FLASHCTL_SAF_AUTO_READ);
+	}
+
+	return 0;
+}
+
+int espi_taf_npcx_set_pr(const struct device *dev, const struct espi_saf_protection *pr)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	const struct espi_saf_pr *preg = pr->pregions;
+	size_t n = pr->nregions;
+	uint8_t regnum;
+	uint32_t rw_pr, override_rw;
+
+	if ((dev == NULL) || (pr == NULL)) {
+		return -EINVAL;
+	}
+
+	if (pr->nregions >= CONFIG_ESPI_TAF_PR_NUM) {
+		return -EINVAL;
+	}
+
+	while (n--) {
+		regnum = preg->pr_num;
+
+		if (regnum >= CONFIG_ESPI_TAF_PR_NUM) {
+			return -EINVAL;
+		}
+
+		rw_pr = preg->master_bm_we << NPCX_FRGN_WPR;
+		rw_pr = rw_pr | (preg->master_bm_rd << NPCX_FRGN_RPR);
+
+		if (preg->flags) {
+			inst->FLASH_PRTR_BADDR[regnum] = (preg->start << 12U) | rw_pr;
+			inst->FLASH_PRTR_HADDR[regnum] = preg->end << 12U;
+		}
+
+		override_rw = (preg->override_r << 16) | preg->override_w;
+		inst->FLASH_RGN_TAG_OVR[regnum] = override_rw;
+		preg++;
+	}
+
+	return 0;
+}
+
+static int espi_taf_npcx_activate(const struct device *dev)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_AUTO_RD_DIS_CTL);
+	inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_BLK_FLASH_NP_FREE);
+
+	return 0;
+}
+
+bool espi_taf_npcx_channel_ready(const struct device *dev)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	if (!IS_BIT_SET(inst->ESPICFG, NPCX_ESPICFG_FLCHANMODE)) {
+		return false;
+	}
+	return true;
+}
+
+/* This routine set FLASH_C_AVAIL for standard request */
+void taf_set_flash_c_avail(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp = inst->FLASHCTL;
+
+	/*
+	 * Clear FLASHCTL_FLASH_NP_FREE to avoid host puts a flash
+	 * standard request command at here.
+	 */
+	tmp &= FLASHCTL_ACCESS_MASK;
+
+	/* set FLASHCTL_FLASH_TX_AVAIL */
+	tmp |= BIT(NPCX_FLASHCTL_FLASH_TX_AVAIL);
+	inst->FLASHCTL = tmp;
+}
+
+/* This routine release FLASH_NP_FREE for standard request */
+void taf_release_flash_np_free(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp = inst->FLASHCTL;
+
+	/*
+	 * Clear FLASHCTL_FLASH_TX_AVAIL to avoid host puts a
+	 * GET_FLASH_C command at here.
+	 */
+	tmp &= FLASHCTL_ACCESS_MASK;
+
+	/* release FLASH_NP_FREE */
+	tmp |= BIT(NPCX_FLASHCTL_FLASH_NP_FREE);
+	inst->FLASHCTL = tmp;
+}
+
+/* This routine resets eSPI flash channel indirect buffer head */
+void reset_indirect_buffer_head(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp;
+
+	tmp = inst->FLASHCTL;
+
+	/*
+	 * Clear FLASHCTL_FLASH_NP_FREE and FLASHCTL_FLASH_TX_AVAIL
+	 * to avoid host puts a flash standard request or a GET_FLASH_C
+	 * command at here.
+	 */
+	tmp &= FLASHCTL_ACCESS_MASK;
+
+	/* release FLASHCTL_RSTBUFHEADS */
+	tmp |= BIT(NPCX_FLASHCTL_RSTBUFHEADS);
+	inst->FLASHCTL = tmp;
+}
+
+void taf_npcx_completion_handler(const struct device *dev, uint32_t *buffer)
+{
+	LOG_DBG("%s", __func__);
+	uint8_t i;
+	uint16_t size = DIV_ROUND_UP((uint8_t)(buffer[0]) + 1, sizeof(uint32_t));
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Check the Flash Access TX Queue is empty by polling
+	 * FLASH_TX_AVAIL.
+	 */
+	while (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL)) {
+		;
+	}
+
+	/* check ESPISTS.FLNACS is clear (no slave completion is detected) */
+	while (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_FLNACS)) {
+		;
+	}
+
+	/* Write packet to FLASHTXBUF */
+	if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) { /* direct mode */
+		for (i = 0; i < size; i++) {
+			inst->FLASHTXBUF[i] = buffer[i];
+		}
+	} else { /* indirect mode */
+		reset_indirect_buffer_head(dev);
+		for (i = 0; i < size; i++) {
+			inst->FLASHTXWRHEAD = buffer[i];
+		}
+	}
+
+	/* Set the FLASHCTL.FLASH_TX_AVAIL bit to 1 to enqueue the packet */
+	taf_set_flash_c_avail(dev);
+
+	/* release FLASH_NP_FREE here to ready get next TAF request*/
+	if ((MSB2(buffer[0]) != CYC_SCS_CMP_WITH_DATA_FIRST) &&
+	    (MSB2(buffer[0]) != CYC_SCS_CMP_WITH_DATA_MIDDLE)) {
+		taf_release_flash_np_free(dev);
+	}
+}
+
+int espi_taf_npcx_flash_read(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
+	uint8_t cycle_type = CYC_SCS_CMP_WITH_DATA_ONLY;
+	uint32_t total_len = pckt->len;
+	uint32_t len = total_len;
+	uint32_t addr = pckt->flash_addr;
+	uint8_t flashreqsize = GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLASHREQSIZE);
+	uint8_t targetmaxsize = GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLREQSUP);
+	uint16_t max_read_req = 32 << flashreqsize;
+	int rc;
+
+	if (flashreqsize > targetmaxsize) {
+		LOG_DBG("Exceeded the maximum supported length");
+		if (targetmaxsize == 0) {
+			targetmaxsize = 1;
+		}
+		max_read_req = 32 << targetmaxsize;
+	}
+
+	if (total_len > max_read_req) {
+		LOG_ERR("Exceeded the limitation of read length");
+		return -EINVAL;
+	}
+
+	if (espi_taf_check_read_protect(dev, addr, len, taf_data_ptr->tag)) {
+		LOG_ERR("Access protect region");
+		return -EINVAL;
+	}
+
+	if (total_len <= MAX_FLASH_REQUEST) {
+		cycle_type = CYC_SCS_CMP_WITH_DATA_ONLY;
+		len = total_len;
+	} else {
+		cycle_type = CYC_SCS_CMP_WITH_DATA_FIRST;
+		len = MAX_FLASH_REQUEST;
+	}
+
+	do {
+		data_ptr = (uint8_t *)taf_data_ptr->data;
+		*data_ptr++ = len + 3;
+		*data_ptr++ = cycle_type;
+		*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+		*data_ptr++ = MSB3(len);
+
+		rc = flash_read(spi_dev, addr, data_ptr, len);
+		if (rc) {
+			LOG_ERR("flash read fail 0x%x", rc);
+			return -EIO;
+		}
+
+		taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+
+		total_len -= len;
+		addr += len;
+
+		if (total_len <= MAX_FLASH_REQUEST) {
+			cycle_type = CYC_SCS_CMP_WITH_DATA_LAST;
+			len = total_len;
+		} else {
+			cycle_type = CYC_SCS_CMP_WITH_DATA_MIDDLE;
+		}
+	} while (total_len);
+
+	return 0;
+}
+
+int espi_taf_npcx_flash_write(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)(taf_data_ptr->data);
+	uint16_t len;
+	int rc;
+
+	if (espi_taf_check_write_protect(dev, pckt->flash_addr,
+					 pckt->len, taf_data_ptr->tag)) {
+		LOG_ERR("Access protection region");
+		return -EINVAL;
+	}
+
+	rc = flash_write(spi_dev, pckt->flash_addr, data_ptr, pckt->len);
+	if (rc) {
+		LOG_ERR("flash write fail 0x%x", rc);
+		return -EIO;
+	}
+
+	/* Completion without Data the length field must be driven to zeros */
+	len = 0;
+
+	*data_ptr++ = len + 3;
+	*data_ptr++ = CYC_SCS_CMP_WITHOUT_DATA;
+	*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+	*data_ptr++ = MSB3(len);
+
+	taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	return 0;
+}
+
+int espi_taf_npcx_flash_erase(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
+	uint32_t addr = pckt->flash_addr;
+	uint32_t len = pckt->len;
+	int rc;
+
+	if (espi_taf_check_write_protect(dev, addr, len, taf_data_ptr->tag)) {
+		LOG_ERR("Access protect region");
+		return -EINVAL;
+	}
+
+	rc = flash_erase(spi_dev, addr, len);
+	if (rc) {
+		LOG_ERR("flash erase fail");
+		return -EIO;
+	}
+
+	/* Completion without Data the length field must be driven to zeros */
+	len = 0;
+
+	*data_ptr++ = len + 3;
+	*data_ptr++ = CYC_SCS_CMP_WITHOUT_DATA;
+	*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+	*data_ptr++ = MSB3(len);
+
+	taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	return 0;
+}
+
+int espi_taf_npcx_flash_unsuccess(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	uint16_t len;
+	struct espi_taf_npcx_pckt *taf_data_ptr
+			= (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
+
+	/* Completion without Data the length field must be driven to zeros */
+	len = 0;
+
+	*data_ptr++ = len + 3;
+	*data_ptr++ = CYC_UNSCS_CMP_WITHOUT_DATA_ONLY;
+	*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+	*data_ptr++ = MSB3(len);
+
+	taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	return 0;
+}
+
+static int espi_taf_npcx_manage_callback(const struct device *dev, struct espi_callback *callback,
+					 bool set)
+{
+	LOG_DBG("%s", __func__);
+	return 0;
+}
+
+int espi_taf_npcx_init(const struct device *dev)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	const struct espi_taf_npcx_config *config = dev->config;
+
+	SET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLCAPA,
+		  ESPI_FLASH_SHARING_CAP_SUPP_TAF_AND_CAF);
+	SET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_TRGFLEBLKSIZE,
+		  BIT(config->erase_sz));
+	SET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLREQSUP,
+		  config->max_rd_sz);
+	inst->FLASHBASE = config->mapped_addr;
+
+	return 0;
+}
+
+static const struct espi_saf_driver_api espi_taf_npcx_driver_api = {
+	.config = espi_taf_npcx_configuration,
+	.set_protection_regions = espi_taf_npcx_set_pr,
+	.activate = espi_taf_npcx_activate,
+	.get_channel_status = espi_taf_npcx_channel_ready,
+	.flash_read = espi_taf_npcx_flash_read,
+	.flash_write = espi_taf_npcx_flash_write,
+	.flash_erase = espi_taf_npcx_flash_erase,
+	.flash_unsuccess = espi_taf_npcx_flash_unsuccess,
+	.manage_callback = espi_taf_npcx_manage_callback,
+};
+
+static struct espi_taf_npcx_data espi_taf_npcx_data;
+
+static const struct espi_taf_npcx_config espi_taf_npcx_config = {
+	.base = DT_INST_REG_ADDR(0),
+	.mapped_addr = DT_INST_PROP(0, mapped_addr),
+	.erase_sz = DT_INST_ERASE_SZ_PROP_OR(0),
+	.max_rd_sz = DT_INST_MAX_READ_SZ_PROP_OR(0),
+};
+
+DEVICE_DT_INST_DEFINE(0, &espi_taf_npcx_init, NULL,
+			&espi_taf_npcx_data, &espi_taf_npcx_config,
+			PRE_KERNEL_2, CONFIG_ESPI_INIT_PRIORITY,
+			&espi_taf_npcx_driver_api);
diff --git a/drivers/espi/host_subs_npcx.c b/drivers/espi/host_subs_npcx.c
index 6b179e0a38..b9187f4ecd 100644
--- a/drivers/espi/host_subs_npcx.c
+++ b/drivers/espi/host_subs_npcx.c
@@ -118,6 +118,7 @@
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/pinctrl.h>
 #include <zephyr/kernel.h>
+#include <zephyr/sys/ring_buffer.h>
 #include <soc.h>
 #include "espi_utils.h"
 #include "soc_host.h"
@@ -125,6 +126,7 @@
 #include "soc_miwu.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(host_sub_npcx, LOG_LEVEL_ERR);
 
 struct host_sub_npcx_config {
@@ -147,6 +149,18 @@ struct host_sub_npcx_data {
 	uint8_t plt_rst_asserted; /* current PLT_RST# status */
 	uint8_t espi_rst_asserted; /* current ESPI_RST# status */
 	const struct device *host_bus_dev; /* device for eSPI/LPC bus */
+#ifdef CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	struct ring_buf port80_ring_buf;
+	uint8_t port80_data[CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_RING_BUF_SIZE];
+	struct k_work work;
+#endif
+};
+
+struct npcx_dp80_buf {
+	union {
+		uint16_t offset_code_16;
+		uint8_t offset_code[2];
+	};
 };
 
 static const struct npcx_clk_cfg host_dev_clk_cfg[] =
@@ -192,15 +206,16 @@ struct host_sub_npcx_data host_sub_data;
 #define EC_CFG_IDX_DATA_IO_ADDR_L  0x63
 
 /* Index of Special Logical Device Configuration (Shared Memory Module) */
-#define EC_CFG_IDX_SHM_CFG         0xF1
-#define EC_CFG_IDX_SHM_WND1_ADDR_0 0xF4
-#define EC_CFG_IDX_SHM_WND1_ADDR_1 0xF5
-#define EC_CFG_IDX_SHM_WND1_ADDR_2 0xF6
-#define EC_CFG_IDX_SHM_WND1_ADDR_3 0xF7
-#define EC_CFG_IDX_SHM_WND2_ADDR_0 0xF8
-#define EC_CFG_IDX_SHM_WND2_ADDR_1 0xF9
-#define EC_CFG_IDX_SHM_WND2_ADDR_2 0xFA
-#define EC_CFG_IDX_SHM_WND2_ADDR_3 0xFB
+#define EC_CFG_IDX_SHM_CFG             0xF1
+#define EC_CFG_IDX_SHM_WND1_ADDR_0     0xF4
+#define EC_CFG_IDX_SHM_WND1_ADDR_1     0xF5
+#define EC_CFG_IDX_SHM_WND1_ADDR_2     0xF6
+#define EC_CFG_IDX_SHM_WND1_ADDR_3     0xF7
+#define EC_CFG_IDX_SHM_WND2_ADDR_0     0xF8
+#define EC_CFG_IDX_SHM_WND2_ADDR_1     0xF9
+#define EC_CFG_IDX_SHM_WND2_ADDR_2     0xFA
+#define EC_CFG_IDX_SHM_WND2_ADDR_3     0xFB
+#define EC_CFG_IDX_SHM_DP80_ADDR_RANGE 0xFD
 
 /* Host sub-device local inline functions */
 static inline uint8_t host_shd_mem_wnd_size_sl(uint32_t size)
@@ -472,34 +487,90 @@ static void host_pmch_ibf_isr(const void *arg)
 
 /* Host port80 sub-device local functions */
 #if defined(CONFIG_ESPI_PERIPHERAL_DEBUG_PORT_80)
+#if defined(CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE)
+static void host_port80_work_handler(struct k_work *item)
+{
+	uint32_t code = 0;
+	struct host_sub_npcx_data *data = CONTAINER_OF(item, struct host_sub_npcx_data, work);
+	struct ring_buf *rbuf = &data->port80_ring_buf;
+	struct espi_event evt = {ESPI_BUS_PERIPHERAL_NOTIFICATION,
+				 (ESPI_PERIPHERAL_INDEX_0 << 16) | ESPI_PERIPHERAL_DEBUG_PORT80,
+				 ESPI_PERIPHERAL_NODATA};
+
+	while (!ring_buf_is_empty(rbuf)) {
+		struct npcx_dp80_buf dp80_buf;
+		uint8_t offset;
+
+		ring_buf_get(rbuf, &dp80_buf.offset_code[0], sizeof(dp80_buf.offset_code));
+		offset = dp80_buf.offset_code[1];
+		code |= dp80_buf.offset_code[0] << (8 * offset);
+		if (ring_buf_is_empty(rbuf)) {
+			evt.evt_data = code;
+			espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev,
+					    evt);
+			break;
+		}
+		/* peek the offset of the next byte */
+		ring_buf_peek(rbuf, &dp80_buf.offset_code[0], sizeof(dp80_buf.offset_code));
+		offset = dp80_buf.offset_code[1];
+		/*
+		 * If the peeked next byte's offset is 0, it is the start of the new code.
+		 * Pass the current code to the application layer to handle the Port80 code.
+		 */
+		if (offset == 0) {
+			evt.evt_data = code;
+			espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev,
+					    evt);
+			code = 0;
+		}
+	}
+}
+#endif
+
 static void host_port80_isr(const void *arg)
 {
 	ARG_UNUSED(arg);
 	struct shm_reg *const inst_shm = host_sub_cfg.inst_shm;
-	struct espi_event evt = { ESPI_BUS_PERIPHERAL_NOTIFICATION,
-		(ESPI_PERIPHERAL_INDEX_0 << 16) | ESPI_PERIPHERAL_DEBUG_PORT80,
-		ESPI_PERIPHERAL_NODATA
-	};
 	uint8_t status = inst_shm->DP80STS;
 
-	LOG_DBG("%s: p80 status 0x%02X", __func__, status);
+#ifdef CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	struct ring_buf *rbuf = &host_sub_data.port80_ring_buf;
+
+	while (IS_BIT_SET(inst_shm->DP80STS, NPCX_DP80STS_FNE)) {
+		struct npcx_dp80_buf dp80_buf;
+
+		dp80_buf.offset_code_16 = inst_shm->DP80BUF;
+		ring_buf_put(rbuf, &dp80_buf.offset_code[0], sizeof(dp80_buf.offset_code));
+	}
+	k_work_submit(&host_sub_data.work);
+#else
+	struct espi_event evt = {ESPI_BUS_PERIPHERAL_NOTIFICATION,
+				 (ESPI_PERIPHERAL_INDEX_0 << 16) | ESPI_PERIPHERAL_DEBUG_PORT80,
+				 ESPI_PERIPHERAL_NODATA};
 
 	/* Read out port80 data continuously if FIFO is not empty */
 	while (IS_BIT_SET(inst_shm->DP80STS, NPCX_DP80STS_FNE)) {
 		LOG_DBG("p80: %04x", inst_shm->DP80BUF);
 		evt.evt_data = inst_shm->DP80BUF;
-		espi_send_callbacks(host_sub_data.callbacks,
-				host_sub_data.host_bus_dev, evt);
+		espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev, evt);
 	}
+#endif
+	LOG_DBG("%s: p80 status 0x%02X", __func__, status);
 
 	/* If FIFO is overflow, show error msg */
 	if (IS_BIT_SET(status, NPCX_DP80STS_FOR)) {
 		inst_shm->DP80STS |= BIT(NPCX_DP80STS_FOR);
-		LOG_ERR("Port80 FIFO Overflow!");
+		LOG_DBG("Port80 FIFO Overflow!");
 	}
 
-	/* Clear all pending bit indicates that FIFO was written by host */
-	inst_shm->DP80STS |= BIT(NPCX_DP80STS_FWR);
+	/* If there are pending post codes remains in FIFO after processing and sending previous
+	 * post codes, do not clear the FNE bit. This allows this handler to be called again
+	 * immediately after it exists.
+	 */
+	if (!IS_BIT_SET(inst_shm->DP80STS, NPCX_DP80STS_FNE)) {
+		/* Clear all pending bit indicates that FIFO was written by host */
+		inst_shm->DP80STS |= BIT(NPCX_DP80STS_FWR);
+	}
 }
 
 static void host_port80_init(void)
@@ -785,6 +856,9 @@ int npcx_host_periph_read_request(enum lpc_peripheral_opcode op,
 		case ECUSTOM_HOST_CMD_GET_PARAM_MEMORY:
 			*data = (uint32_t)shm_host_cmd;
 			break;
+		case ECUSTOM_HOST_CMD_GET_PARAM_MEMORY_SIZE:
+			*data = CONFIG_ESPI_NPCX_PERIPHERAL_HOST_CMD_PARAM_SIZE;
+			break;
 		default:
 			return -EINVAL;
 		}
@@ -975,6 +1049,9 @@ void npcx_host_init_subs_host_domain(void)
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_SHM_WND2_ADDR_0,
 		CONFIG_ESPI_PERIPHERAL_ACPI_SHM_REGION_PORT_NUM & 0xff);
 #endif
+		if (IS_ENABLED(CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE)) {
+			host_c2h_write_io_cfg_reg(EC_CFG_IDX_SHM_DP80_ADDR_RANGE, 0x0f);
+		}
 	/* Enable SHM direct memory access */
 	host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
 	}
@@ -1013,7 +1090,7 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 			return -ENODEV;
 		}
 
-		ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+		ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 				&host_sub_cfg.clks_list[i]);
 		if (ret < 0) {
 			return ret;
@@ -1050,6 +1127,11 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 #endif
 #if defined(CONFIG_ESPI_PERIPHERAL_DEBUG_PORT_80)
 	host_port80_init();
+#if defined(CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE)
+	ring_buf_init(&host_sub_data.port80_ring_buf, sizeof(host_sub_data.port80_data),
+		      host_sub_data.port80_data);
+	k_work_init(&host_sub_data.work, host_port80_work_handler);
+#endif
 #endif
 #if defined(CONFIG_ESPI_PERIPHERAL_UART)
 	host_uart_init();
@@ -1061,13 +1143,11 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 		    DT_INST_IRQ_BY_NAME(0, kbc_ibf, priority),
 		    host_kbc_ibf_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, kbc_ibf, irq));
 
 	IRQ_CONNECT(DT_INST_IRQ_BY_NAME(0, kbc_obe, irq),
 		    DT_INST_IRQ_BY_NAME(0, kbc_obe, priority),
 		    host_kbc_obe_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, kbc_obe, irq));
 #endif
 
 	/* Host PM channel (Host IO) sub-device interrupt installation */
@@ -1077,7 +1157,6 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 		    DT_INST_IRQ_BY_NAME(0, pmch_ibf, priority),
 		    host_pmch_ibf_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, pmch_ibf, irq));
 #endif
 
 	/* Host Port80 sub-device interrupt installation */
@@ -1086,7 +1165,6 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 		    DT_INST_IRQ_BY_NAME(0, p80_fifo, priority),
 		    host_port80_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, p80_fifo, irq));
 #endif
 
 	if (IS_ENABLED(CONFIG_PM)) {
diff --git a/drivers/flash/CMakeLists.txt b/drivers/flash/CMakeLists.txt
index 2e685f7a6e..6e1e9e777b 100644
--- a/drivers/flash/CMakeLists.txt
+++ b/drivers/flash/CMakeLists.txt
@@ -1,7 +1,8 @@
 # SPDX-License-Identifier: Apache-2.0
 
 zephyr_library()
-
+zephyr_library_sources_ifdef(CONFIG_FLASH_NPCX_FIU_QSPI flash_npcx_fiu_qspi.c)
+zephyr_library_sources_ifdef(CONFIG_FLASH_NPCX_FIU_NOR flash_npcx_fiu_nor.c)
 zephyr_library_sources_ifdef(CONFIG_SOC_FLASH_CC13XX_CC26XX soc_flash_cc13xx_cc26xx.c)
 zephyr_library_sources_ifdef(CONFIG_SOC_FLASH_TELINK_B91 soc_flash_b91.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_NOR spi_nor.c)
diff --git a/drivers/flash/Kconfig b/drivers/flash/Kconfig
index 64081737b0..b1d471bf8e 100644
--- a/drivers/flash/Kconfig
+++ b/drivers/flash/Kconfig
@@ -110,4 +110,6 @@ source "drivers/flash/Kconfig.cadence_qspi_nor"
 
 source "drivers/flash/Kconfig.gd32"
 
+source "drivers/flash/Kconfig.npcx_fiu"
+
 endif # FLASH
diff --git a/drivers/flash/Kconfig.npcx_fiu b/drivers/flash/Kconfig.npcx_fiu
new file mode 100644
index 0000000000..6eff013fd7
--- /dev/null
+++ b/drivers/flash/Kconfig.npcx_fiu
@@ -0,0 +1,73 @@
+# NPCX Flash driver configuration options
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config FLASH_NPCX_FIU_QSPI
+	bool "Nuvoton NPCX QSPI Bus Flash driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_FIU_QSPI_ENABLED
+	help
+	  This option enables the QSPI Bus Flash driver for NPCX family of
+	  processors.
+
+config FLASH_NPCX_FIU_NOR
+	bool "Nuvoton NPCX embedded controller (EC) QSPI NOR Flash driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_FIU_NOR_ENABLED
+	depends on FLASH_NPCX_FIU_QSPI
+	select FLASH_HAS_DRIVER_ENABLED
+	select FLASH_HAS_PAGE_LAYOUT
+	select FLASH_JESD216
+	select FLASH_HAS_EX_OP
+	help
+	  This option enables the QSPI NOR Flash driver for NPCX family of
+	  processors.
+
+if FLASH_NPCX_FIU_QSPI
+
+config FLASH_NPCX_FIU_NOR_INIT
+	bool "QSPI NOR flash feature during driver initialization"
+	default y
+	depends on FLASH_NPCX_FIU_NOR
+	help
+	  This option enables the QSPI NOR Flash features such as Quad-Enable,
+	  4-byte address support and so on during driver initialization. Disable
+	  it if QSPI NOR devices are not ready during driver initialization.
+
+config FLASH_NPCX_FIU_DRA_V1
+	bool "Direct Read Access version 1 support"
+	default y if SOC_SERIES_NPCX9
+	help
+	  This option enables DRA V1 support.
+
+config FLASH_NPCX_FIU_DRA_EX_V1
+	bool "Direct Read Access version EX_1 support"
+	default y if SOC_SERIES_NPCK3
+	help
+	  This option enables DRA EX_V1 support.
+
+config FLASH_NPCX_FIU_DRA_V2
+	bool "Direct Read Access version 2 support"
+	default y if SOC_SERIES_NPCX4
+	help
+	  This option enables DRA V1 support.
+
+config FLASH_NPCX_FIU_SUPP_DRA_4B_ADDR
+	bool "4 byte address support in Direct Read Access mode"
+	default y if FLASH_NPCX_FIU_DRA_V1    || \
+		     FLASH_NPCX_FIU_DRA_V2    || \
+		     FLASH_NPCX_FIU_DRA_EX_V1
+	help
+	  Selected if NPCX series supports 4 byte address mode in Direct Read
+	  Access mode.
+
+config FLASH_NPCX_FIU_SUPP_DRA_2_DEV
+	bool "4 byte address support in Direct Read Access mode"
+	default y if FLASH_NPCX_FIU_DRA_V1 || \
+		     FLASH_NPCX_FIU_DRA_V2
+	help
+	  Selected if NPCX series supports two external SPI devices in Direct
+	  Read Access (DRA) on QSPI bus.
+
+endif #FLASH_NPCX_FIU_QSPI
diff --git a/drivers/flash/flash_npcx_fiu_nor.c b/drivers/flash/flash_npcx_fiu_nor.c
new file mode 100644
index 0000000000..e42aa82f89
--- /dev/null
+++ b/drivers/flash/flash_npcx_fiu_nor.c
@@ -0,0 +1,623 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_fiu_nor
+
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/flash.h>
+#include <zephyr/drivers/flash/npcx_flash_api_ex.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h>
+#include <soc.h>
+#ifdef CONFIG_USERSPACE
+#include <zephyr/syscall.h>
+#include <zephyr/internal/syscall_handler.h>
+#endif
+
+#include "flash_npcx_fiu_qspi.h"
+#include "spi_nor.h"
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(flash_npcx_fiu_nor, CONFIG_FLASH_LOG_LEVEL);
+
+#define BLOCK_64K_SIZE KB(64)
+#define BLOCK_4K_SIZE  KB(4)
+
+/* Device config */
+struct flash_npcx_nor_config {
+	/* QSPI bus device for mutex control and bus configuration */
+	const struct device *qspi_bus;
+	/* Mapped address for flash read via direct access */
+	uintptr_t mapped_addr;
+	/* Size of nor device in bytes, from size property */
+	uint32_t flash_size;
+	/* Maximum chip erase time-out in ms */
+	uint32_t max_timeout;
+	/* SPI Nor device configuration on QSPI bus */
+	struct npcx_qspi_cfg qspi_cfg;
+#if defined(CONFIG_FLASH_PAGE_LAYOUT)
+	struct flash_pages_layout layout;
+#endif
+};
+
+/* Device data */
+struct flash_npcx_nor_data {
+	/* Specific control operation for Quad-SPI Nor Flash */
+	uint32_t operation;
+};
+
+static const struct flash_parameters flash_npcx_parameters = {
+	.write_block_size = 1,
+	.erase_value = 0xff,
+};
+
+#define DT_INST_QUAD_EN_PROP_OR(inst)						\
+	COND_CODE_1(DT_INST_NODE_HAS_PROP(inst, quad_enable_requirements),	\
+		    (_CONCAT(JESD216_DW15_QER_VAL_,				\
+		     DT_INST_STRING_TOKEN(inst, quad_enable_requirements))),	\
+		    ((JESD216_DW15_QER_VAL_NONE)))
+
+static inline bool is_within_region(off_t addr, size_t size, off_t region_start,
+				    size_t region_size)
+{
+	return (addr >= region_start &&
+		(addr < (region_start + region_size)) &&
+		((addr + size) <= (region_start + region_size)));
+}
+
+static int flash_npcx_uma_transceive(const struct device *dev, struct npcx_uma_cfg *cfg,
+				     uint32_t flags)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	struct flash_npcx_nor_data *data = dev->data;
+	int ret;
+
+	/* Lock SPI bus and configure it if needed */
+	qspi_npcx_fiu_mutex_lock_configure(config->qspi_bus, &config->qspi_cfg,
+					   data->operation);
+
+	/* Execute UMA transaction */
+	ret = qspi_npcx_fiu_uma_transceive(config->qspi_bus, cfg, flags);
+
+	/* Unlock SPI bus */
+	qspi_npcx_fiu_mutex_unlock(config->qspi_bus);
+
+	return ret;
+}
+
+/* NPCX UMA functions for SPI NOR flash */
+static int flash_npcx_uma_cmd_only(const struct device *dev, uint8_t opcode)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode};
+
+	return flash_npcx_uma_transceive(dev, &cfg, 0); /* opcode only */
+}
+
+static int flash_npcx_uma_cmd_by_addr(const struct device *dev, uint8_t opcode,
+					     uint32_t addr)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode};
+
+	cfg.addr.u32 = sys_cpu_to_be32(addr);
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_ADDR);
+}
+
+static int flash_npcx_uma_read(const struct device *dev, uint8_t opcode,
+			       uint8_t *dst, const size_t size)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode,
+				    .rx_buf = dst,
+				    .rx_count = size};
+
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_READ);
+}
+
+static int flash_npcx_uma_write(const struct device *dev, uint8_t opcode,
+				       uint8_t *src, const size_t size)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode,
+				    .tx_buf = src,
+				    .tx_count = size};
+
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_WRITE);
+}
+
+static int flash_npcx_uma_write_by_addr(const struct device *dev, uint8_t opcode,
+					       uint8_t *src, const size_t size, uint32_t addr)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode,
+					.tx_buf = src,
+					.tx_count = size};
+
+	cfg.addr.u32 = sys_cpu_to_be32(addr);
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_WRITE |
+					 NPCX_UMA_ACCESS_ADDR);
+}
+
+/* Local SPI NOR flash functions */
+static int flash_npcx_nor_wait_until_ready(const struct device *dev)
+{
+	int ret;
+	uint8_t reg;
+	const struct flash_npcx_nor_config *config = dev->config;
+	int64_t st = k_uptime_get();
+
+	do {
+		ret = flash_npcx_uma_read(dev, SPI_NOR_CMD_RDSR, &reg, sizeof(reg));
+		if (ret != 0) {
+			return ret;
+		} else if ((reg & SPI_NOR_WIP_BIT) == 0) {
+			return 0;
+		}
+
+	} while ((k_uptime_get() - st) < config->max_timeout);
+
+	return -EBUSY;
+}
+
+static int flash_npcx_nor_read_status_regs(const struct device *dev, uint8_t *sts_reg)
+{
+	int ret = flash_npcx_uma_read(dev, SPI_NOR_CMD_RDSR, sts_reg, 1);
+
+	if (ret != 0) {
+		return ret;
+	}
+	return flash_npcx_uma_read(dev, SPI_NOR_CMD_RDSR2, sts_reg + 1, 1);
+}
+
+static int flash_npcx_nor_write_status_regs(const struct device *dev, uint8_t *sts_reg)
+{
+	int ret;
+
+	ret = flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = flash_npcx_uma_write(dev, SPI_NOR_CMD_WRSR, sts_reg, 2);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return flash_npcx_nor_wait_until_ready(dev);
+}
+
+/* Flash API functions */
+#if defined(CONFIG_FLASH_JESD216_API)
+static int flash_npcx_nor_read_jedec_id(const struct device *dev, uint8_t *id)
+{
+	if (id == NULL) {
+		return -EINVAL;
+	}
+
+	return flash_npcx_uma_read(dev, SPI_NOR_CMD_RDID, id, SPI_NOR_MAX_ID_LEN);
+}
+
+static int flash_npcx_nor_read_sfdp(const struct device *dev, off_t addr,
+				    void *data, size_t size)
+{
+	uint8_t sfdp_addr[4];
+	struct npcx_uma_cfg cfg = { .opcode = JESD216_CMD_READ_SFDP,
+					.tx_buf = sfdp_addr,
+					.tx_count = 4,
+					.rx_buf = data,
+					.rx_count = size};
+
+	if (data == NULL) {
+		return -EINVAL;
+	}
+
+	/* CMD_READ_SFDP needs a 24-bit address followed by a dummy byte */
+	sfdp_addr[0] = (addr >> 16) & 0xff;
+	sfdp_addr[1] = (addr >> 8) & 0xff;
+	sfdp_addr[2] = addr & 0xff;
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_WRITE |
+					 NPCX_UMA_ACCESS_READ);
+}
+#endif /* CONFIG_FLASH_JESD216_API */
+
+#if defined(CONFIG_FLASH_PAGE_LAYOUT)
+static void flash_npcx_nor_pages_layout(const struct device *dev,
+					const struct flash_pages_layout **layout,
+					size_t *layout_size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+
+	*layout = &config->layout;
+	*layout_size = 1;
+}
+#endif /* CONFIG_FLASH_PAGE_LAYOUT */
+
+static int flash_npcx_nor_read(const struct device *dev, off_t addr,
+				 void *data, size_t size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	struct flash_npcx_nor_data *dev_data = dev->data;
+
+	/* Out of the region of nor flash device? */
+	if (!is_within_region(addr, size, 0, config->flash_size)) {
+		return -EINVAL;
+	}
+
+	/* Lock/Unlock SPI bus also for DRA mode */
+	qspi_npcx_fiu_mutex_lock_configure(config->qspi_bus, &config->qspi_cfg,
+					   dev_data->operation);
+
+	/* Trigger Direct Read Access (DRA) via reading memory mapped-address */
+	memcpy(data, (void *)(config->mapped_addr + addr), size);
+
+	qspi_npcx_fiu_mutex_unlock(config->qspi_bus);
+
+	return 0;
+}
+
+static int flash_npcx_nor_erase(const struct device *dev, off_t addr, size_t size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	int ret = 0;
+
+	/* Out of the region of nor flash device? */
+	if (!is_within_region(addr, size, 0, config->flash_size)) {
+		LOG_ERR("Addr %ld, size %d are out of range", addr, size);
+		return -EINVAL;
+	}
+
+	/* address must be sector-aligned */
+	if (!SPI_NOR_IS_SECTOR_ALIGNED(addr)) {
+		LOG_ERR("Addr %ld is not sector-aligned", addr);
+		return -EINVAL;
+	}
+
+	/* size must be a multiple of sectors */
+	if ((size % BLOCK_4K_SIZE) != 0) {
+		LOG_ERR("Size %d is not a multiple of sectors", size);
+		return -EINVAL;
+	}
+
+	/* Select erase opcode by size */
+	if (size == config->flash_size) {
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+		/* Send chip erase command */
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_CE);
+		return flash_npcx_nor_wait_until_ready(dev);
+	}
+
+	while (size > 0) {
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+		/* Send page/block erase command with addr */
+		if ((size >= BLOCK_64K_SIZE) && SPI_NOR_IS_64K_ALIGNED(addr)) {
+			flash_npcx_uma_cmd_by_addr(dev, SPI_NOR_CMD_BE, addr);
+			addr += BLOCK_64K_SIZE;
+			size -= BLOCK_64K_SIZE;
+		} else {
+			flash_npcx_uma_cmd_by_addr(dev, SPI_NOR_CMD_SE, addr);
+			addr += BLOCK_4K_SIZE;
+			size -= BLOCK_4K_SIZE;
+		}
+		ret = flash_npcx_nor_wait_until_ready(dev);
+		if (ret != 0) {
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int flash_npcx_nor_write(const struct device *dev, off_t addr,
+				  const void *data, size_t size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	uint8_t *tx_buf = (uint8_t *)data;
+	int ret = 0;
+	size_t sz_write;
+
+	/* Out of the region of nor flash device? */
+	if (!is_within_region(addr, size, 0, config->flash_size)) {
+		return -EINVAL;
+	}
+
+	/* Don't write more than a page. */
+	if (size > SPI_NOR_PAGE_SIZE) {
+		sz_write = SPI_NOR_PAGE_SIZE;
+	} else {
+		sz_write = size;
+	}
+
+	/*
+	 * Correct the size of first write to not go through page boundary and
+	 * make the address of next write to align to page boundary.
+	 */
+	if (((addr + sz_write - 1U) / SPI_NOR_PAGE_SIZE) != (addr / SPI_NOR_PAGE_SIZE)) {
+		sz_write -= (addr + sz_write) & (SPI_NOR_PAGE_SIZE - 1);
+	}
+
+	while (size > 0) {
+		/* Start to write */
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+		ret = flash_npcx_uma_write_by_addr(dev, SPI_NOR_CMD_PP, tx_buf,
+						   sz_write, addr);
+		if (ret != 0) {
+			break;
+		}
+
+		/* Wait for writing completed */
+		ret = flash_npcx_nor_wait_until_ready(dev);
+		if (ret != 0) {
+			break;
+		}
+
+		size -= sz_write;
+		tx_buf += sz_write;
+		addr += sz_write;
+
+		if (size > SPI_NOR_PAGE_SIZE) {
+			sz_write = SPI_NOR_PAGE_SIZE;
+		} else {
+			sz_write = size;
+		}
+	}
+
+	return ret;
+}
+
+static const struct flash_parameters *
+flash_npcx_nor_get_parameters(const struct device *dev)
+{
+	ARG_UNUSED(dev);
+
+	return &flash_npcx_parameters;
+};
+
+#ifdef CONFIG_FLASH_EX_OP_ENABLED
+static int flash_npcx_nor_ex_exec_uma(const struct device *dev,
+				      const struct npcx_ex_ops_uma_in *op_in,
+				      const struct npcx_ex_ops_uma_out *op_out)
+{
+	int flag = 0;
+	struct npcx_uma_cfg cfg;
+
+	if (op_in == NULL) {
+		return -EINVAL;
+	}
+
+	/* Organize a UMA transaction */
+	cfg.opcode = op_in->opcode;
+	if (op_in->tx_count != 0) {
+		cfg.tx_buf = op_in->tx_buf;
+		cfg.tx_count = op_in->tx_count;
+		flag |= NPCX_UMA_ACCESS_WRITE;
+	}
+
+	if (op_in->addr_count != 0) {
+		cfg.addr.u32 = sys_cpu_to_be32(op_in->addr);
+		flag |= NPCX_UMA_ACCESS_ADDR;
+	}
+
+	if (op_out != NULL && op_in->rx_count != 0) {
+		cfg.rx_buf = op_out->rx_buf;
+		cfg.rx_count = op_in->rx_count;
+		flag |= NPCX_UMA_ACCESS_READ;
+	}
+
+	return flash_npcx_uma_transceive(dev, &cfg, flag);
+}
+
+static int flash_npcx_nor_ex_set_spi_spec(const struct device *dev,
+					  const struct npcx_ex_ops_qspi_oper_in *op_in)
+{
+	struct flash_npcx_nor_data *data = dev->data;
+
+	/* Cannot disable write protection of internal flash */
+	if ((data->operation & NPCX_EX_OP_INT_FLASH_WP) != 0) {
+		if ((op_in->mask & NPCX_EX_OP_INT_FLASH_WP) != 0 && !op_in->enable) {
+			return -EINVAL;
+		}
+	}
+
+	if (op_in->enable) {
+		data->operation |= op_in->mask;
+	} else {
+		data->operation &= ~op_in->mask;
+	}
+
+	return 0;
+}
+
+static int flash_npcx_nor_ex_get_spi_spec(const struct device *dev,
+					  struct npcx_ex_ops_qspi_oper_out *op_out)
+{
+	struct flash_npcx_nor_data *data = dev->data;
+
+	op_out->oper = data->operation;
+	return 0;
+}
+
+static int flash_npcx_nor_ex_op(const struct device *dev, uint16_t code,
+				const uintptr_t in, void *out)
+{
+#ifdef CONFIG_USERSPACE
+	bool syscall_trap = z_syscall_trap();
+#endif
+	int ret;
+
+	switch (code) {
+	case FLASH_NPCX_EX_OP_EXEC_UMA:
+	{
+		struct npcx_ex_ops_uma_in *op_in = (struct npcx_ex_ops_uma_in *)in;
+		struct npcx_ex_ops_uma_out *op_out = (struct npcx_ex_ops_uma_out *)out;
+#ifdef CONFIG_USERSPACE
+		struct npcx_ex_ops_uma_in in_copy;
+		struct npcx_ex_ops_uma_out out_copy;
+
+		if (syscall_trap) {
+			K_OOPS(k_usermode_from_copy(&in_copy, op_in, sizeof(in_copy)));
+			op_in = &in_copy;
+			op_out = &out_copy;
+		}
+#endif
+
+		ret = flash_npcx_nor_ex_exec_uma(dev, op_in, op_out);
+#ifdef CONFIG_USERSPACE
+		if (ret == 0 && syscall_trap) {
+			K_OOPS(k_usermode_to_copy(out, op_out, sizeof(out_copy)));
+		}
+#endif
+		break;
+	}
+	case FLASH_NPCX_EX_OP_SET_QSPI_OPER:
+	{
+		struct npcx_ex_ops_qspi_oper_in *op_in = (struct npcx_ex_ops_qspi_oper_in *)in;
+#ifdef CONFIG_USERSPACE
+		struct npcx_ex_ops_qspi_oper_in in_copy;
+
+		if (syscall_trap) {
+			K_OOPS(k_usermode_from_copy(&in_copy, op_in, sizeof(in_copy)));
+			op_in = &in_copy;
+		}
+#endif
+		ret = flash_npcx_nor_ex_set_spi_spec(dev, op_in);
+		break;
+	}
+	case FLASH_NPCX_EX_OP_GET_QSPI_OPER:
+	{
+		struct npcx_ex_ops_qspi_oper_out *op_out =
+		(struct npcx_ex_ops_qspi_oper_out *)out;
+#ifdef CONFIG_USERSPACE
+		struct npcx_ex_ops_qspi_oper_out out_copy;
+
+		if (syscall_trap) {
+			op_out = &out_copy;
+		}
+#endif
+		ret = flash_npcx_nor_ex_get_spi_spec(dev, op_out);
+#ifdef CONFIG_USERSPACE
+		if (ret == 0 && syscall_trap) {
+			K_OOPS(k_usermode_to_copy(out, op_out, sizeof(out_copy)));
+		}
+#endif
+		break;
+	}
+	default:
+		ret = -ENOTSUP;
+		break;
+	}
+
+	return ret;
+}
+#endif
+
+static const struct flash_driver_api flash_npcx_nor_driver_api = {
+	.read = flash_npcx_nor_read,
+	.write = flash_npcx_nor_write,
+	.erase = flash_npcx_nor_erase,
+	.get_parameters = flash_npcx_nor_get_parameters,
+#if defined(CONFIG_FLASH_PAGE_LAYOUT)
+	.page_layout = flash_npcx_nor_pages_layout,
+#endif
+#if defined(CONFIG_FLASH_JESD216_API)
+	.sfdp_read = flash_npcx_nor_read_sfdp,
+	.read_jedec_id = flash_npcx_nor_read_jedec_id,
+#endif
+#ifdef CONFIG_FLASH_EX_OP_ENABLED
+	.ex_op = flash_npcx_nor_ex_op,
+#endif
+};
+
+static int flash_npcx_nor_init(const struct device *dev)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_FLASH_NPCX_FIU_NOR_INIT)) {
+		return 0;
+	}
+
+	/* Enable quad access of spi NOR flash */
+	if (config->qspi_cfg.qer_type != JESD216_DW15_QER_NONE) {
+		uint8_t qe_idx, qe_bit, sts_reg[2];
+		/* Read status registers first */
+		ret = flash_npcx_nor_read_status_regs(dev, sts_reg);
+		if (ret != 0) {
+			LOG_ERR("Enable quad access: read reg failed %d!", ret);
+			return ret;
+		}
+		switch (config->qspi_cfg.qer_type) {
+		case JESD216_DW15_QER_S1B6:
+			qe_idx = 1;
+			qe_bit = 6;
+			break;
+		case JESD216_DW15_QER_S2B1v1:
+			__fallthrough;
+		case JESD216_DW15_QER_S2B1v4:
+			__fallthrough;
+		case JESD216_DW15_QER_S2B1v5:
+			qe_idx = 2;
+			qe_bit = 1;
+			break;
+		default:
+			return -ENOTSUP;
+		}
+		/* Set QE bit in status register */
+		sts_reg[qe_idx - 1] |= BIT(qe_bit);
+		ret = flash_npcx_nor_write_status_regs(dev, sts_reg);
+		if (ret != 0) {
+			LOG_ERR("Enable quad access: write reg failed %d!", ret);
+			return ret;
+		}
+	}
+
+	/* Enable 4-byte address of spi NOR flash */
+	if (config->qspi_cfg.enter_4ba != 0) {
+		bool wr_en = (config->qspi_cfg.enter_4ba & 0x02) != 0;
+
+		if (wr_en) {
+			ret = flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+			if (ret != 0) {
+				LOG_ERR("Enable 4byte addr: WREN failed %d!", ret);
+				return ret;
+			}
+		}
+		ret = flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_4BA);
+		if (ret != 0) {
+			LOG_ERR("Enable 4byte addr: 4BA failed %d!", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+#define NPCX_FLASH_NOR_INIT(n)							\
+BUILD_ASSERT(DT_INST_QUAD_EN_PROP_OR(n) == JESD216_DW15_QER_NONE ||		\
+	     DT_INST_STRING_TOKEN(n, rd_mode) == NPCX_RD_MODE_FAST_DUAL,	\
+	     "Fast Dual IO read must be selected in Quad mode");		\
+PINCTRL_DT_INST_DEFINE(n);							\
+static const struct flash_npcx_nor_config flash_npcx_nor_config_##n = {		\
+	.qspi_bus = DEVICE_DT_GET(DT_PARENT(DT_DRV_INST(n))),			\
+	.mapped_addr = DT_INST_PROP(n, mapped_addr),				\
+	.flash_size = DT_INST_PROP(n, size) / 8,				\
+	.max_timeout = DT_INST_PROP(n, max_timeout),				\
+	.qspi_cfg = {								\
+		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),			\
+		.flags = DT_INST_PROP(n, qspi_flags),				\
+		.enter_4ba = DT_INST_PROP_OR(n, enter_4byte_addr, 0),		\
+		.qer_type = DT_INST_QUAD_EN_PROP_OR(n),				\
+		.rd_mode = DT_INST_STRING_TOKEN(n, rd_mode),			\
+	},									\
+	IF_ENABLED(CONFIG_FLASH_PAGE_LAYOUT, (					\
+		.layout = {							\
+			.pages_count = DT_INST_PROP(n, size) /			\
+				      (8 * SPI_NOR_PAGE_SIZE),			\
+			.pages_size  = SPI_NOR_PAGE_SIZE,			\
+		},))								\
+};										\
+static struct flash_npcx_nor_data flash_npcx_nor_data_##n;			\
+DEVICE_DT_INST_DEFINE(n, flash_npcx_nor_init, NULL,				\
+		      &flash_npcx_nor_data_##n, &flash_npcx_nor_config_##n,	\
+		      POST_KERNEL, CONFIG_FLASH_INIT_PRIORITY,			\
+		      &flash_npcx_nor_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(NPCX_FLASH_NOR_INIT)
diff --git a/drivers/flash/flash_npcx_fiu_qspi.c b/drivers/flash/flash_npcx_fiu_qspi.c
new file mode 100644
index 0000000000..f1057889d6
--- /dev/null
+++ b/drivers/flash/flash_npcx_fiu_qspi.c
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_fiu_qspi
+
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/flash/npcx_flash_api_ex.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/drivers/spi.h>
+#include <zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h>
+#include <soc.h>
+
+#include "flash_npcx_fiu_qspi.h"
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(npcx_fiu_qspi, LOG_LEVEL_ERR);
+
+/* Driver convenience defines */
+#define HAL_INSTANCE(dev) \
+	((struct fiu_reg *)((const struct npcx_qspi_fiu_config *)(dev)->config)->base)
+
+/* Device config */
+struct npcx_qspi_fiu_config {
+	/* Flash interface unit base address */
+	uintptr_t base;
+	/* Clock configuration */
+	struct npcx_clk_cfg clk_cfg;
+	/* Enable 2 external SPI devices for direct read on QSPI bus */
+	bool en_direct_access_2dev;
+};
+
+/* Device data */
+struct npcx_qspi_fiu_data {
+	/* mutex of qspi bus controller */
+	struct k_sem lock_sem;
+	/* Current device configuration on QSPI bus */
+	const struct npcx_qspi_cfg *cur_cfg;
+	/* Current Software controlled Chip-Select number */
+	int sw_cs;
+	/* Current QSPI bus operation */
+	uint32_t operation;
+};
+
+/* NPCX SPI User Mode Access (UMA) functions */
+static inline void qspi_npcx_uma_cs_level(const struct device *dev, uint8_t sw_cs, bool level)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Automatic block access support during a UMA trasaction in NPCK series */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if (level == 0) {
+		inst->FIU_MSR_IE_CFG |= BIT(NPCX_MSR_IE_CFG_UMA_BLOCK);
+	}
+#endif
+
+	/* Set chip select to high/low level */
+	if (level) {
+		inst->UMA_ECTS |= BIT(sw_cs);
+	} else {
+		inst->UMA_ECTS &= ~BIT(sw_cs);
+	}
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if (level == 1) {
+		inst->FIU_MSR_IE_CFG &= ~BIT(NPCX_MSR_IE_CFG_UMA_BLOCK);
+	}
+#endif
+}
+
+static inline void npcx_uma_start(const struct device *dev, uint8_t code)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	code &= ~BIT(NPCX_UMA_CTS_DEV_NUM);
+	inst->UMA_CTS = (inst->UMA_CTS & BIT(NPCX_UMA_CTS_DEV_NUM)) | code;
+#else
+	inst->UMA_CTS = code;
+#endif
+}
+
+static inline void qspi_npcx_uma_write_byte(const struct device *dev, uint8_t data)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Set data to UMA_CODE and trigger UMA */
+	inst->UMA_CODE = data;
+	npcx_uma_start(dev, UMA_CODE_CMD_WR_ONLY);
+	/* EXEC_DONE will be zero automatically if a UMA transaction is completed. */
+	while (IS_BIT_SET(inst->UMA_CTS, NPCX_UMA_CTS_EXEC_DONE)) {
+		continue;
+	}
+}
+
+static inline void qspi_npcx_uma_read_byte(const struct device *dev, uint8_t *data)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Trigger UMA and Get data from DB0 later */
+	npcx_uma_start(dev, UMA_CODE_RD_BYTE(1));
+	while (IS_BIT_SET(inst->UMA_CTS, NPCX_UMA_CTS_EXEC_DONE)) {
+		continue;
+	}
+
+	*data = inst->UMA_DB0;
+}
+
+/* NPCX SPI Direct Read Access (DRA)/User Mode Access (UMA) configuration functions */
+static inline void qspi_npcx_config_uma_mode(const struct device *dev,
+					     const struct npcx_qspi_cfg *qspi_cfg)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if ((qspi_cfg->flags & NPCX_QSPI_SHD_FLASH_SL) != 0) {
+		inst->UMA_CTS |= BIT(NPCX_UMA_CTS_DEV_NUM);
+		inst->UMA_ECTS &= ~BIT(NPCX_UMA_ECTS_UMA_DEV_BKP);
+	} else if ((qspi_cfg->flags & NPCX_QSPI_PVT_FLASH_SL) != 0) {
+		inst->UMA_CTS &= ~BIT(NPCX_UMA_CTS_DEV_NUM);
+		inst->UMA_ECTS &= ~BIT(NPCX_UMA_ECTS_UMA_DEV_BKP);
+	} else if ((qspi_cfg->flags & NPCX_QSPI_BKP_FLASH_SL) != 0) {
+		inst->UMA_ECTS |= BIT(NPCX_UMA_ECTS_UMA_DEV_BKP);
+	}
+#else
+	if ((qspi_cfg->flags & NPCX_QSPI_SEC_FLASH_SL) != 0) {
+		inst->UMA_ECTS |= BIT(NPCX_UMA_ECTS_SEC_CS);
+	} else {
+		inst->UMA_ECTS &= ~BIT(NPCX_UMA_ECTS_SEC_CS);
+	}
+#endif /* CONFIG_SOC_SERIES_NPCK3 */
+}
+
+static inline void qspi_npcx_config_dra_4byte_mode(const struct device *dev,
+						   const struct npcx_qspi_cfg *qspi_cfg)
+{
+#if defined(CONFIG_FLASH_NPCX_FIU_SUPP_DRA_4B_ADDR)
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+#if defined(CONFIG_FLASH_NPCX_FIU_DRA_V1)
+	if (qspi_cfg->enter_4ba != 0) {
+		if ((qspi_cfg->flags & NPCX_QSPI_SEC_FLASH_SL) != 0) {
+			inst->SPI1_DEV |= BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS11);
+		} else {
+			inst->SPI1_DEV |= BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS10);
+		}
+	} else {
+		inst->SPI1_DEV &= ~(BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS11) |
+				    BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS10));
+	}
+#elif defined(CONFIG_FLASH_NPCX_FIU_DRA_V2)
+	if (qspi_cfg->enter_4ba != 0) {
+		SET_FIELD(inst->SPI_DEV, NPCX_SPI_DEV_NADDRB, NPCX_DEV_NUM_ADDR_4BYTE);
+	}
+#elif defined(CONFIG_FLASH_NPCX_FIU_DRA_EX_V1)
+	if (qspi_cfg->enter_4ba != 0) {
+		if ((qspi_cfg->flags & NPCX_QSPI_SHD_FLASH_SL) != 0) {
+			inst->FIU_4B_EN |= BIT(NPCX_MSR_FIU_4B_EN_SHD_4B);
+		} else if ((qspi_cfg->flags & NPCX_QSPI_PVT_FLASH_SL) != 0) {
+			inst->FIU_4B_EN |= BIT(NPCX_MSR_FIU_4B_EN_PVT_4B);
+		} else if ((qspi_cfg->flags & NPCX_QSPI_BKP_FLASH_SL) != 0) {
+			inst->FIU_4B_EN |= BIT(NPCX_MSR_FIU_4B_EN_BKP_4B);
+		}
+	}
+#endif
+#endif /* CONFIG_FLASH_NPCX_FIU_SUPP_DRA_4B_ADDR */
+}
+
+static inline void qspi_npcx_config_dra_mode(const struct device *dev,
+					     const struct npcx_qspi_cfg *qspi_cfg)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Select SPI device number for DRA mode in npcx4 series */
+	if (IS_ENABLED(CONFIG_FLASH_NPCX_FIU_DRA_V2)) {
+		int spi_dev_num = (qspi_cfg->flags & NPCX_QSPI_SEC_FLASH_SL) != 0 ? 1 : 0;
+
+		SET_FIELD(inst->BURST_CFG, NPCX_BURST_CFG_SPI_DEV_SEL, spi_dev_num);
+	}
+
+	/* Enable quad mode of Direct Read Mode if needed */
+	if (qspi_cfg->qer_type != JESD216_DW15_QER_NONE) {
+		inst->RESP_CFG |= BIT(NPCX_RESP_CFG_QUAD_EN);
+	} else {
+		inst->RESP_CFG &= ~BIT(NPCX_RESP_CFG_QUAD_EN);
+	}
+
+	/* Selects the SPI read access type of Direct Read Access mode */
+	SET_FIELD(inst->SPI_FL_CFG, NPCX_SPI_FL_CFG_RD_MODE, qspi_cfg->rd_mode);
+
+	/* Enable/Disable 4 byte address mode for Direct Read Access (DRA) */
+	qspi_npcx_config_dra_4byte_mode(dev, qspi_cfg);
+}
+
+static inline void qspi_npcx_fiu_set_operation(const struct device *dev, uint32_t operation)
+{
+	if ((operation & NPCX_EX_OP_INT_FLASH_WP) != 0) {
+		npcx_pinctrl_flash_write_protect_set();
+	}
+}
+
+/* NPCX specific QSPI-FIU controller functions */
+int qspi_npcx_fiu_uma_transceive(const struct device *dev, struct npcx_uma_cfg *cfg,
+				     uint32_t flags)
+{
+	struct npcx_qspi_fiu_data *const data = dev->data;
+
+	/* UMA transaction is permitted? */
+	if ((data->operation & NPCX_EX_OP_LOCK_UMA) != 0) {
+		return -EPERM;
+	}
+
+	/* Assert chip select */
+	qspi_npcx_uma_cs_level(dev, data->sw_cs, false);
+
+	/* Transmit op-code first */
+	qspi_npcx_uma_write_byte(dev, cfg->opcode);
+
+	if ((flags & NPCX_UMA_ACCESS_ADDR) != 0) {
+		/* 3-byte or 4-byte address? */
+		const int addr_start = (data->cur_cfg->enter_4ba != 0) ? 0 : 1;
+
+		for (size_t i = addr_start; i < 4; i++) {
+			LOG_DBG("addr %d, %02x", i, cfg->addr.u8[i]);
+			qspi_npcx_uma_write_byte(dev, cfg->addr.u8[i]);
+		}
+	}
+
+	if ((flags & NPCX_UMA_ACCESS_WRITE) != 0) {
+		if (cfg->tx_buf == NULL) {
+			return -EINVAL;
+		}
+		for (size_t i = 0; i < cfg->tx_count; i++) {
+			qspi_npcx_uma_write_byte(dev, cfg->tx_buf[i]);
+		}
+	}
+
+	if ((flags & NPCX_UMA_ACCESS_READ) != 0) {
+		if (cfg->rx_buf == NULL) {
+			return -EINVAL;
+		}
+		for (size_t i = 0; i < cfg->rx_count; i++) {
+			qspi_npcx_uma_read_byte(dev, cfg->rx_buf + i);
+		}
+	}
+
+	/* De-assert chip select */
+	qspi_npcx_uma_cs_level(dev, data->sw_cs, true);
+
+	return 0;
+}
+
+void qspi_npcx_fiu_mutex_lock_configure(const struct device *dev,
+					const struct npcx_qspi_cfg *cfg,
+					const uint32_t operation)
+{
+	struct npcx_qspi_fiu_data *const data = dev->data;
+
+	k_sem_take(&data->lock_sem, K_FOREVER);
+
+	/* If the current device is different from previous one, configure it */
+	if (data->cur_cfg != cfg) {
+		data->cur_cfg = cfg;
+
+		/* Apply pin-muxing and tri-state */
+		pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
+
+		/* Configure User Mode Access (UMA) settings */
+		qspi_npcx_config_uma_mode(dev, cfg);
+
+		/* Configure for Direct Read Access (DRA) settings */
+		qspi_npcx_config_dra_mode(dev, cfg);
+
+		/* Save SW CS bit used in UMA mode */
+		data->sw_cs = find_lsb_set(cfg->flags & NPCX_QSPI_SW_CS_MASK) - 1;
+	}
+
+	/* Set QSPI bus operation */
+	if (data->operation != operation) {
+		qspi_npcx_fiu_set_operation(dev, operation);
+		data->operation = operation;
+	}
+}
+
+void qspi_npcx_fiu_mutex_unlock(const struct device *dev)
+{
+	struct npcx_qspi_fiu_data *const data = dev->data;
+
+	k_sem_give(&data->lock_sem);
+}
+
+static int qspi_npcx_fiu_init(const struct device *dev)
+{
+	const struct npcx_qspi_fiu_config *const config = dev->config;
+	struct npcx_qspi_fiu_data *const data = dev->data;
+	const struct device *const clk_dev = DEVICE_DT_GET(NPCX_CLK_CTRL_NODE);
+	int ret;
+
+	if (!device_is_ready(clk_dev)) {
+		LOG_ERR("%s device not ready", clk_dev->name);
+		return -ENODEV;
+	}
+
+	/* Turn on device clock first and get source clock freq. */
+	ret = clock_control_on(clk_dev,
+			       (clock_control_subsys_t)&config->clk_cfg);
+	if (ret < 0) {
+		LOG_ERR("Turn on FIU clock fail %d", ret);
+		return ret;
+	}
+
+	/* initialize mutex for qspi controller */
+	k_sem_init(&data->lock_sem, 1, 1);
+
+	/* Enable direct access for 2 external SPI devices */
+	if (config->en_direct_access_2dev) {
+#if defined(CONFIG_FLASH_NPCX_FIU_SUPP_DRA_2_DEV)
+		struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+		inst->FIU_EXT_CFG |= BIT(NPCX_FIU_EXT_CFG_SPI1_2DEV);
+#endif
+	}
+
+	return 0;
+}
+
+#define NPCX_SPI_FIU_INIT(n)							\
+static const struct npcx_qspi_fiu_config npcx_qspi_fiu_config_##n = {		\
+	.base = DT_INST_REG_ADDR(n),						\
+	.clk_cfg = NPCX_DT_CLK_CFG_ITEM(n),					\
+	.en_direct_access_2dev = DT_INST_PROP(n, en_direct_access_2dev),	\
+};										\
+static struct npcx_qspi_fiu_data npcx_qspi_fiu_data_##n;			\
+DEVICE_DT_INST_DEFINE(n, qspi_npcx_fiu_init, NULL,				\
+		      &npcx_qspi_fiu_data_##n, &npcx_qspi_fiu_config_##n,	\
+		      PRE_KERNEL_1, CONFIG_FLASH_INIT_PRIORITY, NULL);
+
+DT_INST_FOREACH_STATUS_OKAY(NPCX_SPI_FIU_INIT)
diff --git a/drivers/flash/flash_npcx_fiu_qspi.h b/drivers/flash/flash_npcx_fiu_qspi.h
new file mode 100644
index 0000000000..1136684d45
--- /dev/null
+++ b/drivers/flash/flash_npcx_fiu_qspi.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_DRIVERS_FLASH_NPCX_FIU_QSPI_H_
+#define ZEPHYR_DRIVERS_FLASH_NPCX_FIU_QSPI_H_
+
+#include <zephyr/device.h>
+#include "jesd216.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* UMA operation flags */
+#define NPCX_UMA_ACCESS_WRITE BIT(0)
+#define NPCX_UMA_ACCESS_READ  BIT(1)
+#define NPCX_UMA_ACCESS_ADDR  BIT(2)
+
+/* Valid value of Dn_NADDRB that sets the number of address bytes in a transaction */
+#define NPCX_DEV_NUM_ADDR_1BYTE 1
+#define NPCX_DEV_NUM_ADDR_2BYTE 2
+#define NPCX_DEV_NUM_ADDR_3BYTE 3
+#define NPCX_DEV_NUM_ADDR_4BYTE 4
+
+/* UMA operation configuration for a SPI device */
+struct npcx_uma_cfg {
+	uint8_t opcode;
+	uint8_t *tx_buf;
+	size_t  tx_count;
+	uint8_t *rx_buf;
+	size_t rx_count;
+	union {
+		uint32_t u32;
+		uint8_t u8[4];
+	} addr;
+};
+
+/* QSPI bus configuration for a SPI device */
+struct npcx_qspi_cfg {
+	/* Type of Quad Enable bit in status register */
+	enum jesd216_dw15_qer_type qer_type;
+	/* Pinctrl for QSPI bus */
+	const struct pinctrl_dev_config *pcfg;
+	/* Enter four bytes address mode value */
+	uint8_t enter_4ba;
+	/* SPI read access type of Direct Read Access mode */
+	uint8_t rd_mode;
+	/* Configurations for the Quad-SPI peripherals */
+	int flags;
+};
+
+/**
+ * @brief Execute UMA transactions on qspi bus
+ *
+ * @param dev Pointer to the device structure for qspi bus controller instance.
+ * @param cfg Pointer to the configuration of UMA transactions.
+ * @param flags Flags to be used during transactions.
+ * @retval 0 on success, -EPERM if an UMA transaction is not permitted.
+ */
+int qspi_npcx_fiu_uma_transceive(const struct device *dev, struct npcx_uma_cfg *cfg,
+				 uint32_t flags);
+
+/**
+ * @brief Lock the mutex of npcx qspi bus controller and apply its configuration
+ *
+ * @param dev Pointer to the device structure for qspi bus controller instance.
+ * @param cfg Pointer to the configuration for the device on qspi bus.
+ * @param operation Qspi bus operation for the device.
+ */
+void qspi_npcx_fiu_mutex_lock_configure(const struct device *dev,
+					const struct npcx_qspi_cfg *cfg,
+					const uint32_t operation);
+
+/**
+ * @brief Unlock the mutex of npcx qspi bus controller.
+ *
+ * @param dev Pointer to the device structure for qspi bus controller instance.
+ */
+void qspi_npcx_fiu_mutex_unlock(const struct device *dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZEPHYR_DRIVERS_FLASH_NPCX_FIU_QSPI_H_ */
diff --git a/drivers/gpio/gpio_npcx.c b/drivers/gpio/gpio_npcx.c
index 201c44b289..dc09753f34 100644
--- a/drivers/gpio/gpio_npcx.c
+++ b/drivers/gpio/gpio_npcx.c
@@ -9,6 +9,7 @@
 #include <zephyr/kernel.h>
 #include <zephyr/device.h>
 #include <zephyr/drivers/gpio.h>
+#include <zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h>
 #include <soc.h>
 
 #include "gpio_utils.h"
@@ -127,11 +128,13 @@ static int gpio_npcx_config(const struct device *dev,
 
 	/* Does this IO pad support low-voltage input (1.8V) detection? */
 	if (lvol->ctrl != NPCX_DT_LVOL_CTRL_NONE) {
+		gpio_flags_t volt = flags & NPCX_GPIO_VOLTAGE_MASK;
+
 		/*
 		 * If this IO pad is configured for low-voltage input detection,
 		 * the related drive type must select to open-drain also.
 		 */
-		if ((flags & GPIO_VOLTAGE_1P8) != 0) {
+		if (volt == NPCX_GPIO_VOLTAGE_1P8) {
 			flags |= GPIO_OPEN_DRAIN;
 			npcx_lvol_set_detect_level(lvol->ctrl, lvol->bit, true);
 		} else {
@@ -215,7 +218,7 @@ static int gpio_npcx_pin_get_config(const struct device *port, gpio_pin_t pin,
 	/* Enable low-voltage detection? */
 	if (lvol->ctrl != NPCX_DT_LVOL_CTRL_NONE &&
 		npcx_lvol_get_detect_level(lvol->ctrl, lvol->bit)) {
-		flags |= GPIO_VOLTAGE_1P8;
+		flags |= NPCX_GPIO_VOLTAGE_1P8;
 	};
 
 	*out_flags = flags;
@@ -296,6 +299,15 @@ static int gpio_npcx_pin_interrupt_configure(const struct device *dev,
 			config->port, pin, config->wui_maps[pin].table,
 			config->wui_maps[pin].group,
 			config->wui_maps[pin].bit);
+#ifdef CONFIG_GPIO_ENABLE_DISABLE_INTERRUPT
+	if (mode == GPIO_INT_MODE_DISABLE_ONLY) {
+		npcx_miwu_irq_disable(&config->wui_maps[pin]);
+		return 0;
+	} else if (mode == GPIO_INT_MODE_ENABLE_ONLY) {
+		npcx_miwu_irq_enable(&config->wui_maps[pin]);
+		return 0;
+	}
+#endif /* CONFIG_GPIO_ENABLE_DISABLE_INTERRUPT */
 
 	/* Disable irq of wake-up input io-pads before configuring them */
 	npcx_miwu_irq_disable(&config->wui_maps[pin]);
@@ -344,7 +356,7 @@ static int gpio_npcx_manage_callback(const struct device *dev,
 				      struct gpio_callback *callback, bool set)
 {
 	const struct gpio_npcx_config *const config = dev->config;
-	struct miwu_io_callback *miwu_cb = (struct miwu_io_callback *)callback;
+	struct miwu_callback *miwu_cb = (struct miwu_callback *)callback;
 	int pin = find_lsb_set(callback->pin_mask) - 1;
 
 	/* pin_mask should not be zero */
@@ -364,7 +376,7 @@ static int gpio_npcx_manage_callback(const struct device *dev,
 			config->port);
 
 	/* Insert or remove a IO callback which being called in MIWU ISRs */
-	return npcx_miwu_manage_gpio_callback(miwu_cb, set);
+	return npcx_miwu_manage_callback(miwu_cb, set);
 }
 
 /* GPIO driver registration */
diff --git a/drivers/i2c/CMakeLists.txt b/drivers/i2c/CMakeLists.txt
index d6910e7c06..c81b150bfc 100644
--- a/drivers/i2c/CMakeLists.txt
+++ b/drivers/i2c/CMakeLists.txt
@@ -31,7 +31,7 @@ zephyr_library_sources_ifdef(CONFIG_I2C_GECKO		i2c_gecko.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_RV32M1_LPI2C	i2c_rv32m1_lpi2c.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_SAM0		i2c_sam0.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_LITEX		i2c_litex.c)
-zephyr_library_sources_ifdef(CONFIG_I2C_NPCX		i2c_npcx_controller.c)
+zephyr_library_sources_ifdef(CONFIG_I2C_NPCX_CTRL	i2c_npcx_controller.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_NPCX		i2c_npcx_port.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_DW		i2c_dw.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_RCAR		i2c_rcar.c)
diff --git a/drivers/i2c/Kconfig.npcx b/drivers/i2c/Kconfig.npcx
index 2422b24c5b..332871f54c 100644
--- a/drivers/i2c/Kconfig.npcx
+++ b/drivers/i2c/Kconfig.npcx
@@ -3,7 +3,7 @@
 # Copyright (c) 2020 Nuvoton Technology Corporation.
 # SPDX-License-Identifier: Apache-2.0
 
-config I2C_NPCX
+menuconfig I2C_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) I2C driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_I2C_PORT_ENABLED
@@ -11,3 +11,30 @@ config I2C_NPCX
 	  This option enables the I2C driver for NPCX family of
 	  processors.
 	  Say y if you wish to use I2C modules on NPCX MCU.
+
+config I2C_NPCX_PORT_INIT_PRIORITY
+	int "NPCX I2C port init priority"
+	default 51
+	depends on I2C_NPCX
+	help
+	  Initialization priority for the I2C port on an NPCX device, must be
+	  set to a lower priority than the controller one (I2C_INIT_PRIORITY).
+
+config I2C_NPCX_CTRL
+	bool "Nuvoton NPCX embedded controller (EC) I2C controller driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_I2C_PORT_ENABLED
+	help
+	  This option enables the I2C controller driver for NPCX family of
+	  processors.
+	  Say y if you wish to use I2C modules on NPCX MCU.
+
+if I2C_NPCX_CTRL
+config I2C_NPCX_DMA_DRIVEN
+	bool "Nuvoton NPCX embedded controller (EC) I2C controller driver with DMA support"
+	default y if SOC_SERIES_NPCK3
+	help
+	  This option enables the I2C controller driver which support DMA for NPCX family of
+	  processors.
+	  Say y if you wish to use I2C modules on NPCX MCU.
+endif #I2C_NPCX_DMA_DRIVEN
\ No newline at end of file
diff --git a/drivers/i2c/i2c_npcx_controller.c b/drivers/i2c/i2c_npcx_controller.c
index 748bb7a92f..07b6987d90 100644
--- a/drivers/i2c/i2c_npcx_controller.c
+++ b/drivers/i2c/i2c_npcx_controller.c
@@ -21,7 +21,7 @@
  *                              +<----------------+<----------------------+
  *                              |       No        |                       | Yes
  *    +------+   +------------+ |  +------- ----+ |    +------- -------+  |
- * +->| IDLE |-->| WAIT_START |--->| WRITE_FIFO |-+--->| WRITE_SUSPEND |--+
+ * +->| IDLE |-->| WAIT_START |--->| WRITE_DATA |-+--->| WRITE_SUSPEND |--+
  * |  +------+   +------------+    +------------+  Yes +---------------+  |
  * |      Issue START    START completed                                  | No
  * |                                            +-----------+             |
@@ -35,7 +35,7 @@
  *                              +<-----------------+<---------------------+
  *                              |       No         |                      | Yes
  *    +------+   +------------+ |  +------- ---+   |    +------- ------+  |
- * +->| IDLE |-->| WAIT_START |--->| READ_FIFO |---+--->| READ_SUSPEND |--+
+ * +->| IDLE |-->| WAIT_START |--->| READ_DATA |---+--->| READ_SUSPEND |--+
  * |  +------+   +------------+    +------------+   Yes +--------------+  |
  * |     Issue START     START completed                                  | No
  * |                                          +-----------+               |
@@ -49,7 +49,7 @@
  *                              +<----------------+<----------------------+
  *                              |       No        |                       | Yes
  *    +------+   +------------+ |  +------- ----+ |    +------- -------+  |
- * +->| IDLE |-->| WAIT_START |--->| WRITE_FIFO |-+--->| WRITE_SUSPEND |--+
+ * +->| IDLE |-->| WAIT_START |--->| WRITE_DATA |-+--->| WRITE_SUSPEND |--+
  * |  +------+   +------------+    +------------+  Yes +---------------+  |
  * |     Issue START     START completed                                  | No
  * |      +---------------------------------------------------------------+
@@ -58,7 +58,7 @@
  * |      |                   +<-----------------+<-----------------------+
  * |      |                   |       No         |                        | Yes
  * |      |  +--------------+ |  +------- ---+   |    +------- ------+    |
- * |      +--| WAIT_RESTART |--->| READ_FIFO |---+--->| READ_SUSPEND |----+
+ * |      +--| WAIT_RESTART |--->| READ_DATA |---+--->| READ_SUSPEND |----+
  * |         +--------------+    +-----------+    Yes +--------------+    |
  * |  Issue RESTART      RESTART completed                                | No
  * |                                           +-----------+              |
@@ -70,9 +70,12 @@
 #include <assert.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/i2c.h>
+#include <zephyr/kernel.h>
+#include <zephyr/sys/atomic.h>
 #include <soc.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(i2c_npcx, LOG_LEVEL_ERR);
 
 /* I2C controller mode */
@@ -88,11 +91,11 @@ LOG_MODULE_REGISTER(i2c_npcx, LOG_LEVEL_ERR);
 /* Default maximum time we allow for an I2C transfer (unit:ms) */
 #define I2C_TRANS_TIMEOUT K_MSEC(100)
 
-/*
- * NPCX I2C module that supports FIFO mode has 32 bytes Tx FIFO and
- * 32 bytes Rx FIFO.
- */
-#define NPCX_I2C_FIFO_MAX_SIZE 32
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+#define NPCX_I2C_DMA_MAX_SIZE 65535 /* Support 65535 bytes during DMA transaction */
+#else
+#define NPCX_I2C_FIFO_MAX_SIZE 32 /* 32 bytes Tx FIFO and 32 bytes Rx FIFO. */
+#endif
 
 /* Valid bit fields in SMBST register */
 #define NPCX_VALID_SMBST_MASK ~(BIT(NPCX_SMBST_XMIT) | BIT(NPCX_SMBST_MASTER))
@@ -109,6 +112,11 @@ enum npcx_i2c_freq {
 	NPCX_I2C_BUS_SPEED_1MHZ,
 };
 
+enum npcx_i2c_flag {
+	NPCX_I2C_FLAG_TARGET,
+	NPCX_I2C_FLAG_COUNT,
+};
+
 /*
  * Internal SMBus Interface driver states values, which reflect events
  * which occurred on the bus
@@ -117,9 +125,9 @@ enum npcx_i2c_oper_state {
 	NPCX_I2C_IDLE,
 	NPCX_I2C_WAIT_START,
 	NPCX_I2C_WAIT_RESTART,
-	NPCX_I2C_WRITE_FIFO,
+	NPCX_I2C_WRITE_DATA,
 	NPCX_I2C_WRITE_SUSPEND,
-	NPCX_I2C_READ_FIFO,
+	NPCX_I2C_READ_DATA,
 	NPCX_I2C_READ_SUSPEND,
 	NPCX_I2C_WAIT_STOP,
 	NPCX_I2C_ERROR_RECOVERY,
@@ -153,15 +161,16 @@ struct i2c_ctrl_data {
 	uint8_t port; /* current port used the controller */
 	bool is_configured; /* is port configured? */
 	const struct npcx_i2c_timing_cfg *ptr_speed_confs;
+#ifdef CONFIG_I2C_TARGET
+	struct i2c_target_config *target_cfg;
+	atomic_t flags;
+#endif
 };
 
 /* Driver convenience defines */
 #define HAL_I2C_INSTANCE(dev)                                                                      \
 	((struct smb_reg *)((const struct i2c_ctrl_config *)(dev)->config)->base)
 
-#define HAL_I2C_FIFO_INSTANCE(dev)                                                                 \
-	((struct smb_fifo_reg *)((const struct i2c_ctrl_config *)(dev)->config)->base)
-
 /* Recommended I2C timing values are based on 15 MHz */
 static const struct npcx_i2c_timing_cfg npcx_15m_speed_confs[] = {
 	[NPCX_I2C_BUS_SPEED_100KHZ] = {.HLDT = 15, .k1 = 76, .k2 = 0},
@@ -175,177 +184,70 @@ static const struct npcx_i2c_timing_cfg npcx_20m_speed_confs[] = {
 	[NPCX_I2C_BUS_SPEED_1MHZ] = {.HLDT  = 7, .k1 = 16, .k2 = 10},
 };
 
+/* Forward declarations */
+void i2c_ctrl_fifo_hold_bus(const struct device *dev, int stall);
+
 /* I2C controller inline functions access shared registers */
 static inline void i2c_ctrl_start(const struct device *dev)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	inst_fifo->SMBCTL1 |= BIT(NPCX_SMBCTL1_START);
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_START);
 }
 
 static inline void i2c_ctrl_stop(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	inst_fifo->SMBCTL1 |= BIT(NPCX_SMBCTL1_STOP);
-}
-
-static inline int i2c_ctrl_bus_busy(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return IS_BIT_SET(inst_fifo->SMBCST, NPCX_SMBCST_BB);
-}
-
-static inline void i2c_ctrl_bank_sel(const struct device *dev, int bank)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	if (bank) {
-		inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_BNK_SEL);
-	} else {
-		inst->SMBCTL3 &= ~BIT(NPCX_SMBCTL3_BNK_SEL);
-	}
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_STOP);
 }
 
-static inline void i2c_ctrl_irq_enable(const struct device *dev, int enable)
-{
-	const struct i2c_ctrl_config *const config = dev->config;
-
-	if (enable) {
-		irq_enable(config->irq);
-	} else {
-		irq_disable(config->irq);
-	}
-}
-
-/* I2C controller inline functions access registers in 'Normal' bank */
-static inline void i2c_ctrl_norm_stall_scl(const struct device *dev)
+static inline int i2c_ctrl_bus_busy(const struct device *dev)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/* Force SCL bus to low and keep SDA floating */
-	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SCL_LVL))
-						| BIT(NPCX_SMBCTL3_SDA_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+	return IS_BIT_SET(inst->SMBCST, NPCX_SMBCST_BB);
 }
 
-static inline void i2c_ctrl_norm_free_scl(const struct device *dev)
+static inline void i2c_ctrl_data_write(const struct device *dev, uint8_t data)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/*
-	 * Release SCL bus. Then it might be still driven by module itself or
-	 * slave device.
-	 */
-	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SCL_LVL) | BIT(NPCX_SMBCTL3_SDA_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+	inst->SMBSDA = data;
 }
 
-/* I2C controller inline functions access registers in 'Normal' bank */
-static inline void i2c_ctrl_norm_stall_sda(const struct device *dev)
+static inline uint8_t i2c_ctrl_data_read(const struct device *dev)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/* Force SDA bus to low and keep SCL floating */
-	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SDA_LVL))
-						| BIT(NPCX_SMBCTL3_SCL_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+	return inst->SMBSDA;
 }
 
-static inline void i2c_ctrl_norm_free_sda(const struct device *dev)
+static inline void i2c_ctrl_bank_sel(const struct device *dev, int bank)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/*
-	 * Release SDA bus. Then it might be still driven by module itself or
-	 * slave device.
-	 */
-	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SDA_LVL) | BIT(NPCX_SMBCTL3_SCL_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
-}
-
-/* I2C controller inline functions access registers in 'FIFO' bank */
-static inline void i2c_ctrl_fifo_write(const struct device *dev, uint8_t data)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	inst_fifo->SMBSDA = data;
-}
-
-static inline uint8_t i2c_ctrl_fifo_read(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return inst_fifo->SMBSDA;
-}
-
-static inline int i2c_ctrl_fifo_tx_avail(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return NPCX_I2C_FIFO_MAX_SIZE - (inst_fifo->SMBTXF_STS & 0x3f);
-}
-
-static inline int i2c_ctrl_fifo_rx_occupied(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return inst_fifo->SMBRXF_STS & 0x3f;
-}
-
-static inline void i2c_ctrl_fifo_rx_setup_threshold_nack(
-		const struct device *dev, int threshold, int last)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-	uint8_t value = MIN(threshold, NPCX_I2C_FIFO_MAX_SIZE);
-
-	SET_FIELD(inst_fifo->SMBRXF_CTL, NPCX_SMBRXF_CTL_RX_THR, value);
-
-	/*
-	 * Is it last received transaction? If so, set LAST bit. Then the
-	 * hardware will generate NACK automatically when receiving last byte.
-	 */
-	if (last && (value == threshold)) {
-		inst_fifo->SMBRXF_CTL |= BIT(NPCX_SMBRXF_CTL_LAST);
+	/* All DMA registers locate at bank 0 */
+	if (IS_ENABLED(CONFIG_I2C_NPCX_DMA_DRIVEN)) {
+		return;
 	}
-}
-
-static inline void i2c_ctrl_fifo_clear_status(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
 
-	inst_fifo->SMBFIF_CTS |= BIT(NPCX_SMBFIF_CTS_CLR_FIFO);
+	if (bank) {
+		inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_BNK_SEL);
+	} else {
+		inst->SMBCTL3 &= ~BIT(NPCX_SMBCTL3_BNK_SEL);
+	}
 }
 
-/*
- * I2C local functions which touch the registers in 'Normal' bank. These
- * utilities will change bank back to FIFO mode when leaving themselves in case
- * the other utilities access the registers in 'FIFO' bank.
- */
-static void i2c_ctrl_hold_bus(const struct device *dev, int stall)
+static inline void i2c_ctrl_irq_enable(const struct device *dev, int enable)
 {
-	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_NORMAL);
+	const struct i2c_ctrl_config *const config = dev->config;
 
-	if (stall) {
-		i2c_ctrl_norm_stall_scl(dev);
+	if (enable) {
+		irq_enable(config->irq);
 	} else {
-		i2c_ctrl_norm_free_scl(dev);
+		irq_disable(config->irq);
 	}
-
-	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_FIFO);
 }
 
 static void i2c_ctrl_init_module(const struct device *dev)
@@ -354,9 +256,10 @@ static void i2c_ctrl_init_module(const struct device *dev)
 
 	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_NORMAL);
 
-	/* Enable FIFO mode first */
-	inst->SMBFIF_CTL |= BIT(NPCX_SMBFIF_CTL_FIFO_EN);
-
+	/* Enable FIFO mode first if selected */
+	if (!IS_ENABLED(CONFIG_I2C_NPCX_DMA_DRIVEN)) {
+		inst->SMBFIF_CTL |= BIT(NPCX_SMBFIF_CTL_FIFO_EN);
+	}
 	/* Enable module - before configuring CTL1 */
 	inst->SMBCTL2  |= BIT(NPCX_SMBCTL2_ENABLE);
 
@@ -405,7 +308,7 @@ static void i2c_ctrl_config_bus_freq(const struct device *dev,
 /* I2C controller local functions */
 static int i2c_ctrl_wait_stop_completed(const struct device *dev, int timeout)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
 	if (timeout <= 0) {
 		return -EINVAL;
@@ -416,7 +319,7 @@ static int i2c_ctrl_wait_stop_completed(const struct device *dev, int timeout)
 		 * Wait till i2c bus is idle. This bit is cleared to 0
 		 * automatically after the STOP condition is generated.
 		 */
-		if (!IS_BIT_SET(inst_fifo->SMBCTL1, NPCX_SMBCTL1_STOP))
+		if (!IS_BIT_SET(inst->SMBCTL1, NPCX_SMBCTL1_STOP))
 			break;
 		k_msleep(1);
 	} while (--timeout);
@@ -463,7 +366,7 @@ static int i2c_ctrl_wait_idle_completed(const struct device *dev, int timeout)
 
 static int i2c_ctrl_recovery(const struct device *dev)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 	struct i2c_ctrl_data *const data = dev->data;
 	int ret;
 
@@ -471,8 +374,10 @@ static int i2c_ctrl_recovery(const struct device *dev)
 		data->oper_state = NPCX_I2C_ERROR_RECOVERY;
 	}
 
-	/* Step 1: Make sure the bus is not stalled before exit. */
-	i2c_ctrl_hold_bus(dev, 0);
+	/* Step 1: Make sure the bus is not stalled before exit in FIFO mode. */
+	if (!IS_ENABLED(CONFIG_I2C_NPCX_DMA_DRIVEN)) {
+		i2c_ctrl_fifo_hold_bus(dev, 0);
+	}
 
 	/*
 	 * Step 2: Abort data, wait for STOP condition completed.
@@ -480,9 +385,9 @@ static int i2c_ctrl_recovery(const struct device *dev)
 	 * - Wait for STOP condition completed
 	 * - Then clear BB (BUS BUSY) bit
 	 */
-	inst_fifo->SMBST = BIT(NPCX_SMBST_BER) | BIT(NPCX_SMBST_NEGACK);
+	inst->SMBST = BIT(NPCX_SMBST_BER) | BIT(NPCX_SMBST_NEGACK);
 	ret = i2c_ctrl_wait_stop_completed(dev, I2C_MAX_TIMEOUT);
-	inst_fifo->SMBCST |= BIT(NPCX_SMBCST_BB);
+	inst->SMBCST |= BIT(NPCX_SMBCST_BB);
 	if (ret != 0) {
 		LOG_ERR("Abort i2c port%02x fail! Bus might be stalled.",
 								data->port);
@@ -494,7 +399,7 @@ static int i2c_ctrl_recovery(const struct device *dev)
 	 * - Wait both SCL/SDA line are high
 	 * - Enable i2c module again
 	 */
-	inst_fifo->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+	inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
 	ret = i2c_ctrl_wait_idle_completed(dev, I2C_MAX_TIMEOUT);
 	if (ret != 0) {
 		LOG_ERR("Reset i2c port%02x fail! Bus might be stalled.",
@@ -537,6 +442,401 @@ size_t i2c_ctrl_calculate_msg_remains(const struct device *dev)
 	return (buf_end > data->ptr_msg) ? (buf_end - data->ptr_msg) : 0;
 }
 
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+/* I2C controller inline functions for 'DMA' mode */
+static inline uint16_t i2c_ctrl_dma_transferred_bytes(const struct device *dev)
+{
+	uint16_t lens;
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* return number of bytes of DMA transmitted or received transactions */
+	lens = (inst->DATA_CNT1 << 8) + inst->DATA_CNT2;
+
+	return lens;
+}
+
+static inline void i2c_ctrl_dma_nack(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	inst->DMA_CTRL |= BIT(NPCX_DMA_CTL_LAST_PEC);
+}
+
+static size_t i2c_ctrl_calc_dma_lens(const struct device *dev)
+{
+	size_t remains = i2c_ctrl_calculate_msg_remains(dev);
+
+	return MIN(remains, NPCX_I2C_DMA_MAX_SIZE);
+}
+
+static bool i2c_ctrl_dma_is_last_pkg(const struct device *dev, size_t remains)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	return data->ptr_msg + remains == data->msg->buf + data->msg->len;
+}
+
+static inline void i2c_ctrl_dma_clear_status(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Clear DMA interrupt bit */
+	inst->DMA_CTRL |= BIT(NPCX_DMA_CTL_INTCLR);
+}
+
+static inline void i2c_ctrl_dma_start(const struct device *dev, uint8_t *addr,
+	uint16_t lens)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+	uint32_t dma_addr = (uint32_t)addr;
+
+	if (lens == 0) {
+		return;
+	}
+
+	/* Configure the address of DMA transmitted or received transactions */
+	inst->DMA_ADDR1 = (uint8_t)(dma_addr & 0xff);
+	inst->DMA_ADDR2 = (uint8_t)((dma_addr >> 8) & 0xff);
+	inst->DMA_ADDR3 = (uint8_t)((dma_addr >> 16) & 0xff);
+	inst->DMA_ADDR4 = (uint8_t)((dma_addr >> 24) & 0xff);
+
+	/* Configure the length of DMA transmitted or received transactions */
+	inst->DATA_LEN1 = (uint8_t)(lens & 0xff);
+	inst->DATA_LEN2 = (uint8_t)((lens >> 8) & 0xff);
+
+	/* Clear DMA status bit and release bus */
+	if (IS_BIT_SET(inst->DMA_CTRL, NPCX_DMA_CTL_IRQSTS)) {
+		i2c_ctrl_dma_clear_status(dev);
+	}
+	/* Start the DMA transaction */
+	inst->DMA_CTRL |= BIT(NPCX_DMA_CTL_ENABLE);
+}
+
+static size_t i2c_ctrl_dma_proceed_write(const struct device *dev)
+{
+	/* Calculate how many remaining bytes need to transmit */
+	size_t dma_lens = i2c_ctrl_calc_dma_lens(dev);
+	struct i2c_ctrl_data *const data = dev->data;
+
+	LOG_DBG("W: dma lens %d, last %d", dma_lens,
+						i2c_ctrl_dma_transferred_bytes(dev));
+
+	/* No DMA transactions */
+	if (dma_lens == 0) {
+		return 0;
+	}
+
+	/* Start DMA transmitted transaction again */
+	i2c_ctrl_dma_start(dev, data->ptr_msg, dma_lens);
+
+	return dma_lens;
+}
+
+static size_t i2c_ctrl_dma_proceed_read(const struct device *dev)
+{
+	/* Calculate how many remaining bytes need to receive */
+	size_t dma_lens = i2c_ctrl_calc_dma_lens(dev);
+	struct i2c_ctrl_data *const data = dev->data;
+
+	LOG_DBG("R: dma lens %d, last %d",
+				dma_lens, i2c_ctrl_dma_transferred_bytes(dev));
+
+	if (dma_lens == 0) {
+		return 0;
+	}
+
+	/* Last byte for NACK in received transaction */
+	if (i2c_ctrl_dma_is_last_pkg(dev, dma_lens) &&
+				(data->msg->flags & I2C_MSG_STOP) != 0) {
+		/* Issue NACK in the end of DMA transation */
+		i2c_ctrl_dma_nack(dev);
+	}
+
+	/* Start DMA if bus is idle */
+	i2c_ctrl_dma_start(dev, data->ptr_msg, dma_lens);
+
+	return dma_lens;
+}
+
+/* I2C controller recover function in `DMA` mode */
+static inline bool i2c_ctrl_toggle_scls(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/*
+	 * Toggle SCL to generate 9 clocks. If the I2C target releases the SDA, we can stop
+	 * toggle the SCL and issue a STOP.
+	 */
+	for (int j = 0; j < 9; j++) {
+		if (IS_BIT_SET(inst->SMBCTL3, NPCX_SMBCTL3_SDA_LVL)) {
+			break;
+		}
+
+		/* Toggle SCL line for one cycle. */
+		inst->SMBCST |= BIT(NPCX_SMBCST_TGSCL);
+		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	}
+	/* Generate a STOP condition */
+	i2c_ctrl_stop(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	if (i2c_ctrl_is_scl_sda_both_high(dev)) {
+		return true;
+	}
+
+	return false;
+}
+
+/* I2C controller `DMA` interrupt functions */
+static void i2c_ctrl_handle_write_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* START condition is issued */
+	if (data->oper_state == NPCX_I2C_WAIT_START) {
+		/* Write slave address with W bit */
+		i2c_ctrl_data_write(dev, ((data->addr << 1)  & ~BIT(0)));
+
+		/* Start first DMA transmitted transaction */
+		i2c_ctrl_dma_proceed_write(dev);
+
+		/* Start to proceed write process */
+		data->oper_state = NPCX_I2C_WRITE_DATA;
+	}
+	/* Skip the other SDAST events */
+}
+
+static void i2c_ctrl_handle_read_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* START or RESTART condition is issued */
+	if (data->oper_state == NPCX_I2C_WAIT_START ||
+			data->oper_state == NPCX_I2C_WAIT_RESTART) {
+		/* Configure first DMA received transaction before sending address */
+		i2c_ctrl_dma_proceed_read(dev);
+
+		/* Write slave address with R bit */
+		i2c_ctrl_data_write(dev, ((data->addr << 1) | BIT(0)));
+
+		/* Start to proceed read process */
+		data->oper_state = NPCX_I2C_READ_DATA;
+	}
+	/* Skip the other SDAST events */
+}
+
+static void i2c_ctrl_handle_write_dma_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* Write message data bytes to FIFO */
+	if (data->oper_state == NPCX_I2C_WRITE_DATA) {
+		/* Record how many bytes transmitted via DMA */
+		data->ptr_msg += i2c_ctrl_dma_transferred_bytes(dev);
+
+		/* If next DMA transmitted transaction proceeds, return immediately */
+		if (i2c_ctrl_dma_proceed_write(dev) != 0) {
+			return;
+		}
+
+		/* No more remaining bytes */
+		if (data->msg->flags & I2C_MSG_STOP) {
+			/* Generate a STOP condition immediately */
+			i2c_ctrl_stop(dev);
+			/* Clear DMA status bit and release bus */
+			i2c_ctrl_dma_clear_status(dev);
+			/* Wait for STOP completed */
+			data->oper_state = NPCX_I2C_WAIT_STOP;
+		} else {
+			/* Disable interrupt and hold bus until handling next message */
+			i2c_ctrl_irq_enable(dev, 0);
+			/* Wait for the other messages */
+			data->oper_state = NPCX_I2C_WRITE_SUSPEND;
+		}
+
+		return i2c_ctrl_notify(dev, 0);
+	}
+}
+
+static void i2c_ctrl_handle_read_dma_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* Read message data bytes from FIFO */
+	if (data->oper_state == NPCX_I2C_READ_DATA) {
+		/* Record how many bytes received via DMA */
+		data->ptr_msg += i2c_ctrl_dma_transferred_bytes(dev);
+
+		/* If next DMA received transaction proceeds, return immediately */
+		if (i2c_ctrl_dma_proceed_read(dev) != 0) {
+			return;
+		}
+
+		/* Is the STOP condition issued? */
+		if ((data->msg->flags & I2C_MSG_STOP) != 0) {
+			/* Generate a STOP condition immediately */
+			i2c_ctrl_stop(dev);
+
+			/* Clear DMA status bit and release bus */
+			i2c_ctrl_dma_clear_status(dev);
+
+			/* Wait for STOP completed */
+			data->oper_state = NPCX_I2C_WAIT_STOP;
+		} else {
+			/* Disable i2c interrupt first */
+			i2c_ctrl_irq_enable(dev, 0);
+			data->oper_state = NPCX_I2C_READ_SUSPEND;
+		}
+
+		return i2c_ctrl_notify(dev, 0);
+	}
+}
+#else
+/* I2C controller inline functions for 'FIFO' mode */
+static inline void i2c_ctrl_fifo_stall_scl(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/* Force SCL bus to low and keep SDA floating */
+	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SCL_LVL))
+						| BIT(NPCX_SMBCTL3_SDA_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+
+static inline void i2c_ctrl_fifo_free_scl(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/*
+	 * Release SCL bus. Then it might be still driven by module itself or
+	 * slave device.
+	 */
+	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SCL_LVL) | BIT(NPCX_SMBCTL3_SDA_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+
+static inline void i2c_ctrl_fifo_stall_sda(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/* Force SDA bus to low and keep SCL floating */
+	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SDA_LVL))
+						| BIT(NPCX_SMBCTL3_SCL_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+
+static inline void i2c_ctrl_norm_free_sda(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/*
+	 * Release SDA bus. Then it might be still driven by module itself or
+	 * slave device.
+	 */
+	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SDA_LVL) | BIT(NPCX_SMBCTL3_SCL_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+/*
+ * I2C local functions which touch the registers in 'Normal' bank. These
+ * utilities will change bank back to FIFO mode when leaving themselves in case
+ * the other utilities access the registers in 'FIFO' bank.
+ */
+void i2c_ctrl_fifo_hold_bus(const struct device *dev, int stall)
+{
+	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_NORMAL);
+
+	if (stall) {
+		i2c_ctrl_fifo_stall_scl(dev);
+	} else {
+		i2c_ctrl_fifo_free_scl(dev);
+	}
+
+	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_FIFO);
+}
+
+static inline int i2c_ctrl_fifo_tx_avail(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	return NPCX_I2C_FIFO_MAX_SIZE - (inst->SMBTXF_STS & 0x3f);
+}
+
+static inline int i2c_ctrl_fifo_rx_occupied(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	return inst->SMBRXF_STS & 0x3f;
+}
+
+static inline void i2c_ctrl_fifo_rx_setup_threshold_nack(
+		const struct device *dev, int threshold, int last)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+	uint8_t value = MIN(threshold, NPCX_I2C_FIFO_MAX_SIZE);
+
+	SET_FIELD(inst->SMBRXF_CTL, NPCX_SMBRXF_CTL_RX_THR, value);
+
+	/*
+	 * Is it last received transaction? If so, set LAST bit. Then the
+	 * hardware will generate NACK automatically when receiving last byte.
+	 */
+	if (last && (value == threshold)) {
+		inst->SMBRXF_CTL |= BIT(NPCX_SMBRXF_CTL_LAST);
+	}
+}
+
+static inline void i2c_ctrl_fifo_clear_status(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	inst->SMBFIF_CTS |= BIT(NPCX_SMBFIF_CTS_CLR_FIFO);
+}
+
+/* I2C controller recover function in `FIFO` mode */
+static inline bool i2c_ctrl_toggle_scls(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Drive the clock high. */
+	i2c_ctrl_fifo_free_scl(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	/*
+	 * Toggle SCL to generate 9 clocks. If the I2C target releases the SDA, we can stop
+	 * toggle the SCL and issue a STOP.
+	 */
+	for (int j = 0; j < 9; j++) {
+		if (IS_BIT_SET(inst->SMBCTL3, NPCX_SMBCTL3_SDA_LVL)) {
+			break;
+		}
+		i2c_ctrl_fifo_stall_scl(dev);
+		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+		i2c_ctrl_fifo_free_scl(dev);
+		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	}
+	/* Drive the SDA line to issue STOP. */
+	i2c_ctrl_fifo_stall_sda(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	i2c_ctrl_norm_free_sda(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	if (i2c_ctrl_is_scl_sda_both_high(dev)) {
+		return true;
+	}
+
+	return false;
+}
+
+/* I2C controller `FIFO` interrupt functions */
 static void i2c_ctrl_handle_write_int_event(const struct device *dev)
 {
 	struct i2c_ctrl_data *const data = dev->data;
@@ -544,21 +844,21 @@ static void i2c_ctrl_handle_write_int_event(const struct device *dev)
 	/* START condition is issued */
 	if (data->oper_state == NPCX_I2C_WAIT_START) {
 		/* Write slave address with W bit */
-		i2c_ctrl_fifo_write(dev, ((data->addr << 1)  & ~BIT(0)));
+		i2c_ctrl_data_write(dev, ((data->addr << 1)  & ~BIT(0)));
 		/* Start to proceed write process */
-		data->oper_state = NPCX_I2C_WRITE_FIFO;
+		data->oper_state = NPCX_I2C_WRITE_DATA;
 		return;
 	}
 
 	/* Write message data bytes to FIFO */
-	if (data->oper_state == NPCX_I2C_WRITE_FIFO) {
+	if (data->oper_state == NPCX_I2C_WRITE_DATA) {
 		/* Calculate how many remaining bytes need to transmit */
 		size_t tx_remain = i2c_ctrl_calculate_msg_remains(dev);
 		size_t tx_avail = MIN(tx_remain, i2c_ctrl_fifo_tx_avail(dev));
 
 		LOG_DBG("tx remains %d, avail %d", tx_remain, tx_avail);
 		for (int i = 0U; i < tx_avail; i++) {
-			i2c_ctrl_fifo_write(dev, *(data->ptr_msg++));
+			i2c_ctrl_data_write(dev, *(data->ptr_msg++));
 		}
 
 		/* Is there any remaining bytes? */
@@ -597,14 +897,14 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 		i2c_ctrl_fifo_rx_setup_threshold_nack(dev, data->msg->len,
 					(data->msg->flags & I2C_MSG_STOP) != 0);
 		/* Write slave address with R bit */
-		i2c_ctrl_fifo_write(dev, ((data->addr << 1) | BIT(0)));
+		i2c_ctrl_data_write(dev, ((data->addr << 1) | BIT(0)));
 		/* Start to proceed read process */
-		data->oper_state = NPCX_I2C_READ_FIFO;
+		data->oper_state = NPCX_I2C_READ_DATA;
 		return;
 	}
 
 	/* Read message data bytes from FIFO */
-	if (data->oper_state == NPCX_I2C_READ_FIFO) {
+	if (data->oper_state == NPCX_I2C_READ_DATA) {
 		/* Calculate how many remaining bytes need to receive */
 		size_t rx_remain = i2c_ctrl_calculate_msg_remains(dev);
 		size_t rx_occupied = i2c_ctrl_fifo_rx_occupied(dev);
@@ -625,12 +925,12 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 			 * immediately after the driver start to read data from
 			 * FIFO. Then we might lose incoming data from device.
 			 */
-			i2c_ctrl_hold_bus(dev, 1);
+			i2c_ctrl_fifo_hold_bus(dev, 1);
 		}
 
 		/* Read data bytes from FIFO */
 		for (int i = 0; i < rx_occupied; i++) {
-			*(data->ptr_msg++) = i2c_ctrl_fifo_read(dev);
+			*(data->ptr_msg++) = i2c_ctrl_data_read(dev);
 		}
 		rx_remain = i2c_ctrl_calculate_msg_remains(dev);
 
@@ -639,7 +939,7 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 			i2c_ctrl_fifo_rx_setup_threshold_nack(dev, rx_remain,
 					(data->msg->flags & I2C_MSG_STOP) != 0);
 			/* Release bus */
-			i2c_ctrl_hold_bus(dev, 0);
+			i2c_ctrl_fifo_hold_bus(dev, 0);
 			return;
 		}
 	}
@@ -659,6 +959,7 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 
 	return i2c_ctrl_notify(dev, 0);
 }
+#endif /* CONFIG_I2C_NPCX_DMA_DRIVEN */
 
 static int i2c_ctrl_proc_write_msg(const struct device *dev,
 							struct i2c_msg *msg)
@@ -671,16 +972,20 @@ static int i2c_ctrl_proc_write_msg(const struct device *dev,
 
 	if (data->oper_state == NPCX_I2C_IDLE) {
 		data->oper_state = NPCX_I2C_WAIT_START;
-
+#if !defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
 		/* Clear FIFO status before starting a new transaction */
 		i2c_ctrl_fifo_clear_status(dev);
-
+#endif
 		/* Issue a START, wait for transaction completed */
 		i2c_ctrl_start(dev);
 
 		return i2c_ctrl_wait_completion(dev);
 	} else if (data->oper_state == NPCX_I2C_WRITE_SUSPEND) {
-		data->oper_state = NPCX_I2C_WRITE_FIFO;
+		data->oper_state = NPCX_I2C_WRITE_DATA;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Start the following DMA transmitted transaction */
+		i2c_ctrl_dma_proceed_write(dev);
+#endif
 		i2c_ctrl_irq_enable(dev, 1);
 
 		return i2c_ctrl_wait_completion(dev);
@@ -702,10 +1007,10 @@ static int i2c_ctrl_proc_read_msg(const struct device *dev, struct i2c_msg *msg)
 
 	if (data->oper_state == NPCX_I2C_IDLE) {
 		data->oper_state = NPCX_I2C_WAIT_START;
-
+#if !defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
 		/* Clear FIFO status before starting a new transaction */
 		i2c_ctrl_fifo_clear_status(dev);
-
+#endif
 		/* Issue a START, wait for transaction completed */
 		i2c_ctrl_start(dev);
 
@@ -714,19 +1019,26 @@ static int i2c_ctrl_proc_read_msg(const struct device *dev, struct i2c_msg *msg)
 		data->oper_state = NPCX_I2C_WAIT_RESTART;
 		/* Issue a RESTART, wait for transaction completed */
 		i2c_ctrl_start(dev);
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Clear DMA status bit and release bus */
+		i2c_ctrl_dma_clear_status(dev);
+#endif
 		i2c_ctrl_irq_enable(dev, 1);
 
 		return i2c_ctrl_wait_completion(dev);
 	} else if (data->oper_state == NPCX_I2C_READ_SUSPEND) {
-		data->oper_state = NPCX_I2C_READ_FIFO;
-
+		data->oper_state = NPCX_I2C_READ_DATA;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Start DMA received transaction */
+		i2c_ctrl_dma_proceed_read(dev);
+#else
 		/* Setup threshold of RX FIFO first */
 		i2c_ctrl_fifo_rx_setup_threshold_nack(dev, msg->len,
 				(msg->flags & I2C_MSG_STOP) != 0);
 
 		/* Release bus */
-		i2c_ctrl_hold_bus(dev, 0);
-
+		i2c_ctrl_fifo_hold_bus(dev, 0);
+#endif
 		/* Enable i2c interrupt first */
 		i2c_ctrl_irq_enable(dev, 1);
 		return i2c_ctrl_wait_completion(dev);
@@ -738,26 +1050,141 @@ static int i2c_ctrl_proc_read_msg(const struct device *dev, struct i2c_msg *msg)
 	return data->trans_err;
 }
 
+/* I2C controller isr function */
+#ifdef CONFIG_I2C_TARGET
+static void i2c_ctrl_target_isr(const struct device *dev, uint8_t status)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+	struct i2c_ctrl_data *const data = dev->data;
+	const struct i2c_target_callbacks *target_cb = data->target_cfg->callbacks;
+	uint8_t val = 0;
+
+	/* A 'Bus Error' has been identified */
+	if (IS_BIT_SET(status, NPCX_SMBST_BER)) {
+		/* Clear BER Bit */
+		inst->SMBST = BIT(NPCX_SMBST_BER);
+
+		/* Notify upper layer the end of transaction */
+		if (target_cb->stop) {
+			target_cb->stop(data->target_cfg);
+		}
+
+		/* Reset i2c module in target mode */
+		inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+		inst->SMBCTL2 |= BIT(NPCX_SMBCTL2_ENABLE);
+
+		/* End of transaction */
+		data->oper_state = NPCX_I2C_IDLE;
+		return;
+	}
+
+	/* A 'Slave Stop' Condition has been identified */
+	if (IS_BIT_SET(status, NPCX_SMBST_SLVSTP)) {
+		/* Clear SLVSTP Bit */
+		inst->SMBST = BIT(NPCX_SMBST_SLVSTP);
+		/* End of transaction */
+		data->oper_state = NPCX_I2C_IDLE;
+		/* Notify upper layer a STOP condition received */
+		if (target_cb->stop) {
+			target_cb->stop(data->target_cfg);
+		}
+		return;
+	}
+
+	/* A negative acknowledge has occurred */
+	if (IS_BIT_SET(status, NPCX_SMBST_NEGACK)) {
+		/* Clear NEGACK Bit */
+		inst->SMBST = BIT(NPCX_SMBST_NEGACK);
+		/* Do nothing in i2c target mode */
+		return;
+	}
+
+	/* A 'Target Address Match' has been identified */
+	if (IS_BIT_SET(status, NPCX_SMBST_NMATCH)) {
+		/* Clear NMATCH Bit */
+		inst->SMBST = BIT(NPCX_SMBST_NMATCH);
+
+		/* Distinguish tje direction of i2c target mode by reading XMIT bit */
+		if (IS_BIT_SET(inst->SMBST, NPCX_SMBST_XMIT)) {
+			/* Start transmitting data in i2c target mode */
+			data->oper_state = NPCX_I2C_WRITE_DATA;
+			/* Write first requested byte after repeated start */
+			if (target_cb->read_requested) {
+				target_cb->read_requested(data->target_cfg, &val);
+			}
+			inst->SMBSDA = val;
+		} else {
+			/* Start receiving data in i2c target mode */
+			data->oper_state = NPCX_I2C_READ_DATA;
+			if (target_cb->write_requested) {
+				target_cb->write_requested(data->target_cfg);
+			}
+		}
+		return;
+	}
+
+	/* Tx byte empty or Rx byte full has occurred */
+	if (IS_BIT_SET(status, NPCX_SMBST_SDAST)) {
+		if (data->oper_state == NPCX_I2C_WRITE_DATA) {
+			/* Notify upper layer one byte will be transmitted */
+			if (target_cb->read_processed) {
+				target_cb->read_processed(data->target_cfg, &val);
+			}
+			inst->SMBSDA = val;
+		} else if (data->oper_state == NPCX_I2C_READ_DATA) {
+			if (target_cb->write_received) {
+				val = inst->SMBSDA;
+				/* Notify upper layer one byte received */
+				target_cb->write_received(data->target_cfg, val);
+			}
+		} else {
+			LOG_ERR("Unexpected oper state %d on i2c target port%02x!",
+				data->oper_state, data->port);
+		}
+		return;
+	}
+
+	/* Clear unexpected status bits */
+	if (status != 0) {
+		inst->SMBST = status;
+		LOG_ERR("Unexpected  SMBST 0x%02x occurred on i2c target port%02x!",
+			status, data->port);
+	}
+}
+#endif
+
 /* I2C controller isr function */
 static void i2c_ctrl_isr(const struct device *dev)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 	struct i2c_ctrl_data *const data = dev->data;
-	uint8_t status, tmp;
+	uint8_t status = inst->SMBST & NPCX_VALID_SMBST_MASK;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+	uint8_t	dma_status = inst->DMA_CTRL;
 
-	status = inst_fifo->SMBST & NPCX_VALID_SMBST_MASK;
+	LOG_DBG("ISR status: %02x dma_ctrl: %02x, %d", status, dma_status, data->oper_state);
+#else
 	LOG_DBG("status: %02x, %d", status, data->oper_state);
+#endif
+
+#ifdef CONFIG_I2C_TARGET
+	if (atomic_test_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return i2c_ctrl_target_isr(dev, status);
+	}
+#endif
 
 	/* A 'Bus Error' has been identified */
 	if (IS_BIT_SET(status, NPCX_SMBST_BER)) {
+		uint8_t tmp;
+
 		/* Generate a STOP condition immediately */
 		i2c_ctrl_stop(dev);
 
 		/* Clear BER Bit */
-		inst_fifo->SMBST = BIT(NPCX_SMBST_BER);
+		inst->SMBST = BIT(NPCX_SMBST_BER);
 
 		/* Make sure slave doesn't hold bus by reading FIFO again */
-		tmp = i2c_ctrl_fifo_read(dev);
+		tmp = i2c_ctrl_data_read(dev);
 
 		LOG_ERR("Bus error occurred on i2c port%02x!", data->port);
 		data->oper_state = NPCX_I2C_ERROR_RECOVERY;
@@ -773,7 +1200,12 @@ static void i2c_ctrl_isr(const struct device *dev)
 		i2c_ctrl_stop(dev);
 
 		/* Clear NEGACK Bit */
-		inst_fifo->SMBST = BIT(NPCX_SMBST_NEGACK);
+		inst->SMBST = BIT(NPCX_SMBST_NEGACK);
+
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Clear DMA status bit to release bus */
+		i2c_ctrl_dma_clear_status(dev);
+#endif
 
 		/* End transaction */
 		data->oper_state = NPCX_I2C_WAIT_STOP;
@@ -791,9 +1223,20 @@ static void i2c_ctrl_isr(const struct device *dev)
 		}
 	}
 
+	/* DMA transaction has been finished */
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+	if (IS_BIT_SET(dma_status, NPCX_DMA_CTL_IRQSTS)) {
+		if (data->is_write) {
+			return i2c_ctrl_handle_write_dma_int_event(dev);
+		} else {
+			return i2c_ctrl_handle_read_dma_int_event(dev);
+		}
+	}
+#endif
+
 	/* Clear unexpected status bits */
 	if (status != 0) {
-		inst_fifo->SMBST = status;
+		inst->SMBST = status;
 		LOG_ERR("Unexpected  SMBST 0x%02x occurred on i2c port%02x!",
 			status, data->port);
 	}
@@ -892,32 +1335,7 @@ int npcx_i2c_ctrl_recover_bus(const struct device *dev)
 	}
 
 	for (int i = 0; i < I2C_RECOVER_SDA_RETRY; i++) {
-		/* Drive the clock high. */
-		i2c_ctrl_norm_free_scl(dev);
-		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-
-		/*
-		 * Toggle SCL to generate 9 clocks. If the I2C target releases the SDA, we can stop
-		 * toggle the SCL and issue a STOP.
-		 */
-		for (int j = 0; j < 9; j++) {
-			if (IS_BIT_SET(inst->SMBCTL3, NPCX_SMBCTL3_SDA_LVL)) {
-				break;
-			}
-
-			i2c_ctrl_norm_stall_scl(dev);
-			k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-			i2c_ctrl_norm_free_scl(dev);
-			k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-		}
-
-		/* Drive the SDA line to issue STOP. */
-		i2c_ctrl_norm_stall_sda(dev);
-		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-		i2c_ctrl_norm_free_sda(dev);
-		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-
-		if (i2c_ctrl_is_scl_sda_both_high(dev)) {
+		if (i2c_ctrl_toggle_scls(dev)) {
 			ret = 0;
 			goto recover_exit;
 		}
@@ -938,6 +1356,86 @@ recover_exit:
 	return ret;
 }
 
+#ifdef CONFIG_I2C_TARGET
+int npcx_i2c_ctrl_target_register(const struct device *i2c_dev,
+				 struct i2c_target_config *target_cfg, uint8_t port)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(i2c_dev);
+	struct i2c_ctrl_data *const data = i2c_dev->data;
+	int idx_ctrl = (port & 0xF0) >> 4;
+	int idx_port = (port & 0x0F);
+	uint8_t addr = BIT(NPCX_SMBADDR1_SAEN) | target_cfg->address;
+
+	/* I2c module has been configured to target mode */
+	if (atomic_test_and_set_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return -EBUSY;
+	}
+
+	/* A transiaction is ongoing */
+	if (data->oper_state != NPCX_I2C_IDLE) {
+		atomic_clear_bit(&data->flags, NPCX_I2C_FLAG_TARGET);
+		return -EBUSY;
+	}
+
+	data->target_cfg = target_cfg;
+
+	i2c_ctrl_irq_enable(i2c_dev, 0);
+	/* Switch correct port for i2c controller first */
+	npcx_pinctrl_i2c_port_sel(idx_ctrl, idx_port);
+	/* Reset I2C module */
+	inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+	inst->SMBCTL2 |= BIT(NPCX_SMBCTL2_ENABLE);
+
+	/* Select normal bank and single byte mode for i2c target mode */
+	i2c_ctrl_bank_sel(i2c_dev, NPCX_I2C_BANK_NORMAL);
+	inst->SMBFIF_CTL &= ~BIT(NPCX_SMBFIF_CTL_FIFO_EN);
+	inst->SMBADDR1 = addr; /* Enable target mode and configure its address */
+
+	/* Reconfigure SMBCTL1 */
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_NMINTE) | BIT(NPCX_SMBCTL1_INTEN);
+	i2c_ctrl_irq_enable(i2c_dev, 1);
+
+	return 0;
+}
+
+int npcx_i2c_ctrl_target_unregister(const struct device *i2c_dev,
+				   struct i2c_target_config *target_cfg)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(i2c_dev);
+	struct i2c_ctrl_data *const data = i2c_dev->data;
+
+	/* No I2c module has been configured to target mode */
+	if (!atomic_test_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return -EINVAL;
+	}
+
+	/* A transiaction is ongoing */
+	if (data->oper_state != NPCX_I2C_IDLE) {
+		return -EBUSY;
+	}
+	data->target_cfg = NULL;
+
+	i2c_ctrl_irq_enable(i2c_dev, 0);
+	/* Reset I2C module */
+	inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+	inst->SMBCTL2 |= BIT(NPCX_SMBCTL2_ENABLE);
+
+	inst->SMBADDR1 = 0; /* Disable target mode and clear address setting */
+	/* Enable FIFO mode and select to FIFO bank for i2c controller mode */
+	inst->SMBFIF_CTL |= BIT(NPCX_SMBFIF_CTL_FIFO_EN);
+	i2c_ctrl_bank_sel(i2c_dev, NPCX_I2C_BANK_FIFO);
+
+	/* Reconfigure SMBCTL1 */
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_NMINTE) | BIT(NPCX_SMBCTL1_INTEN);
+	i2c_ctrl_irq_enable(i2c_dev, 1);
+
+	/* Mark it as controller mode */
+	atomic_clear_bit(&data->flags, NPCX_I2C_FLAG_TARGET);
+
+	return 0;
+}
+#endif
+
 int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
 			      uint8_t num_msgs, uint16_t addr, int port)
 {
@@ -945,6 +1443,13 @@ int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
 	int ret = 0;
 	uint8_t i;
 
+#ifdef CONFIG_I2C_TARGET
+	/* I2c module has been configured to target mode */
+	if (atomic_test_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return -EBUSY;
+	}
+#endif
+
 	/*
 	 * suspend-to-idle stops SMB module clocks (derived from APB2/APB3), which must remain
 	 * active during a transaction
@@ -1009,7 +1514,7 @@ int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
 		}
 	}
 
-	if (data->oper_state == NPCX_I2C_ERROR_RECOVERY) {
+	if (data->oper_state == NPCX_I2C_ERROR_RECOVERY || ret == -ETIMEDOUT) {
 		int recovery_error = i2c_ctrl_recovery(i2c_dev);
 		/*
 		 * Recovery failed, return it immediately. Otherwise, the upper
@@ -1040,7 +1545,7 @@ static int i2c_ctrl_init(const struct device *dev)
 
 	/* Turn on device clock first and get source clock freq. */
 	if (clock_control_on(clk_dev,
-		(clock_control_subsys_t *) &config->clk_cfg) != 0) {
+		(clock_control_subsys_t) &config->clk_cfg) != 0) {
 		LOG_ERR("Turn on %s clock fail.", dev->name);
 		return -EIO;
 	}
@@ -1050,7 +1555,7 @@ static int i2c_ctrl_init(const struct device *dev)
 	 * configuration of the device to meet SMBus timing spec. Please refer
 	 * Table 21/22/23 and section 7.5.9 SMBus Timing for more detail.
 	 */
-	if (clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	if (clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&config->clk_cfg, &i2c_rate) != 0) {
 		LOG_ERR("Get %s clock rate error.", dev->name);
 		return -EIO;
@@ -1110,7 +1615,7 @@ static int i2c_ctrl_init(const struct device *dev)
 									       \
 	static struct i2c_ctrl_data i2c_ctrl_data_##inst;                      \
 									       \
-	I2C_DEVICE_DT_INST_DEFINE(inst,                                        \
+	DEVICE_DT_INST_DEFINE(inst,                                            \
 			    NPCX_I2C_CTRL_INIT_FUNC(inst),                     \
 			    NULL,                                              \
 			    &i2c_ctrl_data_##inst, &i2c_ctrl_cfg_##inst,       \
diff --git a/drivers/i2c/i2c_npcx_controller.h b/drivers/i2c/i2c_npcx_controller.h
index d119b38fac..0833824404 100644
--- a/drivers/i2c/i2c_npcx_controller.h
+++ b/drivers/i2c/i2c_npcx_controller.h
@@ -80,6 +80,32 @@ int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
  */
 int npcx_i2c_ctrl_recover_bus(const struct device *dev);
 
+/**
+ * @brief Registers the provided config as Target device of a npcx i2c controller.
+ *
+ * @param i2c_dev Pointer to the device structure for i2c controller instance.
+ * @param target_cfg Config struct used by the i2c target driver
+ * @param port Port index of selected i2c port.
+ *
+ * @retval 0 Is successful
+ * @retval -EBUSY If i2c transaction is proceeding.
+ */
+int npcx_i2c_ctrl_target_register(const struct device *i2c_dev,
+				 struct i2c_target_config *target_cfg, uint8_t port);
+
+/**
+ * @brief Unregisters the provided config as Target device of a npcx i2c controller.
+ *
+ * @param i2c_dev Pointer to the device structure for i2c controller instance.
+ * @param target_cfg Config struct used by the i2c target driver
+ *
+ * @retval 0 Is successful
+ * @retval -EBUSY If i2c transaction is proceeding.
+ * @retval -EINVAL If parameters are invalid
+ */
+int npcx_i2c_ctrl_target_unregister(const struct device *i2c_dev,
+				   struct i2c_target_config *target_cfg);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/i2c/i2c_npcx_port.c b/drivers/i2c/i2c_npcx_port.c
index d1ea375147..b43383c18d 100644
--- a/drivers/i2c/i2c_npcx_port.c
+++ b/drivers/i2c/i2c_npcx_port.c
@@ -143,6 +143,38 @@ static int i2c_npcx_port_recover_bus(const struct device *dev)
 	return ret;
 }
 
+#ifdef CONFIG_I2C_TARGET
+static int i2c_npcx_target_register(const struct device *dev,
+				  struct i2c_target_config *target_cfg)
+{
+	const struct i2c_npcx_port_config *const config = dev->config;
+
+	if (!target_cfg) {
+		return -EINVAL;
+	}
+
+	if (config->i2c_ctrl == NULL) {
+		LOG_ERR("Cannot find i2c controller on port%02x!", config->port);
+		return -EIO;
+	}
+
+	return npcx_i2c_ctrl_target_register(config->i2c_ctrl, target_cfg, config->port);
+}
+
+static int i2c_npcx_target_unregister(const struct device *dev,
+				     struct i2c_target_config *target_cfg)
+{
+	const struct i2c_npcx_port_config *const config = dev->config;
+
+	if (config->i2c_ctrl == NULL) {
+		LOG_ERR("Cannot find i2c controller on port%02x!", config->port);
+		return -EIO;
+	}
+
+	return npcx_i2c_ctrl_target_unregister(config->i2c_ctrl, target_cfg);
+}
+#endif
+
 /* I2C driver registration */
 static int i2c_npcx_port_init(const struct device *dev)
 {
@@ -173,6 +205,10 @@ static const struct i2c_driver_api i2c_port_npcx_driver_api = {
 	.get_config = i2c_npcx_port_get_config,
 	.transfer = i2c_npcx_port_transfer,
 	.recover_bus = i2c_npcx_port_recover_bus,
+#ifdef CONFIG_I2C_TARGET
+	.target_register = i2c_npcx_target_register,
+	.target_unregister = i2c_npcx_target_unregister,
+#endif
 };
 
 /* I2C port init macro functions */
@@ -190,7 +226,7 @@ static const struct i2c_driver_api i2c_port_npcx_driver_api = {
 			    i2c_npcx_port_init,                                \
 			    NULL, NULL,                                        \
 			    &i2c_npcx_port_cfg_##inst,                         \
-			    PRE_KERNEL_1, CONFIG_I2C_INIT_PRIORITY,            \
+			    PRE_KERNEL_1, CONFIG_I2C_NPCX_PORT_INIT_PRIORITY,  \
 			    &i2c_port_npcx_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(NPCX_I2C_PORT_INIT)
diff --git a/drivers/interrupt_controller/Kconfig b/drivers/interrupt_controller/Kconfig
index 93d6332294..a5ae5eb565 100644
--- a/drivers/interrupt_controller/Kconfig
+++ b/drivers/interrupt_controller/Kconfig
@@ -43,6 +43,19 @@ config INTC_INIT_PRIORITY
 	help
 	  Interrupt controller device initialization priority.
 
+if MCHP_ECIA_XEC
+
+config XEC_GIRQ_INIT_PRIORITY
+	int "XEX GIRQ Interrupt controller init priority"
+	default 41
+	help
+	  XEC GIRQ Interrupt controller device initialization priority.
+	  The priority value needs to be greater than INTC_INIT_PRIORITY
+	  So that the XEC GIRQ controllers are initialized after the
+	  xec_ecia.
+
+endif
+
 module = INTC
 module-str = intc
 source "subsys/logging/Kconfig.template.log_config"
diff --git a/drivers/interrupt_controller/intc_mchp_ecia_xec.c b/drivers/interrupt_controller/intc_mchp_ecia_xec.c
index 5a3a05953d..789c635b6a 100644
--- a/drivers/interrupt_controller/intc_mchp_ecia_xec.c
+++ b/drivers/interrupt_controller/intc_mchp_ecia_xec.c
@@ -572,7 +572,7 @@ static int xec_ecia_init(const struct device *dev)
 									\
 	DEVICE_DT_DEFINE(n, xec_girq_init_##n,				\
 		 NULL, &xec_data_girq_##n, &xec_config_girq_##n,	\
-		 PRE_KERNEL_1, CONFIG_INTC_INIT_PRIORITY,		\
+		 PRE_KERNEL_1, CONFIG_XEC_GIRQ_INIT_PRIORITY,		\
 		 NULL);							\
 									\
 	static int xec_girq_init_##n(const struct device *dev)		\
diff --git a/drivers/interrupt_controller/intc_miwu.c b/drivers/interrupt_controller/intc_miwu.c
index 509f90386e..81c5c515b1 100644
--- a/drivers/interrupt_controller/intc_miwu.c
+++ b/drivers/interrupt_controller/intc_miwu.c
@@ -57,6 +57,7 @@
 #include "soc_gpio.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(intc_miwu, LOG_LEVEL_ERR);
 
 /* MIWU module instances */
@@ -77,68 +78,53 @@ struct intc_miwu_config {
 	uint8_t index;
 };
 
-/* Callback functions list for GPIO wake-up inputs */
-sys_slist_t cb_list_gpio;
-
-/*
- * Callback functions list for the generic hardware modules  wake-up inputs
- * such as timer, uart, i2c, host interface and so on.
- */
-sys_slist_t cb_list_generic;
-
-BUILD_ASSERT(sizeof(struct miwu_io_callback) == sizeof(struct gpio_callback),
-	"Size of struct miwu_io_callback must equal to struct gpio_callback");
+/* Driver data */
+struct intc_miwu_data {
+	/* Callback functions list for each MIWU group */
+	sys_slist_t cb_list_grp[8];
+};
 
 BUILD_ASSERT(sizeof(struct miwu_io_params) == sizeof(gpio_port_pins_t),
 	"Size of struct miwu_io_params must equal to struct gpio_port_pins_t");
 
+BUILD_ASSERT(offsetof(struct miwu_callback, io_cb.params) +
+	sizeof(struct miwu_io_params) == sizeof(struct gpio_callback),
+	"Failed in size check of miwu_callback and gpio_callback structures!");
+
+BUILD_ASSERT(offsetof(struct miwu_callback, io_cb.params.cb_type) ==
+	offsetof(struct miwu_callback, dev_cb.params.cb_type),
+	"Failed in offset check of cb_type field of miwu_callback structure");
+
 /* MIWU local functions */
-static void intc_miwu_dispatch_gpio_isr(uint8_t wui_table,
-					uint8_t wui_group, uint8_t wui_bit)
+static void intc_miwu_dispatch_isr(sys_slist_t *cb_list, uint8_t mask)
 {
-	struct miwu_io_callback *cb, *tmp;
-
-	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&cb_list_gpio, cb, tmp, node) {
-		/* Pending bit, group and table match the wui item in list */
-		if (cb->params.wui.table == wui_table
-			&& cb->params.wui.group == wui_group
-			&& cb->params.wui.bit == wui_bit) {
-			__ASSERT(cb->handler, "No GPIO callback handler!");
-			/*
-			 * Execute GPIO callback and the other callback might
-			 * match the same wui item.
-			 */
-			cb->handler(npcx_get_gpio_dev(cb->params.gpio_port),
+	struct miwu_callback *cb, *tmp;
+
+	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(cb_list, cb, tmp, node) {
+
+		if (cb->io_cb.params.cb_type == NPCX_MIWU_CALLBACK_GPIO) {
+			if (BIT(cb->io_cb.params.wui.bit) & mask) {
+				__ASSERT(cb->io_cb.handler, "No GPIO callback handler!");
+				cb->io_cb.handler(
+					npcx_get_gpio_dev(cb->io_cb.params.gpio_port),
 					(struct gpio_callback *)cb,
-					cb->params.pin_mask);
-		}
-	}
-}
+					cb->io_cb.params.pin_mask);
+			}
+		} else {
+			if (BIT(cb->dev_cb.params.wui.bit) & mask) {
+				__ASSERT(cb->dev_cb.handler, "No device callback handler!");
 
-static void intc_miwu_dispatch_generic_isr(uint8_t wui_table,
-					uint8_t wui_group, uint8_t wui_bit)
-{
-	struct miwu_dev_callback *cb, *tmp;
-
-	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&cb_list_generic, cb, tmp, node) {
-		/* Pending bit, group and table match the wui item in list */
-		if (cb->wui.table == wui_table
-				&& cb->wui.group == wui_group
-				&& cb->wui.bit == wui_bit) {
-			__ASSERT(cb->handler, "No Generic callback handler!");
-			/*
-			 * Execute generic callback and the other callback might
-			 * match the same wui item.
-			 */
-			cb->handler(cb->source, &cb->wui);
+				cb->dev_cb.handler(cb->dev_cb.params.source,
+						   &cb->dev_cb.params.wui);
+			}
 		}
 	}
 }
 
 static void intc_miwu_isr_pri(int wui_table, int wui_group)
 {
-	int wui_bit;
 	const struct intc_miwu_config *config = miwu_devs[wui_table]->config;
+	struct intc_miwu_data *data = miwu_devs[wui_table]->data;
 	const uint32_t base = config->base;
 	uint8_t mask = NPCX_WKPND(base, wui_group) & NPCX_WKEN(base, wui_group);
 
@@ -147,17 +133,8 @@ static void intc_miwu_isr_pri(int wui_table, int wui_group)
 		NPCX_WKPCL(base, wui_group) = mask;
 	}
 
-	for (wui_bit = 0; wui_bit < 8; wui_bit++) {
-		if (mask & BIT(wui_bit)) {
-			LOG_DBG("miwu_isr %d %d %d!\n", wui_table,
-							wui_group, wui_bit);
-			/* Dispatch registered gpio and generic isrs */
-			intc_miwu_dispatch_gpio_isr(wui_table,
-							wui_group, wui_bit);
-			intc_miwu_dispatch_generic_isr(wui_table,
-							wui_group, wui_bit);
-		}
-	}
+	/* Dispatch registered gpio isrs */
+	intc_miwu_dispatch_isr(&data->cb_list_grp[wui_group], mask);
 }
 
 /* Platform specific MIWU functions */
@@ -277,50 +254,47 @@ int npcx_miwu_interrupt_configure(const struct npcx_wui *wui,
 	return 0;
 }
 
-void npcx_miwu_init_gpio_callback(struct miwu_io_callback *callback,
+void npcx_miwu_init_gpio_callback(struct miwu_callback *callback,
 				const struct npcx_wui *io_wui, int port)
 {
 	/* Initialize WUI and GPIO settings in unused bits field */
-	callback->params.wui.table = io_wui->table;
-	callback->params.wui.group = io_wui->group;
-	callback->params.wui.bit   = io_wui->bit;
-	callback->params.gpio_port = port;
+	callback->io_cb.params.wui.table = io_wui->table;
+	callback->io_cb.params.wui.bit   = io_wui->bit;
+	callback->io_cb.params.gpio_port = port;
+	callback->io_cb.params.cb_type = NPCX_MIWU_CALLBACK_GPIO;
+	callback->io_cb.params.wui.group = io_wui->group;
 }
 
-void npcx_miwu_init_dev_callback(struct miwu_dev_callback *callback,
+void npcx_miwu_init_dev_callback(struct miwu_callback *callback,
 				const struct npcx_wui *dev_wui,
 				miwu_dev_callback_handler_t handler,
 				const struct device *source)
 {
 	/* Initialize WUI and input device settings */
-	callback->wui.table = dev_wui->table;
-	callback->wui.group = dev_wui->group;
-	callback->wui.bit   = dev_wui->bit;
-	callback->handler = handler;
-	callback->source = source;
+	callback->dev_cb.params.wui.table = dev_wui->table;
+	callback->dev_cb.params.wui.group = dev_wui->group;
+	callback->dev_cb.params.wui.bit   = dev_wui->bit;
+	callback->dev_cb.params.source = source;
+	callback->dev_cb.params.cb_type = NPCX_MIWU_CALLBACK_DEV;
+	callback->dev_cb.handler = handler;
 }
 
-int npcx_miwu_manage_gpio_callback(struct miwu_io_callback *cb, bool set)
+int npcx_miwu_manage_callback(struct miwu_callback *cb, bool set)
 {
-	if (!sys_slist_is_empty(&cb_list_gpio)) {
-		if (!sys_slist_find_and_remove(&cb_list_gpio, &cb->node)) {
-			if (!set) {
-				return -EINVAL;
-			}
-		}
-	}
+	struct npcx_wui *wui;
+	struct intc_miwu_data *data;
+	sys_slist_t *cb_list;
 
-	if (set) {
-		sys_slist_prepend(&cb_list_gpio, &cb->node);
+	if (cb->io_cb.params.cb_type == NPCX_MIWU_CALLBACK_GPIO) {
+		wui = &cb->io_cb.params.wui;
+	} else {
+		wui = &cb->dev_cb.params.wui;
 	}
 
-	return 0;
-}
-
-int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set)
-{
-	if (!sys_slist_is_empty(&cb_list_generic)) {
-		if (!sys_slist_find_and_remove(&cb_list_generic, &cb->node)) {
+	data = miwu_devs[wui->table]->data;
+	cb_list = &data->cb_list_grp[wui->group];
+	if (!sys_slist_is_empty(cb_list)) {
+		if (!sys_slist_find_and_remove(cb_list, &cb->node)) {
 			if (!set) {
 				return -EINVAL;
 			}
@@ -328,7 +302,7 @@ int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set)
 	}
 
 	if (set) {
-		sys_slist_prepend(&cb_list_generic, &cb->node);
+		sys_slist_prepend(cb_list, &cb->node);
 	}
 
 	return 0;
@@ -384,11 +358,12 @@ int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set)
 		.base = DT_REG_ADDR(DT_NODELABEL(miwu##inst)),                 \
 		.index = DT_PROP(DT_NODELABEL(miwu##inst), index),             \
 	};                                                                     \
+	struct intc_miwu_data miwu_data_##inst;				       \
 									       \
 	DEVICE_DT_INST_DEFINE(inst,					       \
 			    NPCX_MIWU_INIT_FUNC(inst),                         \
 			    NULL,					       \
-			    NULL, &miwu_config_##inst,                         \
+			    &miwu_data_##inst, &miwu_config_##inst,            \
 			    PRE_KERNEL_1,                                      \
 			    CONFIG_INTC_INIT_PRIORITY, NULL);                  \
 									       \
diff --git a/drivers/led/CMakeLists.txt b/drivers/led/CMakeLists.txt
index b3d5147ef6..ba1dd973fa 100644
--- a/drivers/led/CMakeLists.txt
+++ b/drivers/led/CMakeLists.txt
@@ -5,6 +5,7 @@ zephyr_library()
 zephyr_library_sources_ifdef(CONFIG_HT16K33 ht16k33.c)
 zephyr_library_sources_ifdef(CONFIG_LED_GPIO led_gpio.c)
 zephyr_library_sources_ifdef(CONFIG_LED_PWM led_pwm.c)
+zephyr_library_sources_ifdef(CONFIG_LED_XEC led_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_LP3943 lp3943.c)
 zephyr_library_sources_ifdef(CONFIG_LP503X lp503x.c)
 zephyr_library_sources_ifdef(CONFIG_LP5562 lp5562.c)
diff --git a/drivers/led/Kconfig b/drivers/led/Kconfig
index 7c62be06ba..a93e4dc83c 100644
--- a/drivers/led/Kconfig
+++ b/drivers/led/Kconfig
@@ -34,5 +34,6 @@ source "drivers/led/Kconfig.lp5562"
 source "drivers/led/Kconfig.pca9633"
 source "drivers/led/Kconfig.pwm"
 source "drivers/led/Kconfig.tlc59108"
+source "drivers/led/Kconfig.xec"
 
 endif # LED
diff --git a/drivers/led/Kconfig.xec b/drivers/led/Kconfig.xec
new file mode 100644
index 0000000000..e0651567ca
--- /dev/null
+++ b/drivers/led/Kconfig.xec
@@ -0,0 +1,11 @@
+# Copyright (c) 2022 Microchip Technology Inc.
+# SPDX-License-Identifier: Apache-2.0
+
+config LED_XEC
+	bool "Microchip XEC BB-LED driver"
+	default y
+        # Backport note: Drop this and use device tree when intercepting 3.2
+	depends on LED
+	help
+	  Enable driver for the Microchip XEC Breathing-Blinking
+	  LED controller
diff --git a/drivers/led/led_mchp_xec.c b/drivers/led/led_mchp_xec.c
new file mode 100644
index 0000000000..1dfc405e0a
--- /dev/null
+++ b/drivers/led/led_mchp_xec.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2022 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT microchip_xec_bbled
+
+/**
+ * @file
+ * @brief Microchip Breathing-Blinking LED controller
+ */
+
+#include <soc.h>
+#ifndef CONFIG_SOC_SERIES_MEC1501X
+#include <zephyr/drivers/clock_control/mchp_xec_clock_control.h>
+#include <zephyr/drivers/interrupt_controller/intc_mchp_xec_ecia.h>
+#endif
+#include <zephyr/drivers/led.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/device.h>
+#include <zephyr/kernel.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(led_xec, CONFIG_LED_LOG_LEVEL);
+
+/* Same BBLED hardware block in MEC15xx and MEC172x families
+ * Config register
+ */
+#define XEC_BBLED_CFG_MSK		0x1ffffu
+#define XEC_BBLED_CFG_MODE_POS		0
+#define XEC_BBLED_CFG_MODE_MSK		0x3u
+#define XEC_BBLED_CFG_MODE_OFF		0
+#define XEC_BBLED_CFG_MODE_BREATHING	0x1u
+#define XEC_BBLED_CFG_MODE_PWM		0x2u
+#define XEC_BBLED_CFG_MODE_ALWAYS_ON	0x3u
+#define XEC_BBLED_CFG_CLK_SRC_48M_POS	2
+#define XEC_BBLED_CFG_EN_UPDATE_POS	6
+#define XEC_BBLED_CFG_RST_PWM_POS	7
+#define XEC_BBLED_CFG_WDT_RLD_POS	8
+#define XEC_BBLED_CFG_WDT_RLD_MSK0	0xffu
+#define XEC_BBLED_CFG_WDT_RLD_MSK	0xff00u
+#define XEC_BBLED_CFG_WDT_RLD_DFLT	0x1400u
+
+/* Limits register */
+#define XEC_BBLED_LIM_MSK		0xffffu
+#define XEC_BBLED_LIM_MIN_POS		0
+#define XEC_BBLED_LIM_MIN_MSK		0xffu
+#define XEC_BBLED_LIM_MAX_POS		8
+#define XEC_BBLED_LIM_MAX_MSK		0xff00u
+
+/* Delay register */
+#define XEC_BBLED_DLY_MSK		0xffffffu
+#define XEC_BBLED_DLY_LO_POS		0
+#define XEC_BBLED_DLY_LO_MSK		0xfffu
+#define XEC_BBLED_DLY_HI_POS		12
+#define XEC_BBLED_DLY_HI_MSK		0xfff000u
+
+/* Update step size and update interval registers implement
+ * eight 4-bit fields numbered 0 to 7
+ */
+#define XEC_BBLED_UPD_SSI_POS(n)	((uint32_t)(n) * 4u)
+#define XEC_BBLED_UPD_SSI0_MSK(n)	((uint32_t)0xfu << XEC_BBLED_UPD_SSI_POS(n))
+
+/* Output delay register: b[7:0] is delay in clock source units */
+#define XEC_BBLED_OUT_DLY_MSK		0xffu
+
+/* Delay.Lo register field */
+#define XEC_BBLED_MAX_PRESCALER		4095u
+/* Blink mode source frequency is 32768 Hz */
+#define XEC_BBLED_BLINK_CLK_SRC_HZ	32768u
+/* Fblink = 32768 / (256 * (prescaler+1))
+ * prescaler is 12 bit.
+ * Maximum Fblink = 128 Hz or 7.8125 ms
+ * Minimum Fblink = 32.25 mHz or 32000 ms
+ */
+#define XEC_BBLED_BLINK_PERIOD_MAX_MS	32000u
+#define XEC_BBLED_BLINK_PERIOD_MIN_MS	8u
+
+struct xec_bbled_regs {
+	volatile uint32_t config;
+	volatile uint32_t limits;
+	volatile uint32_t delay;
+	volatile uint32_t update_step_size;
+	volatile uint32_t update_interval;
+	volatile uint32_t output_delay;
+};
+
+struct xec_bbled_config {
+	struct xec_bbled_regs * const regs;
+	const struct pinctrl_dev_config *pcfg;
+	uint8_t girq_id;
+	uint8_t girq_pos;
+	uint8_t pcr_id;
+	uint8_t pcr_pos;
+};
+
+/* delay_on and delay_off are in milliseconds
+ * (prescale+1) = (32768 * Tblink_ms) / (256 * 1000)
+ * requires caller to limit delay_on and delay_off based
+ * on BBLED 32KHz minimum/maximum values.
+ */
+static uint32_t calc_blink_32k_prescaler(uint32_t delay_on, uint32_t delay_off)
+{
+	uint32_t temp = ((delay_on + delay_off) * XEC_BBLED_BLINK_CLK_SRC_HZ) / (256U * 1000U);
+	uint32_t prescaler = 0u;
+
+	if (temp) {
+		temp--;
+		if (temp > XEC_BBLED_MAX_PRESCALER) {
+			prescaler = XEC_BBLED_MAX_PRESCALER;
+		} else {
+			prescaler = (uint32_t)temp;
+		}
+	}
+
+	return prescaler;
+}
+
+/* return duty cycle scaled to [0, 255]
+ * caller must insure delay_on and delay_off are in hardware range.
+ */
+static inline uint32_t calc_blink_duty_cycle(uint32_t delay_on, uint32_t delay_off)
+{
+	return (256U * delay_on) / (delay_on + delay_off);
+}
+
+/* Enable HW blinking of the LED.
+ * delay_on = on time in milliseconds
+ * delay_off = off time in milliseconds
+ * BBLED blinking mode uses an 8-bit accumulator and an 8-bit duty cycle
+ * register. The duty cycle register is programmed once and the
+ * accumulator is used as an 8-bit up counter.
+ * The counter uses the 32768 Hz clock and is pre-scaled by the delay
+ * counter. Maximum blink rate is 128Hz to 32.25 mHz (7.8 ms to 32 seconds).
+ * 8-bit duty cycle values: 0x00 = full off, 0xff = full on.
+ * Fblink = 32768 / ((prescale + 1) * 256)
+ * HiWidth (seconds) = (1/Fblink) * (duty_cycle / 256)
+ * LoWidth (seconds) = (1/Fblink) * ((1 - duty_cycle) / 256)
+ * duty_cycle in [0, 1]. Register value for duty cycle is
+ * scaled to [0, 255].
+ * prescale is delay register low delay field, bits[11:0]
+ * duty_cycle is limits register minimum field, bits[7:0]
+ */
+static int xec_bbled_blink(const struct device *dev, uint32_t led,
+			    uint32_t delay_on, uint32_t delay_off)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+	uint32_t period, prescaler, dcs;
+
+	if (led) {
+		return -EINVAL;
+	}
+
+	/* insure period will not overflow uin32_t */
+	if ((delay_on > XEC_BBLED_BLINK_PERIOD_MAX_MS)
+	    || (delay_off > XEC_BBLED_BLINK_PERIOD_MAX_MS)) {
+		return -EINVAL;
+	}
+
+	period = delay_on + delay_off;
+	if ((period < XEC_BBLED_BLINK_PERIOD_MIN_MS)
+	    || (period > XEC_BBLED_BLINK_PERIOD_MAX_MS)) {
+		return -EINVAL;
+	}
+
+	prescaler = calc_blink_32k_prescaler(delay_on, delay_off);
+	dcs = calc_blink_duty_cycle(delay_on, delay_off);
+
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+		       | XEC_BBLED_CFG_MODE_OFF;
+	regs->delay = (regs->delay & ~(XEC_BBLED_DLY_LO_MSK))
+		      | (prescaler & XEC_BBLED_DLY_LO_MSK);
+	regs->limits = (regs->limits & ~(XEC_BBLED_LIM_MIN_MSK))
+		       | (dcs & XEC_BBLED_LIM_MIN_MSK);
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+		       | XEC_BBLED_CFG_MODE_PWM;
+	regs->config |= BIT(XEC_BBLED_CFG_EN_UPDATE_POS);
+
+	return 0;
+}
+
+static int xec_bbled_on(const struct device *dev, uint32_t led)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+
+	if (led) {
+		return -EINVAL;
+	}
+
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+			| XEC_BBLED_CFG_MODE_ALWAYS_ON;
+	return 0;
+}
+
+static int xec_bbled_off(const struct device *dev, uint32_t led)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+
+	if (led) {
+		return -EINVAL;
+	}
+
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+			| XEC_BBLED_CFG_MODE_OFF;
+	return 0;
+}
+
+#ifdef CONFIG_SOC_SERIES_MEC1501X
+static inline void xec_bbled_slp_en_clr(const struct device *dev)
+{
+	const struct xec_bbled_config * const cfg = dev->config;
+	enum pcr_id pcr_val = PCR_MAX_ID;
+
+	switch (cfg->pcr_pos) {
+	case MCHP_PCR3_LED0_POS:
+		pcr_val = PCR_LED0;
+		break;
+	case MCHP_PCR3_LED1_POS:
+		pcr_val = PCR_LED1;
+		break;
+	case MCHP_PCR3_LED2_POS:
+		pcr_val = PCR_LED2;
+		break;
+	default:
+		return;
+	}
+
+	mchp_pcr_periph_slp_ctrl(pcr_val, 0);
+}
+#else
+static inline void xec_bbled_slp_en_clr(const struct device *dev)
+{
+	const struct xec_bbled_config * const cfg = dev->config;
+
+	z_mchp_xec_pcr_periph_sleep(cfg->pcr_id, cfg->pcr_pos, 0);
+}
+#endif
+
+static int xec_bbled_init(const struct device *dev)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+
+	xec_bbled_slp_en_clr(dev);
+
+	/* soft reset, disable BBLED WDT, set clock source to default (32KHz domain) */
+	regs->config |= BIT(XEC_BBLED_CFG_RST_PWM_POS);
+	regs->config = XEC_BBLED_CFG_MODE_OFF;
+
+	int ret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
+
+	if (ret != 0) {
+		LOG_ERR("XEC BBLED pinctrl setup failed (%d)", ret);
+	}
+
+	return ret;
+}
+
+static const struct led_driver_api xec_bbled_api = {
+	.on		= xec_bbled_on,
+	.off		= xec_bbled_off,
+	.blink		= xec_bbled_blink,
+};
+
+#define XEC_BBLED_PINCTRL_DEF(i) PINCTRL_DT_INST_DEFINE(i)
+
+#define XEC_BBLED_CONFIG(i)						\
+static struct xec_bbled_config xec_bbled_config_##i = {			\
+	.regs = (struct xec_bbled_regs * const)DT_INST_REG_ADDR(i),	\
+	.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),			\
+	.girq_id = (uint8_t)(DT_INST_PROP_BY_IDX(i, girqs, 0)),		\
+	.girq_pos = (uint8_t)(DT_INST_PROP_BY_IDX(i, girqs, 1)),	\
+	.pcr_id = (uint8_t)DT_INST_PROP_BY_IDX(i, pcrs, 0),		\
+	.pcr_pos = (uint8_t)DT_INST_PROP_BY_IDX(i, pcrs, 1),		\
+}
+
+#define XEC_BBLED_DEVICE(i)						\
+									\
+XEC_BBLED_PINCTRL_DEF(i);						\
+									\
+XEC_BBLED_CONFIG(i);							\
+									\
+DEVICE_DT_INST_DEFINE(i, &xec_bbled_init, NULL,				\
+		      NULL, &xec_bbled_config_##i,			\
+		      POST_KERNEL, CONFIG_LED_INIT_PRIORITY,		\
+		      &xec_bbled_api);
+
+DT_INST_FOREACH_STATUS_OKAY(XEC_BBLED_DEVICE)
diff --git a/drivers/peci/peci_mchp_xec.c b/drivers/peci/peci_mchp_xec.c
index fff0abe74b..d97f85d855 100644
--- a/drivers/peci/peci_mchp_xec.c
+++ b/drivers/peci/peci_mchp_xec.c
@@ -442,6 +442,7 @@ static int peci_xec_init(const struct device *dev)
 {
 	const struct peci_xec_config * const cfg = dev->config;
 	struct peci_regs * const regs = cfg->regs;
+	struct ecs_regs * const ecs_regs = (struct ecs_regs *)(DT_REG_ADDR(DT_NODELABEL(ecs)));
 
 #ifdef CONFIG_PINCTRL
 	int ret = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
@@ -458,6 +459,8 @@ static int peci_xec_init(const struct device *dev)
 
 	peci_clr_slp_en(dev);
 
+	ecs_regs->PECI_DIS = 0x00u;
+
 	/* Reset PECI interface */
 	regs->CONTROL |= MCHP_PECI_CTRL_RST;
 	k_msleep(PECI_RESET_DELAY_MS);
diff --git a/drivers/peci/peci_npcx.c b/drivers/peci/peci_npcx.c
index 7c7a2a45e5..a8579cbc21 100644
--- a/drivers/peci/peci_npcx.c
+++ b/drivers/peci/peci_npcx.c
@@ -12,8 +12,10 @@
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/peci.h>
 #include <zephyr/drivers/pinctrl.h>
+#include <zephyr/kernel.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(peci_npcx, CONFIG_PECI_LOG_LEVEL);
 
 #define PECI_TIMEOUT		 K_MSEC(300)
@@ -78,7 +80,7 @@ static int peci_npcx_configure(const struct device *dev, uint32_t bitrate)
 	 * The unit of the bitrate is in Kbps, need to convert it to bps when
 	 * calculate the divider
 	 */
-	bit_rate_divider = ceiling_fraction(data->peci_src_clk_freq, bitrate * 1000 * 4) - 1;
+	bit_rate_divider = DIV_ROUND_UP(data->peci_src_clk_freq, bitrate * 1000 * 4) - 1;
 	/*
 	 * Make sure the divider doesn't exceed the max valid value and is not lower than the
 	 * minimal valid value.
@@ -242,13 +244,13 @@ static int peci_npcx_init(const struct device *dev)
 		return -ENODEV;
 	}
 
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)&config->clk_cfg);
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on PECI clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)&config->clk_cfg,
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clk_cfg,
 				     &data->peci_src_clk_freq);
 	if (ret < 0) {
 		LOG_ERR("Get PECI source clock rate error %d", ret);
diff --git a/drivers/pinctrl/pinctrl_npcx.c b/drivers/pinctrl/pinctrl_npcx.c
index 22848b937d..afdd0ecf60 100644
--- a/drivers/pinctrl/pinctrl_npcx.c
+++ b/drivers/pinctrl/pinctrl_npcx.c
@@ -38,17 +38,10 @@ static const struct npcx_pwm_pinctrl_config pwm_pinctrl_cfg[] = {
 /* Pin-control local functions for peripheral devices */
 static bool npcx_periph_pinmux_has_lock(int group)
 {
-#if defined(CONFIG_SOC_SERIES_NPCX7)
-	if (group == 0x00 || (group >= 0x02 && group <= 0x04) || group == 0x06 ||
-		group == 0x0b || group == 0x0f) {
+	if ((BIT(group) & NPCX_DEVALT_LK_GROUP_MASK) != 0) {
 		return true;
 	}
-#elif defined(CONFIG_SOC_SERIES_NPCX9)
-	if (group == 0x00 || (group >= 0x02 && group <= 0x06) || group == 0x0b ||
-		group == 0x0d || (group >= 0x0f && group <= 0x12)) {
-		return true;
-	}
-#endif
+
 	return false;
 }
 
@@ -71,8 +64,11 @@ static void npcx_periph_pinmux_configure(const struct npcx_periph *alt, bool is_
 		NPCX_DEVALT(scfg_base, alt->group) &= ~alt_mask;
 	}
 
+	/* NPCK3 series doesn't support lock functionality */
 	if (is_locked && npcx_periph_pinmux_has_lock(alt->group)) {
+#if !defined(CONFIG_SOC_SERIES_NPCK3)
 		NPCX_DEVALT_LK(scfg_base, alt->group) |= alt_mask;
+#endif
 	}
 }
 
@@ -146,11 +142,35 @@ static void npcx_psl_input_detection_configure(const pinctrl_soc_pin_t *pin)
 	}
 
 	/* Configure detection mode of PSL input pads */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if (pin->flags.psl_in_mode == NPCX_PSL_IN_MODE_EDGE) {
+		inst_glue->PSL_CTS3 |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	} else {
+		inst_glue->PSL_CTS3 &= ~NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	}
+
+	/* Clear event bits */
+	inst_glue->PSL_CTS |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	inst_glue->PSL_IN_POS |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	inst_glue->PSL_IN_NEG |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+
+#else
 	if (pin->flags.psl_in_mode == NPCX_PSL_IN_MODE_EDGE) {
 		inst_glue->PSL_CTS |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
 	} else {
 		inst_glue->PSL_CTS &= ~NPCX_PSL_CTS_MODE_BIT(psl_in->port);
 	}
+#endif
+}
+
+static void npcx_device_control_configure(const pinctrl_soc_pin_t *pin)
+{
+	const struct npcx_dev_ctl *ctrl = (const struct npcx_dev_ctl *)&pin->cfg.dev_ctl;
+	const uintptr_t scfg_base = npcx_pinctrl_cfg.base_scfg;
+
+	SET_FIELD(NPCX_DEV_CTL(scfg_base, ctrl->offest),
+			      FIELD(ctrl->field_offset, ctrl->field_size),
+			      ctrl->field_value);
 }
 
 /* Pinctrl API implementation */
@@ -164,6 +184,9 @@ int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
 		if (pins[i].flags.type == NPCX_PINCTRL_TYPE_PERIPH) {
 			/* Configure peripheral device's pinmux functionality */
 			npcx_periph_configure(&pins[i], reg);
+		} else if (pins[i].flags.type == NPCX_PINCTRL_TYPE_DEVICE_CTRL) {
+			/* Configure device's io characteristics */
+			npcx_device_control_configure(&pins[i]);
 		} else if (pins[i].flags.type == NPCX_PINCTRL_TYPE_PSL_IN) {
 			/* Configure SPL input's detection mode */
 			npcx_psl_input_detection_configure(&pins[i]);
diff --git a/drivers/ps2/Kconfig.npcx b/drivers/ps2/Kconfig.npcx
index e14e680eb3..afbec76d92 100644
--- a/drivers/ps2/Kconfig.npcx
+++ b/drivers/ps2/Kconfig.npcx
@@ -5,7 +5,8 @@
 
 menuconfig PS2_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) PS2 driver"
-	depends on SOC_FAMILY_NPCX && ESPI_PERIPHERAL_8042_KBC
+	depends on DT_HAS_NUVOTON_NPCX_PS2_CHANNEL_ENABLED
+	default y
 	help
 	  Enable the NPCX family PS2 driver. It provides four PS/2 channels.
 	  Each channel has two quasi-bidirectional signals that serve as
diff --git a/drivers/ps2/ps2_npcx_controller.c b/drivers/ps2/ps2_npcx_controller.c
index aacb9973ef..ad37d5e162 100644
--- a/drivers/ps2/ps2_npcx_controller.c
+++ b/drivers/ps2/ps2_npcx_controller.c
@@ -15,11 +15,13 @@
  * The hardware accelerator mechanism is shared by four PS/2 channels.
  */
 
+#include <zephyr/kernel.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/ps2.h>
 #include <zephyr/dt-bindings/clock/npcx_clock.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(ps2_npcx_ctrl, CONFIG_PS2_LOG_LEVEL);
 
 #define NPCX_PS2_CH_COUNT 4
@@ -337,7 +339,7 @@ static int ps2_npcx_ctrl_init(const struct device *dev)
 
 	/* Turn on PS/2 controller device clock */
 	ret = clock_control_on(clk_dev,
-			       (clock_control_subsys_t *)&config->clk_cfg);
+			       (clock_control_subsys_t)&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on PS/2 clock fail %d", ret);
 		return ret;
diff --git a/drivers/pwm/pwm_npcx.c b/drivers/pwm/pwm_npcx.c
index d39c173581..44dd89d350 100644
--- a/drivers/pwm/pwm_npcx.c
+++ b/drivers/pwm/pwm_npcx.c
@@ -113,7 +113,7 @@ static int pwm_npcx_set_cycles(const struct device *dev, uint32_t channel,
 	 * maximum pwm period cycles and won't exceed it.
 	 * Then prescaler = ceil (period_cycles / pwm_max_period_cycles)
 	 */
-	prescaler = ceiling_fraction(period_cycles, NPCX_PWM_MAX_PERIOD_CYCLES);
+	prescaler = DIV_ROUND_UP(period_cycles, NPCX_PWM_MAX_PERIOD_CYCLES);
 	if (prescaler > NPCX_PWM_MAX_PRESCALER) {
 		return -EINVAL;
 	}
@@ -189,14 +189,14 @@ static int pwm_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on PWM clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&config->clk_cfg, &data->cycles_per_sec);
 	if (ret < 0) {
 		LOG_ERR("Get PWM clock rate error %d", ret);
@@ -230,7 +230,7 @@ static int pwm_npcx_init(const struct device *dev)
 	DEVICE_DT_INST_DEFINE(inst,					       \
 			    &pwm_npcx_init, NULL,			       \
 			    &pwm_npcx_data_##inst, &pwm_npcx_cfg_##inst,       \
-			    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \
+			    PRE_KERNEL_1, CONFIG_PWM_INIT_PRIORITY,	       \
 			    &pwm_npcx_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(NPCX_PWM_INIT)
diff --git a/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig b/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig
index d40f36c573..e1abfacaea 100644
--- a/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig
+++ b/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig
@@ -13,4 +13,32 @@ config ADC_CMP_NPCX
 	  This option enables threshold interruption using sensor
 	  trigger API.
 
+if ADC_CMP_NPCX
+
+config ADC_CMP_NPCX_WORKQUEUE
+	bool "NPCX ADC threshold detection uses internal work queue"
+	help
+	  Threshold detection ISR utilizes system work queue for calling
+	  trigger handlers; set this option to use dedicated work queue instead.
+
+if ADC_CMP_NPCX_WORKQUEUE
+
+config ADC_CMP_NPCX_WORKQUEUE_PRIORITY
+	int "Nuvoton NPCX ADC trheshold detection work queue priority"
+	default SYSTEM_WORKQUEUE_PRIORITY
+	help
+	  This option sets internal ADC NPCX threshold detection workqueue
+	  priority.
+
+config ADC_CMP_NPCX_WORKQUEUE_STACK_SIZE
+	int "Nuvoton NPCX ADC trheshold detection work queue stack size"
+	default 768
+	help
+	  This option sets internal ADC NPCX threshold detection workqueue
+	  stack size.
+
+endif # ADC_CMP_NPCX_WORKQUEUE
+
+endif # ADC_CMP_NPCX
+
 endif # ADC_NPCX
diff --git a/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c b/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c
index 900e91fe11..cba37069ce 100644
--- a/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c
+++ b/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c
@@ -7,7 +7,7 @@
 #include <zephyr/drivers/sensor.h>
 #include <zephyr/drivers/adc/adc_npcx_threshold.h>
 #include <zephyr/drivers/sensor/adc_cmp_npcx.h>
-
+#include <zephyr/kernel.h>
 #include <zephyr/logging/log.h>
 
 LOG_MODULE_REGISTER(adc_cmp_npcx, CONFIG_SENSOR_LOG_LEVEL);
@@ -92,7 +92,7 @@ static int adc_cmp_npcx_init(const struct device *dev)
 	if (config->thr_mv != ADC_CMP_NPCX_UNDEFINED) {
 		param.type = ADC_NPCX_THRESHOLD_PARAM_THVAL;
 		/* Convert from millivolts to ADC raw register value */
-		ret = adc_npcx_threshold_mv_to_thrval(config->thr_mv,
+		ret = adc_npcx_threshold_mv_to_thrval(config->adc, config->thr_mv,
 						&param.val);
 		if (ret) {
 			goto init_error;
@@ -135,7 +135,7 @@ static int adc_cmp_npcx_set_threshold(const struct device *dev, bool is_upper,
 
 	param.type = ADC_NPCX_THRESHOLD_PARAM_THVAL;
 	if (is_mv) {
-		ret = adc_npcx_threshold_mv_to_thrval(value, &param.val);
+		ret = adc_npcx_threshold_mv_to_thrval(config->adc, value, &param.val);
 		if (ret) {
 			return ret;
 		}
@@ -251,20 +251,23 @@ static const struct sensor_driver_api adc_cmp_npcx_api = {
 	.channel_get = adc_cmp_npcx_channel_get,
 };
 
-#define NPCX_ADC_CMP_INIT(inst)                                               \
-	static struct adc_cmp_npcx_data adc_cmp_npcx_data_##inst;             \
-	static const struct adc_cmp_npcx_config adc_cmp_npcx_config_##inst = {\
-		.adc = DEVICE_DT_GET(DT_INST_IO_CHANNELS_CTLR(inst)),         \
-		.chnsel = DT_INST_IO_CHANNELS_INPUT(inst),                    \
-		.th_sel = inst,                                               \
-		.thr_mv = DT_INST_PROP_OR(inst, threshold_mv,                 \
-			ADC_CMP_NPCX_UNDEFINED),                              \
-		.comparison = DT_INST_STRING_TOKEN_OR(inst,                   \
-			comparison, ADC_CMP_NPCX_UNDEFINED)                   \
-	};                                                                    \
-	DEVICE_DT_INST_DEFINE(inst, adc_cmp_npcx_init, NULL,                  \
-			      &adc_cmp_npcx_data_##inst,                      \
-			      &adc_cmp_npcx_config_##inst, PRE_KERNEL_2,      \
-			      CONFIG_SENSOR_INIT_PRIORITY,                    \
-			      &adc_cmp_npcx_api);
+#define NPCX_ADC_CMP_INIT(inst)							\
+	static struct adc_cmp_npcx_data adc_cmp_npcx_data_##inst;		\
+	static const struct adc_cmp_npcx_config adc_cmp_npcx_config_##inst = {	\
+		.adc = DEVICE_DT_GET(DT_INST_IO_CHANNELS_CTLR(inst)),		\
+		.chnsel = DT_INST_IO_CHANNELS_INPUT(inst),			\
+		.th_sel = DT_INST_STRING_TOKEN_OR(inst, thr_sel, inst),		\
+		.thr_mv = DT_INST_PROP_OR(inst, threshold_mv,			\
+			ADC_CMP_NPCX_UNDEFINED),				\
+		.comparison = DT_INST_STRING_TOKEN_OR(inst,			\
+			comparison, ADC_CMP_NPCX_UNDEFINED)			\
+	};									\
+	SENSOR_DEVICE_DT_INST_DEFINE(inst, adc_cmp_npcx_init, NULL,		\
+			      &adc_cmp_npcx_data_##inst,			\
+			      &adc_cmp_npcx_config_##inst, POST_KERNEL,		\
+			      CONFIG_SENSOR_INIT_PRIORITY,			\
+			      &adc_cmp_npcx_api);				\
+	BUILD_ASSERT(DT_INST_STRING_TOKEN_OR(inst, thr_sel, inst) <		\
+		     DT_PROP(DT_INST_IO_CHANNELS_CTLR(inst), threshold_count),	\
+		     "Exceed the number of threshold detectors adc supports");
 DT_INST_FOREACH_STATUS_OKAY(NPCX_ADC_CMP_INIT)
diff --git a/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c b/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c
index 3efd363a90..b373d998b6 100644
--- a/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c
+++ b/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c
@@ -176,7 +176,7 @@ static inline bool tach_npcx_is_captured(const struct device *dev)
 
 	LOG_DBG("port A is captured %d, port b is captured %d",
 		IS_BIT_SET(inst->TECTRL, NPCX_TECTRL_TAPND),
-		IS_BIT_SET(inst->TECTRL, NPCX_TECTRL_TAPND));
+		IS_BIT_SET(inst->TECTRL, NPCX_TECTRL_TBPND));
 
 	/*
 	 * In mode 5, the flag TAPND or TBPND indicates a input captured on
@@ -259,6 +259,8 @@ int tach_npcx_sample_fetch(const struct device *dev, enum sensor_channel chan)
 	if (tach_npcx_is_underflow(dev)) {
 		/* Clear pending flags */
 		tach_npcx_clear_underflow_flag(dev);
+		/* Clear stale captured data */
+		tach_npcx_clear_captured_flag(dev);
 		data->capture = 0;
 
 		return 0;
@@ -320,14 +322,14 @@ static int tach_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on tachometer clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 					&config->clk_cfg, &data->input_clk);
 	if (ret < 0) {
 		LOG_ERR("Get tachometer clock rate error %d", ret);
@@ -380,7 +382,7 @@ static const struct sensor_driver_api tach_npcx_driver_api = {
 									       \
 	static struct tach_npcx_data tach_data_##inst;                         \
 									       \
-	DEVICE_DT_INST_DEFINE(inst,                                            \
+	SENSOR_DEVICE_DT_INST_DEFINE(inst,                                     \
 			      tach_npcx_init,                                  \
 			      NULL,                                            \
 			      &tach_data_##inst,                               \
diff --git a/drivers/serial/uart_npcx.c b/drivers/serial/uart_npcx.c
index c609a26026..84d197fab7 100644
--- a/drivers/serial/uart_npcx.c
+++ b/drivers/serial/uart_npcx.c
@@ -19,6 +19,7 @@
 #include "soc_power.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(uart_npcx, CONFIG_UART_LOG_LEVEL);
 
 /* Driver config */
@@ -46,7 +47,8 @@ enum uart_pm_policy_state_flag {
 struct uart_npcx_data {
 	/* Baud rate */
 	uint32_t baud_rate;
-	struct miwu_dev_callback uart_rx_cb;
+	struct miwu_callback uart_rx_cb;
+	struct k_spinlock lock;
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
 	uart_irq_callback_user_data_t user_cb;
 	void *user_data;
@@ -59,7 +61,7 @@ struct uart_npcx_data {
 #endif
 };
 
-#if defined(CONFIG_PM) && defined(CONFIG_UART_INTERRUPT_DRIVEN)
+#ifdef CONFIG_PM
 static void uart_npcx_pm_policy_state_lock_get(struct uart_npcx_data *data,
 					       enum uart_pm_policy_state_flag flag)
 {
@@ -75,7 +77,7 @@ static void uart_npcx_pm_policy_state_lock_put(struct uart_npcx_data *data,
 		pm_policy_state_lock_put(PM_STATE_SUSPEND_TO_IDLE, PM_ALL_SUBSTATES);
 	}
 }
-#endif /* defined(CONFIG_PM) && defined(CONFIG_UART_INTERRUPT_DRIVEN) */
+#endif
 
 /* UART local functions */
 static int uart_set_npcx_baud_rate(struct uart_reg *const inst, int baud_rate, int src_clk)
@@ -105,7 +107,11 @@ static int uart_npcx_tx_fifo_ready(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* True if the Tx FIFO is not completely full */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return inst->UTXFLV != NPCK_SZ_UART_FIFO;
+#else
 	return !(GET_FIELD(inst->UFTSTS, NPCX_UFTSTS_TEMPTY_LVL) == 0);
+#endif
 }
 
 static int uart_npcx_rx_fifo_available(const struct device *dev)
@@ -114,7 +120,11 @@ static int uart_npcx_rx_fifo_available(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* True if at least one byte is in the Rx FIFO */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return inst->URXFLV != 0;
+#else
 	return IS_BIT_SET(inst->UFRSTS, NPCX_UFRSTS_RFIFO_NEMPTY_STS);
+#endif
 }
 
 static void uart_npcx_dis_all_tx_interrupts(const struct device *dev)
@@ -123,9 +133,13 @@ static void uart_npcx_dis_all_tx_interrupts(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* Disable all Tx interrupts */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL &= ~BIT(NPCX_UICTRL_ETI);
+#else
 	inst->UFTCTL &= ~(BIT(NPCX_UFTCTL_TEMPTY_LVL_EN) |
 			  BIT(NPCX_UFTCTL_TEMPTY_EN) |
 			  BIT(NPCX_UFTCTL_NXMIP_EN));
+#endif
 }
 
 static void uart_npcx_clear_rx_fifo(const struct device *dev)
@@ -143,21 +157,21 @@ static int uart_npcx_fifo_fill(const struct device *dev, const uint8_t *tx_data,
 {
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
+	struct uart_npcx_data *data = dev->data;
 	uint8_t tx_bytes = 0U;
+	k_spinlock_key_t key = k_spin_lock(&data->lock);
 
 	/* If Tx FIFO is still ready to send */
 	while ((size - tx_bytes > 0) && uart_npcx_tx_fifo_ready(dev)) {
 		/* Put a character into Tx FIFO */
-#ifdef CONFIG_PM
-		struct uart_npcx_data *data = dev->data;
-
-		uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_TX_FLAG);
-		inst->UTBUF = tx_data[tx_bytes++];
-		inst->UFTCTL |= BIT(NPCX_UFTCTL_NXMIP_EN);
-#else
 		inst->UTBUF = tx_data[tx_bytes++];
-#endif /* CONFIG_PM */
 	}
+#ifdef CONFIG_PM
+	uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_TX_FLAG);
+	/* Enable NXMIP interrupt in case ec enters deep sleep early */
+	inst->UFTCTL |= BIT(NPCX_UFTCTL_NXMIP_EN);
+#endif /* CONFIG_PM */
+	k_spin_unlock(&data->lock, key);
 
 	return tx_bytes;
 }
@@ -182,7 +196,15 @@ static void uart_npcx_irq_tx_enable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL |= BIT(NPCX_UICTRL_ETI);
+#else
+	struct uart_npcx_data *data = dev->data;
+	k_spinlock_key_t key = k_spin_lock(&data->lock);
+
 	inst->UFTCTL |= BIT(NPCX_UFTCTL_TEMPTY_EN);
+	k_spin_unlock(&data->lock, key);
+#endif
 }
 
 static void uart_npcx_irq_tx_disable(const struct device *dev)
@@ -190,12 +212,32 @@ static void uart_npcx_irq_tx_disable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL &= ~(BIT(NPCX_UICTRL_ETI));
+#else
+	struct uart_npcx_data *data = dev->data;
+	k_spinlock_key_t key = k_spin_lock(&data->lock);
+
 	inst->UFTCTL &= ~(BIT(NPCX_UFTCTL_TEMPTY_EN));
+	k_spin_unlock(&data->lock, key);
+#endif
+}
+
+static bool uart_npcx_irq_tx_is_enabled(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_ETI);
+#else
+	return IS_BIT_SET(inst->UFTCTL, NPCX_UFTCTL_TEMPTY_EN);
+#endif
 }
 
 static int uart_npcx_irq_tx_ready(const struct device *dev)
 {
-	return uart_npcx_tx_fifo_ready(dev);
+	return uart_npcx_tx_fifo_ready(dev) && uart_npcx_irq_tx_is_enabled(dev);
 }
 
 static int uart_npcx_irq_tx_complete(const struct device *dev)
@@ -204,7 +246,11 @@ static int uart_npcx_irq_tx_complete(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* Tx FIFO is empty or last byte is sending */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return inst->UTXFLV == 0;
+#else
 	return IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP);
+#endif
 }
 
 static void uart_npcx_irq_rx_enable(const struct device *dev)
@@ -212,7 +258,11 @@ static void uart_npcx_irq_rx_enable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL |= BIT(NPCX_UICTRL_ERI);
+#else
 	inst->UFRCTL |= BIT(NPCX_UFRCTL_RNEMPTY_EN);
+#endif
 }
 
 static void uart_npcx_irq_rx_disable(const struct device *dev)
@@ -220,7 +270,23 @@ static void uart_npcx_irq_rx_disable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL &= ~(BIT(NPCX_UICTRL_ERI));
+#else
 	inst->UFRCTL &= ~(BIT(NPCX_UFRCTL_RNEMPTY_EN));
+#endif
+}
+
+static bool uart_npcx_irq_rx_is_enabled(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_ERI);
+#else
+	return IS_BIT_SET(inst->UFRCTL, NPCX_UFRCTL_RNEMPTY_EN);
+#endif
 }
 
 static int uart_npcx_irq_rx_ready(const struct device *dev)
@@ -246,7 +312,8 @@ static void uart_npcx_irq_err_disable(const struct device *dev)
 
 static int uart_npcx_irq_is_pending(const struct device *dev)
 {
-	return (uart_npcx_irq_tx_ready(dev) || uart_npcx_irq_rx_ready(dev));
+	return uart_npcx_irq_tx_ready(dev) ||
+		(uart_npcx_irq_rx_ready(dev) && uart_npcx_irq_rx_is_enabled(dev));
 }
 
 static int uart_npcx_irq_update(const struct device *dev)
@@ -291,8 +358,12 @@ static void uart_npcx_isr(const struct device *dev)
 
 	if (IS_BIT_SET(inst->UFTCTL, NPCX_UFTCTL_NXMIP_EN) &&
 	    IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP)) {
-		uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_TX_FLAG);
+		k_spinlock_key_t key = k_spin_lock(&data->lock);
+
+		/* Disable NXMIP interrupt */
 		inst->UFTCTL &= ~BIT(NPCX_UFTCTL_NXMIP_EN);
+		k_spin_unlock(&data->lock, key);
+		uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_TX_FLAG);
 	}
 #endif /* CONFIG_PM */
 }
@@ -395,8 +466,9 @@ static __unused void uart_npcx_rx_wk_isr(const struct device *dev, struct npcx_w
 #ifdef CONFIG_UART_CONSOLE_INPUT_EXPIRED
 static void uart_npcx_rx_refresh_timeout(struct k_work *work)
 {
+	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 	struct uart_npcx_data *data =
-		CONTAINER_OF(work, struct uart_npcx_data, rx_refresh_timeout_work);
+		CONTAINER_OF(dwork, struct uart_npcx_data, rx_refresh_timeout_work);
 
 	uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_RX_FLAG);
 }
@@ -440,7 +512,7 @@ static int uart_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)&config->clk_cfg);
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on UART clock fail %d", ret);
 		return ret;
@@ -450,7 +522,7 @@ static int uart_npcx_init(const struct device *dev)
 	 * If apb2's clock is not 15MHz, we need to find the other optimized
 	 * values of UPSR and UBAUD for baud rate 115200.
 	 */
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)&config->clk_cfg,
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clk_cfg,
 				     &uart_rate);
 	if (ret < 0) {
 		LOG_ERR("Get UART clock rate error %d", ret);
@@ -473,8 +545,12 @@ static int uart_npcx_init(const struct device *dev)
 
 	/* Initialize UART FIFO if mode is interrupt driven */
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UFCTRL |= BIT(NPCK_FIFO_EN);
+#else
 	/* Enable the UART FIFO mode */
 	inst->UMDSL |= BIT(NPCX_UMDSL_FIFO_MD);
+#endif
 
 	/* Disable all UART tx FIFO interrupts */
 	uart_npcx_dis_all_tx_interrupts(dev);
@@ -490,7 +566,7 @@ static int uart_npcx_init(const struct device *dev)
 		/* Initialize a miwu device input and its callback function */
 		npcx_miwu_init_dev_callback(&data->uart_rx_cb, &config->uart_rx_wui,
 					    uart_npcx_rx_wk_isr, dev);
-		npcx_miwu_manage_dev_callback(&data->uart_rx_cb, true);
+		npcx_miwu_manage_callback(&data->uart_rx_cb, true);
 		/*
 		 * Configure the UART wake-up event triggered from a falling
 		 * edge on CR_SIN pin. No need for callback function.
diff --git a/drivers/spi/CMakeLists.txt b/drivers/spi/CMakeLists.txt
index 58e28804ac..a848904ef8 100644
--- a/drivers/spi/CMakeLists.txt
+++ b/drivers/spi/CMakeLists.txt
@@ -25,7 +25,7 @@ zephyr_library_sources_ifdef(CONFIG_SPI_XLNX_AXI_QUADSPI spi_xlnx_axi_quadspi.c)
 zephyr_library_sources_ifdef(CONFIG_ESP32_SPIM		spi_esp32_spim.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_TEST		spi_test.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_PSOC6		spi_psoc6.c)
-zephyr_library_sources_ifdef(CONFIG_SPI_NPCX_FIU	spi_npcx_fiu.c)
+# zephyr_library_sources_ifdef(CONFIG_SPI_NPCX_FIU	spi_npcx_fiu.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_BITBANG		spi_bitbang.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_XEC_QMSPI_LDMA	spi_xec_qmspi_ldma.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_GD32		spi_gd32.c)
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 4d028b05c8..9739824530 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -93,7 +93,7 @@ source "drivers/spi/Kconfig.test"
 
 source "drivers/spi/Kconfig.psoc6"
 
-source "drivers/spi/Kconfig.npcx_fiu"
+# source "drivers/spi/Kconfig.npcx_fiu"
 
 source "drivers/spi/Kconfig.bitbang"
 
diff --git a/drivers/timer/npcx_itim_timer.c b/drivers/timer/npcx_itim_timer.c
index a6eb113c6f..590b9d25ba 100644
--- a/drivers/timer/npcx_itim_timer.c
+++ b/drivers/timer/npcx_itim_timer.c
@@ -34,14 +34,16 @@
  *   "sleep/deep sleep" power state if CONFIG_PM is enabled.
  */
 
-#include <zephyr/device.h>
+#include <zephyr/init.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/timer/system_timer.h>
+#include <zephyr/kernel.h>
 #include <zephyr/sys_clock.h>
 #include <zephyr/spinlock.h>
 #include <soc.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(itim, LOG_LEVEL_ERR);
 
 #define NPCX_ITIM32_MAX_CNT 0xffffffff
@@ -301,9 +303,8 @@ uint64_t npcx_clock_get_sleep_ticks(void)
 }
 #endif /* CONFIG_PM */
 
-static int sys_clock_driver_init(const struct device *dev)
+static int sys_clock_driver_init(void)
 {
-	ARG_UNUSED(dev);
 	int ret;
 	uint32_t sys_tmr_rate;
 	const struct device *const clk_dev = DEVICE_DT_GET(NPCX_CLK_CTRL_NODE);
@@ -315,7 +316,7 @@ static int sys_clock_driver_init(const struct device *dev)
 
 	/* Turn on all itim module clocks used for counting */
 	for (int i = 0; i < ARRAY_SIZE(itim_clk_cfg); i++) {
-		ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+		ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 				&itim_clk_cfg[i]);
 		if (ret < 0) {
 			LOG_ERR("Turn on timer %d clock failed.", i);
@@ -327,7 +328,7 @@ static int sys_clock_driver_init(const struct device *dev)
 	 * In npcx series, we use ITIM64 as system kernel timer. Its source
 	 * clock frequency must equal to CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC.
 	 */
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&itim_clk_cfg[1], &sys_tmr_rate);
 	if (ret < 0) {
 		LOG_ERR("Get ITIM64 clock rate failed %d", ret);
diff --git a/drivers/watchdog/wdt_npcx.c b/drivers/watchdog/wdt_npcx.c
index 52df7c5866..b34cf13386 100644
--- a/drivers/watchdog/wdt_npcx.c
+++ b/drivers/watchdog/wdt_npcx.c
@@ -28,14 +28,18 @@
  *
  */
 
+#include "soc_miwu.h"
+
 #include <assert.h>
-#include <zephyr/drivers/gpio.h>
+
 #include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/gpio.h>
 #include <zephyr/drivers/watchdog.h>
-#include <soc.h>
-
-#include "soc_miwu.h"
+#include <zephyr/kernel.h>
 #include <zephyr/logging/log.h>
+
+#include <soc.h>
+#include "soc_dbg.h"
 LOG_MODULE_REGISTER(wdt_npcx, CONFIG_WDT_LOG_LEVEL);
 
 /* Watchdog operating frequency is fixed to LFCLK (32.768) kHz */
@@ -79,7 +83,7 @@ struct wdt_npcx_data {
 	bool timeout_installed;
 };
 
-struct miwu_dev_callback miwu_cb;
+struct miwu_callback miwu_cb;
 
 /* Driver convenience defines */
 #define HAL_INSTANCE(dev) ((struct twd_reg *)((const struct wdt_npcx_config *)(dev)->config)->base)
@@ -150,7 +154,7 @@ static void wdt_config_t0out_interrupt(const struct device *dev)
 	/* Initialize a miwu device input and its callback function */
 	npcx_miwu_init_dev_callback(&miwu_cb, &config->t0out, wdt_t0out_isr,
 			dev);
-	npcx_miwu_manage_dev_callback(&miwu_cb, true);
+	npcx_miwu_manage_callback(&miwu_cb, true);
 
 	/*
 	 * Configure the T0 wake-up event triggered from a rising edge
@@ -224,20 +228,22 @@ static int wdt_npcx_setup(const struct device *dev, uint8_t options)
 		return -ENOTSUP;
 	}
 
+	/* Stall the WDT counter when halted by debugger */
 	if ((options & WDT_OPT_PAUSE_HALTED_BY_DBG) != 0) {
-		LOG_ERR("WDT_OPT_PAUSE_HALTED_BY_DBG is not supported");
-		return -ENOTSUP;
+		npcx_dbg_freeze_enable(true);
+	} else {
+		npcx_dbg_freeze_enable(false);
 	}
 
 	/*
 	 * One clock period of T0 timer is 32/32.768 KHz = 0.976 ms.
 	 * Then the counter value is timeout/0.976 - 1.
 	 */
-	inst->TWDT0 = MAX(ceiling_fraction(data->timeout * NPCX_WDT_CLK,
+	inst->TWDT0 = MAX(DIV_ROUND_UP(data->timeout * NPCX_WDT_CLK,
 				32 * 1000) - 1, 1);
 
 	/* Configure 8-bit watchdog counter */
-	inst->WDCNT = MIN(ceiling_fraction(data->timeout, 32) +
+	inst->WDCNT = MIN(DIV_ROUND_UP(data->timeout, 32) +
 					CONFIG_WDT_NPCX_DELAY_CYCLES, 0xff);
 
 	LOG_DBG("WDT setup: TWDT0, WDCNT are %d, %d", inst->TWDT0, inst->WDCNT);
@@ -337,6 +343,10 @@ static int wdt_npcx_init(const struct device *dev)
 	inst->WDCP = 0x05; /* Prescaler is 32 in Watchdog Timer */
 	inst->TWCP = 0x05; /* Prescaler is 32 in T0 Timer */
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->T0CSR |= BIT(NPCX_T0CSR_T0EN); /* enable T0OUT */
+#endif
+
 	return 0;
 }
 
diff --git a/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi b/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi
index c662131f23..c242d74752 100644
--- a/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi
@@ -130,7 +130,7 @@
 		 * low voltage detection.)
 		 */
 		lvol_none: lvol-pseudo {
-			lvols = <&scfg 6 0>;
+			lvols = <&scfg 31 0>;
 		};
 	};
 };
diff --git a/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi b/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi
index f71349e805..e1a1266a48 100644
--- a/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi
@@ -23,9 +23,6 @@
 		wui_io83: wui0-1-3 {
 			miwus = <&miwu0 0 3>; /* GPIO83 */
 		};
-		wui_cr_sin2: wui0-1-6-2 {
-			miwus = <&miwu0 0 6>; /* CR_SIN2 */
-		};
 		wui_io87: wui0-1-7 {
 			miwus = <&miwu0 0 7>; /* GPIO87 */
 		};
diff --git a/dts/arm/nuvoton/npcx/npcx.dtsi b/dts/arm/nuvoton/npcx/npcx.dtsi
new file mode 100644
index 0000000000..bbb3ef3923
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx.dtsi
@@ -0,0 +1,681 @@
+/*
+ * Copyright (c) 2021 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <arm/armv7-m.dtsi>
+
+/* Macros for device tree declarations of npcx soc family */
+#include <zephyr/dt-bindings/adc/adc.h>
+#include <zephyr/dt-bindings/clock/npcx_clock.h>
+#include <zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h>
+#include <zephyr/dt-bindings/gpio/gpio.h>
+#include <zephyr/dt-bindings/i2c/i2c.h>
+#include <zephyr/dt-bindings/pinctrl/npcx-pinctrl.h>
+#include <zephyr/dt-bindings/pwm/pwm.h>
+#include <zephyr/dt-bindings/sensor/npcx_tach.h>
+#include <freq.h>
+
+/ {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-m4f";
+			reg = <0>;
+			cpu-power-states = <&suspend_to_idle0 &suspend_to_idle1>;
+		};
+
+		power-states {
+			suspend_to_idle0: suspend-to-idle0 {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-idle";
+				substate-id = <0>;
+				min-residency-us = <1000>;
+			};
+
+			suspend_to_idle1: suspend-to-idle1 {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-idle";
+				substate-id = <1>;
+				min-residency-us = <201000>;
+			};
+		};
+	};
+
+	def-io-conf-list {
+		compatible = "nuvoton,npcx-pinctrl-def";
+		/* Change default functional pads to GPIOs
+		 * no_spip - PIN95.97.A1.A3
+		 * no_fpip - PIN96.A0.A2.A4 - Internal flash only
+		 * no_pwrgd - PIN72
+		 * no_lpc_espi - PIN46.47.51.52.53.54.55.57
+		 * no_peci_en - PIN81
+		 * npsl_in1_sl - PIND2
+		 * npsl_in2_sl - PIN00
+		 * no_ksi0-7 - PIN31.30.27.26.25.24.23.22
+		 * no_ks000-17 - PIN21.20.17.16.15.14.13.12.11.10.07.06.05.04.
+		 *                  82.83.03.B1
+		 */
+		pinmux = <>;
+	};
+
+	/** Dummy pinctrl node. It will be initialized with defaults based on the SoC series.
+	 *  Then, the user can override the pin control options at the board level.
+	 */
+	pinctrl: pinctrl {
+		compatible = "nuvoton,npcx-pinctrl";
+		status = "okay";
+	};
+
+	/* Dummy node of IOs that have leakage current. The user can override
+	 * 'leak-gpios' prop. at board DT file to save more power consumption.
+	 */
+	power_leakage_io: power-leakage-io {
+		compatible = "nuvoton,npcx-leakage-io";
+		status = "okay";
+	};
+
+	soc {
+		bbram: bb-ram@400af000 {
+			compatible = "nuvoton,npcx-bbram";
+			reg = <0x400af000 0x80
+			       0x400af100 0x1>;
+			reg-names = "memory", "status";
+		};
+
+		pcc: clock-controller@4000d000 {
+			compatible = "nuvoton,npcx-pcc";
+			/* Cells for bus type, clock control reg and bit */
+			#clock-cells = <3>;
+			/* First reg region is Power Management Controller */
+			/* Second reg region is Core Domain Clock Generator */
+			reg = <0x4000d000 0x2000
+			       0x400b5000 0x2000>;
+			reg-names = "pmc", "cdcg";
+		};
+
+		scfg: scfg@400c3000 {
+			compatible = "nuvoton,npcx-scfg";
+			/* First reg region is System Configuration Device */
+			/* Second reg region is Debugger Interface Device */
+			/* Third reg region is System Glue Device */
+			reg = <0x400c3000 0x70
+			       0x400c3070 0x30
+			       0x400a5000 0x2000>;
+			reg-names = "scfg", "dbg", "glue";
+			#alt-cells = <3>;
+			#lvol-cells = <2>;
+		};
+
+		mdc: mdc@4000c000 {
+			compatible = "syscon";
+			reg = <0x4000c000 0xa>;
+			reg-io-width = <1>;
+		};
+
+		mdc_header: mdc@4000c00a {
+			compatible = "syscon";
+			reg = <0x4000c00a 0x4>;
+			reg-io-width = <2>;
+		};
+
+		miwu0: miwu@400bb000 {
+			compatible = "nuvoton,npcx-miwu";
+			reg = <0x400bb000 0x2000>;
+			index = <0>;
+			#miwu-cells = <2>;
+		};
+
+		miwu1: miwu@400bd000 {
+			compatible = "nuvoton,npcx-miwu";
+			reg = <0x400bd000 0x2000>;
+			index = <1>;
+			#miwu-cells = <2>;
+		};
+
+		miwu2: miwu@400bf000 {
+			compatible = "nuvoton,npcx-miwu";
+			reg = <0x400bf000 0x2000>;
+			index = <2>;
+			#miwu-cells = <2>;
+		};
+
+		gpio0: gpio@40081000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40081000 0x2000>;
+			gpio-controller;
+			index = <0x0>;
+			#gpio-cells=<2>;
+		};
+
+		gpio1: gpio@40083000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40083000 0x2000>;
+			gpio-controller;
+			index = <0x1>;
+			#gpio-cells=<2>;
+		};
+
+		gpio2: gpio@40085000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40085000 0x2000>;
+			gpio-controller;
+			index = <0x2>;
+			#gpio-cells=<2>;
+		};
+
+		gpio3: gpio@40087000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40087000 0x2000>;
+			gpio-controller;
+			index = <0x3>;
+			#gpio-cells=<2>;
+		};
+
+		gpio4: gpio@40089000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40089000 0x2000>;
+			gpio-controller;
+			index = <0x4>;
+			#gpio-cells=<2>;
+		};
+
+		gpio5: gpio@4008b000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4008b000 0x2000>;
+			gpio-controller;
+			index = <0x5>;
+			#gpio-cells=<2>;
+		};
+
+		gpio6: gpio@4008d000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4008d000 0x2000>;
+			gpio-controller;
+			index = <0x6>;
+			#gpio-cells=<2>;
+		};
+
+		gpio7: gpio@4008f000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4008f000 0x2000>;
+			gpio-controller;
+			index = <0x7>;
+			#gpio-cells=<2>;
+		};
+
+		gpio8: gpio@40091000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40091000 0x2000>;
+			gpio-controller;
+			index = <0x8>;
+			#gpio-cells=<2>;
+		};
+
+		gpio9: gpio@40093000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40093000 0x2000>;
+			gpio-controller;
+			index = <0x9>;
+			#gpio-cells=<2>;
+		};
+
+		gpioa: gpio@40095000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40095000 0x2000>;
+			gpio-controller;
+			index = <0xA>;
+			#gpio-cells=<2>;
+		};
+
+		gpiob: gpio@40097000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40097000 0x2000>;
+			gpio-controller;
+			index = <0xB>;
+			#gpio-cells=<2>;
+		};
+
+		gpioc: gpio@40099000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40099000 0x2000>;
+			gpio-controller;
+			index = <0xC>;
+			#gpio-cells=<2>;
+		};
+
+		gpiod: gpio@4009b000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4009b000 0x2000>;
+			gpio-controller;
+			index = <0xD>;
+			#gpio-cells=<2>;
+		};
+
+		gpioe: gpio@4009d000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4009d000 0x2000>;
+			gpio-controller;
+			index = <0xE>;
+			#gpio-cells=<2>;
+		};
+
+		gpiof: gpio@4009f000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4009f000 0x2000>;
+			gpio-controller;
+			index = <0xF>;
+			#gpio-cells=<2>;
+		};
+
+		pwm0: pwm@40080000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40080000 0x2000>;
+			pwm-channel = <0>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 0>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm1: pwm@40082000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40082000 0x2000>;
+			pwm-channel = <1>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 1>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm2: pwm@40084000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40084000 0x2000>;
+			pwm-channel = <2>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 2>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm3: pwm@40086000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40086000 0x2000>;
+			pwm-channel = <3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 3>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm4: pwm@40088000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40088000 0x2000>;
+			pwm-channel = <4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 4>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm5: pwm@4008a000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x4008a000 0x2000>;
+			pwm-channel = <5>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 5>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm6: pwm@4008c000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x4008c000 0x2000>;
+			pwm-channel = <6>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 6>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm7: pwm@4008e000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x4008e000 0x2000>;
+			pwm-channel = <7>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 7>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		adc0: adc@400d1000 {
+			compatible = "nuvoton,npcx-adc";
+			#io-channel-cells = <1>;
+			reg = <0x400d1000 0x2000>;
+			interrupts = <10 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB1 NPCX_PWDWN_CTL4 4>;
+			vref-mv = <2816>;
+			status = "disabled";
+		};
+
+		twd0: watchdog@400d8000 {
+			compatible = "nuvoton,npcx-watchdog";
+			reg = <0x400d8000 0x2000>;
+			t0-out = <&wui_t0out>;
+		};
+
+		espi0: espi@4000a000 {
+			compatible = "nuvoton,npcx-espi";
+			reg = <0x4000a000 0x2000>;
+			interrupts = <18 3>; /* Interrupt for eSPI Bus */
+
+			/* clocks for eSPI modules */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL6 7>;
+			/* WUI maps for eSPI signals */
+			espi-rst-wui = <&wui_espi_rst>;
+			rx-plsize = <64>;
+			tx-plsize = <16>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#vw-cells = <3>;
+			status = "disabled";
+		};
+
+		shi0: shi@4000f000 {
+			compatible = "nuvoton,npcx-shi";
+			reg = <0x4000f000 0x120>;
+			interrupts = <18 1>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 1>;
+			status = "disabled";
+			buffer-rx-size = <128>;
+			buffer-tx-size = <128>;
+		};
+
+		host_sub: lpc@400c1000 {
+			compatible = "nuvoton,npcx-host-sub";
+			/* host sub-module register address & size */
+			reg = <0x400c1000 0x2000
+			       0x40010000 0x2000
+			       0x4000e000 0x2000
+			       0x400c7000 0x2000
+			       0x400c9000 0x2000
+			       0x400cb000 0x2000>;
+			reg-names = "mswc", "shm", "c2h", "kbc", "pm_acpi",
+				    "pm_hcmd";
+
+			/* host sub-module IRQ and priority */
+			interrupts = <25 3>, /* KBC Input-Buf-Full (IBF) */
+				     <56 3>, /* KBC Output-Buf-Empty (OBE) */
+				     <26 3>, /* PMCH Input-Buf-Full (IBF) */
+				     <3 3>,  /* PMCH Output-Buf-Empty (OBE) */
+				     <6 3>;  /* Port80 FIFO Not Empty */
+			interrupt-names = "kbc_ibf", "kbc_obe", "pmch_ibf",
+					  "pmch_obe", "p80_fifo";
+
+			/* WUI map for accessing host sub-modules */
+			host-acc-wui = <&wui_host_acc>;
+
+			/* clocks for host sub-modules */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 3>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 4>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 5>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 6>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 7>;
+		};
+
+		/* I2c Controllers - Do not use them as i2c node directly */
+		i2c_ctrl0: i2c@40009000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40009000 0x1000>;
+			interrupts = <13 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL3 0>;
+			status = "disabled";
+		};
+
+		i2c_ctrl1: i2c@4000b000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x4000b000 0x1000>;
+			interrupts = <14 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL3 1>;
+			status = "disabled";
+		};
+
+		i2c_ctrl2: i2c@400c0000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x400c0000 0x1000>;
+			interrupts = <36 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL3 2>;
+			status = "disabled";
+		};
+
+		i2c_ctrl3: i2c@400c2000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x400c2000 0x1000>;
+			interrupts = <37 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL3 3>;
+			status = "disabled";
+		};
+
+		i2c_ctrl4: i2c@40008000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40008000 0x1000>;
+			interrupts = <19 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL3 4>;
+			status = "disabled";
+		};
+
+		i2c_ctrl5: i2c@40017000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40017000 0x1000>;
+			interrupts = <20 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL7 0>;
+			status = "disabled";
+		};
+
+		i2c_ctrl6: i2c@40018000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40018000 0x1000>;
+			interrupts = <16 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL7 1>;
+			status = "disabled";
+		};
+
+		i2c_ctrl7: i2c@40019000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40019000 0x1000>;
+			interrupts = <8 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL7 2>;
+			status = "disabled";
+		};
+
+		tach1: tach@400e1000 {
+			compatible = "nuvoton,npcx-tach";
+			reg = <0x400e1000 0x2000>;
+			clocks = <&pcc NPCX_CLOCK_BUS_LFCLK NPCX_PWDWN_CTL1 5>;
+			status = "disabled";
+		};
+
+		tach2: tach@400e3000 {
+			compatible = "nuvoton,npcx-tach";
+			reg = <0x400e3000 0x2000>;
+			clocks = <&pcc NPCX_CLOCK_BUS_LFCLK NPCX_PWDWN_CTL1 6>;
+			status = "disabled";
+		};
+
+		ps2_ctrl0: ps2@400b1000 {
+			compatible = "nuvoton,npcx-ps2-ctrl";
+			reg = <0x400b1000 0x1000>;
+			interrupts = <21 4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_FREERUN NPCX_PWDWN_CTL1 3>;
+
+			/* PS2 Channels - Please use them as PS2 node */
+			ps2_channel0: io_ps2_channel0 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x00>;
+				status = "disabled";
+			};
+
+			ps2_channel1: io_ps2_channel1 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x01>;
+				status = "disabled";
+			};
+
+			ps2_channel2: io_ps2_channel2 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x02>;
+				status = "disabled";
+			};
+
+			ps2_channel3: io_ps2_channel3 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x03>;
+				status = "disabled";
+			};
+		};
+
+		/* Dedicated Quad-SPI interface to access SPI flashes */
+		qspi_fiu0: quadspi@40020000 {
+			compatible = "nuvoton,npcx-fiu-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x40020000 0x2000>;
+		};
+
+		peci0: peci@400d4000 {
+			compatible = "nuvoton,npcx-peci";
+			reg = <0x400d4000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <4 4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_FMCLK NPCX_PWDWN_CTL4 5>;
+			status = "disabled";
+		};
+
+		kbd: kbd@400a3000 {
+			compatible = "nuvoton,npcx-kbd";
+			reg = <0x400a3000 0x2000>;
+			interrupts = <49 4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB1 NPCX_PWDWN_CTL1 0>;
+			wui-maps = <&wui_io31 &wui_io30 &wui_io27 &wui_io26
+				    &wui_io25 &wui_io24 &wui_io23 &wui_io22>;
+			status = "disabled";
+		};
+	};
+
+	soc-if {
+		/* Soc specific peripheral interface phandles which don't contain
+		 * 'reg' prop. Please overwrite 'status' prop. to 'okay' if you
+		 * want to switch the interface from io to specific peripheral.
+		 */
+		host_uart: io_host_uart {
+			compatible = "nuvoton,npcx-host-uart";
+			status = "disabled";
+		};
+
+		i2c0_0: io_i2c_ctrl0_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x00>;
+			controller = <&i2c_ctrl0>;
+			status = "disabled";
+		};
+
+		i2c1_0: io_i2c_ctrl1_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x10>;
+			controller = <&i2c_ctrl1>;
+			status = "disabled";
+		};
+
+		i2c2_0: io_i2c_ctrl2_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x20>;
+			controller = <&i2c_ctrl2>;
+			status = "disabled";
+		};
+
+		i2c3_0: io_i2c_ctrl3_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x30>;
+			controller = <&i2c_ctrl3>;
+			status = "disabled";
+		};
+
+		i2c4_1: io_i2c_ctrl4_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x41>;
+			controller = <&i2c_ctrl4>;
+			status = "disabled";
+		};
+
+		i2c5_0: io_i2c_ctrl5_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x50>;
+			controller = <&i2c_ctrl5>;
+			status = "disabled";
+		};
+
+		i2c5_1: io_i2c_ctrl5_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x51>;
+			controller = <&i2c_ctrl5>;
+			status = "disabled";
+		};
+
+		i2c6_0: io_i2c_ctrl6_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x60>;
+			controller = <&i2c_ctrl6>;
+			status = "disabled";
+		};
+
+		i2c6_1: io_i2c_ctrl6_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x61>;
+			controller = <&i2c_ctrl6>;
+			status = "disabled";
+		};
+
+		i2c7_0: io_i2c_ctrl7_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x70>;
+			controller = <&i2c_ctrl7>;
+			status = "disabled";
+		};
+
+		power_ctrl_psl: power-ctrl-psl {
+			compatible = "nuvoton,npcx-power-psl";
+			status = "disabled";
+		};
+	};
+
+	soc-id {
+		compatible = "nuvoton,npcx-soc-id";
+		family-id = <0x20>;
+	};
+
+	booter-variant {
+		compatible = "nuvoton,npcx-booter-variant";
+	};
+};
+
+&nvic {
+	arm,num-irq-priority-bits = <3>;
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4.dtsi b/dts/arm/nuvoton/npcx/npcx4.dtsi
new file mode 100644
index 0000000000..a01d5d69ab
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4.dtsi
@@ -0,0 +1,325 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* npcx4 series pinmux mapping table */
+#include "npcx4/npcx4-alts-map.dtsi"
+/* npcx4 series mapping table between MIWU wui bits and source device */
+#include "npcx4/npcx4-miwus-wui-map.dtsi"
+/* npcx4 series mapping table between MIWU groups and interrupts */
+#include "npcx4/npcx4-miwus-int-map.dtsi"
+/* npcx4 series eSPI VW mapping table */
+#include "npcx4/npcx4-espi-vws-map.dtsi"
+/* npcx4 series low-voltage io controls mapping table */
+#include "npcx4/npcx4-lvol-ctrl-map.dtsi"
+
+/* Device tree declarations of npcx soc family */
+#include "npcx.dtsi"
+
+/ {
+	def-io-conf-list {
+		pinmux = <&alt0_gpio_no_spip
+			  &alt0_gpio_no_fpip
+			  &alt1_no_pwrgd
+			  &alt7_no_ksi0_sl
+			  &alt7_no_ksi1_sl
+			  &alt7_no_ksi2_sl
+			  &alt7_no_ksi3_sl
+			  &alt7_no_ksi4_sl
+			  &alt7_no_ksi5_sl
+			  &alt7_no_ksi6_sl
+			  &alt7_no_ksi7_sl
+			  &alt8_no_kso00_sl
+			  &alt8_no_kso01_sl
+			  &alt8_no_kso02_sl
+			  &alt8_no_kso03_sl
+			  &alt8_no_kso04_sl
+			  &alt8_no_kso05_sl
+			  &alt8_no_kso06_sl
+			  &alt8_no_kso07_sl
+			  &alt9_no_kso08_sl
+			  &alt9_no_kso09_sl
+			  &alt9_no_kso10_sl
+			  &alt9_no_kso11_sl
+			  &alt9_no_kso12_sl
+			  &alt9_no_kso13_sl
+			  &alt9_no_kso14_sl
+			  &alt9_no_kso15_sl
+			  &alta_no_kso16_sl
+			  &alta_no_kso17_sl
+			  &alta_no_peci_en
+			  &altc_gpio97_sl_inv
+			  &altd_npsl_in1_sl
+			  &altd_npsl_in2_sl
+			  &altd_psl_in3_sl
+			  &altd_psl_in4_sl
+			  &altg_psl_gpo_sl>;
+	};
+
+	soc {
+		compatible = "nuvoton,npcx4", "nuvoton,npcx", "simple-bus";
+
+		/* Specific soc devices in npcx4 series */
+		itims: timer@400b0000 {
+			compatible = "nuvoton,npcx-itim-timer";
+			reg = <0x400b0000 0x2000
+			       0x400be000 0x2000>;
+			reg-names = "evt_itim", "sys_itim";
+			clocks = <&pcc NPCX_CLOCK_BUS_LFCLK NPCX_PWDWN_CTL4 0
+				  &pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL7 5>;
+			interrupts = <28 1>; /* Event timer interrupt */
+		};
+
+		uart1: serial@400e0000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E0000 0x2000>;
+			interrupts = <33 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL1 4>;
+			uart-rx = <&wui_cr_sin1>;
+			status = "disabled";
+		};
+
+		uart2: serial@400e2000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E2000 0x2000>;
+			interrupts = <32 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 6>;
+			uart-rx = <&wui_cr_sin2>;
+			status = "disabled";
+		};
+
+		uart3: serial@400e4000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E4000 0x2000>;
+			interrupts = <38 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 4>;
+			uart-rx = <&wui_cr_sin3>;
+			status = "disabled";
+		};
+
+		uart4: serial@400e6000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E6000 0x2000>;
+			interrupts = <39 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 3>;
+			uart-rx = <&wui_cr_sin4>;
+			status = "disabled";
+		};
+
+		/* Default clock and power settings in npcx4 series */
+		pcc: clock-controller@4000d000 {
+			clock-frequency = <DT_FREQ_M(120)>; /* OFMCLK runs at 120MHz */
+			core-prescaler = <8>; /* CORE_CLK runs at 15MHz */
+			apb1-prescaler = <8>; /* APB1_CLK runs at 15MHz */
+			apb2-prescaler = <8>; /* APB2_CLK runs at 15MHz */
+			apb3-prescaler = <8>; /* APB3_CLK runs at 15MHz */
+			apb4-prescaler = <8>; /* APB4_CLK runs at 15MHz */
+			ram-pd-depth = <8>; /* Valid bit-depth of RAM_PDn reg */
+			pwdwn-ctl-val = <0xfb
+					 0xff
+					 0x1f /* No GDMA1_PD/GDMA2_PD */
+					 0xff
+					 0xfa
+					 0x7f /* No ESPI_PD */
+					 0xff
+					 0xcf>; /* No FIU_PD */
+		};
+
+		/* Wake-up input source mapping for GPIOs in npcx4 series */
+		gpio0: gpio@40081000 {
+			wui-maps = <&wui_io00 &wui_io01 &wui_io02 &wui_io03
+				    &wui_io04 &wui_io05 &wui_io06 &wui_io07>;
+
+			lvol-maps = <&lvol_io00 &lvol_io01 &lvol_io02 &lvol_io03
+				     &lvol_io04 &lvol_io05 &lvol_io06 &lvol_io07>;
+		};
+
+		gpio1: gpio@40083000 {
+			wui-maps = <&wui_io10 &wui_io11 &wui_io12 &wui_io13
+				    &wui_io14 &wui_io15 &wui_io16 &wui_io17>;
+
+			lvol-maps = <&lvol_io10 &lvol_io11 &lvol_none &lvol_io13
+				     &lvol_io14 &lvol_io15 &lvol_io16 &lvol_io17>;
+		};
+
+		gpio2: gpio@40085000 {
+			wui-maps = <&wui_io20 &wui_io21 &wui_io22 &wui_io23
+				    &wui_io24 &wui_io25 &wui_io26 &wui_io27>;
+
+			lvol-maps = <&lvol_io20 &lvol_io21 &lvol_io22 &lvol_io23
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpio3: gpio@40087000 {
+			wui-maps = <&wui_io30 &wui_io31 &wui_none &wui_io33
+				    &wui_io34 &wui_none &wui_io36 &wui_io37>;
+
+			lvol-maps = <&lvol_none &lvol_none &lvol_none &lvol_io33
+				     &lvol_io34 &lvol_none &lvol_io36 &lvol_io37>;
+		};
+
+		gpio4: gpio@40089000 {
+			wui-maps = <&wui_io40 &wui_io41 &wui_io42 &wui_io43
+				    &wui_io44 &wui_io45 &wui_io46 &wui_io47>;
+
+			lvol-maps = <&lvol_io40 &lvol_io41 &lvol_io42 &lvol_io43
+				     &lvol_io44 &lvol_io45 &lvol_none &lvol_none>;
+		};
+
+		gpio5: gpio@4008b000 {
+			wui-maps = <&wui_io50 &wui_io51 &wui_io52 &wui_io53
+				    &wui_io54 &wui_io55 &wui_io56 &wui_io57>;
+
+			lvol-maps = <&lvol_io50 &lvol_none &lvol_none &lvol_none
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpio6: gpio@4008d000 {
+			wui-maps = <&wui_io60 &wui_io61 &wui_io62 &wui_io63
+				    &wui_io64 &wui_none &wui_io66 &wui_io67>;
+
+			lvol-maps = <&lvol_io60 &lvol_io61 &lvol_io62 &lvol_io63
+				     &lvol_io64 &lvol_none &lvol_io66 &lvol_io67>;
+		};
+
+		gpio7: gpio@4008f000 {
+			wui-maps = <&wui_io70 &wui_none &wui_io72 &wui_io73
+				    &wui_io74 &wui_io75 &wui_io76 &wui_none>;
+
+			lvol-maps = <&lvol_io70 &lvol_none &lvol_io72 &lvol_io73
+				     &lvol_io74 &lvol_io75 &lvol_io76 &lvol_none>;
+		};
+
+		gpio8: gpio@40091000 {
+			wui-maps = <&wui_io80 &wui_io81 &wui_io82 &wui_io83
+				    &wui_none &wui_none &wui_none &wui_io87>;
+
+			lvol-maps = <&lvol_io80 &lvol_none &lvol_io82 &lvol_io83
+				     &lvol_none &lvol_none &lvol_none &lvol_io87>;
+		};
+
+		gpio9: gpio@40093000 {
+			wui-maps = <&wui_io90 &wui_io91 &wui_io92 &wui_io93
+				    &wui_io94 &wui_io95 &wui_io96 &wui_io97>;
+
+			lvol-maps = <&lvol_io90 &lvol_io91 &lvol_io92 &lvol_none
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpioa: gpio@40095000 {
+			wui-maps = <&wui_ioa0 &wui_ioa1 &wui_ioa2 &wui_ioa3
+				    &wui_ioa4 &wui_ioa5 &wui_ioa6 &wui_ioa7>;
+
+			lvol-maps = <&lvol_none &lvol_none &lvol_none &lvol_none
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpiob: gpio@40097000 {
+			wui-maps = <&wui_iob0 &wui_iob1 &wui_iob2 &wui_iob3
+				    &wui_iob4 &wui_iob5 &wui_iob6 &wui_iob7>;
+
+			lvol-maps = <&lvol_none &lvol_iob1 &lvol_iob2 &lvol_iob3
+				     &lvol_iob4 &lvol_iob5 &lvol_iob6 &lvol_iob7>;
+		};
+
+		gpioc: gpio@40099000 {
+			wui-maps = <&wui_ioc0 &wui_ioc1 &wui_ioc2 &wui_ioc3
+				    &wui_ioc4 &wui_ioc5 &wui_ioc6 &wui_ioc7>;
+
+			lvol-maps = <&lvol_ioc0 &lvol_ioc1 &lvol_ioc2 &lvol_ioc3
+				     &lvol_ioc4 &lvol_ioc5 &lvol_ioc6 &lvol_ioc7>;
+		};
+
+		gpiod: gpio@4009b000 {
+			wui-maps = <&wui_iod0 &wui_iod1 &wui_iod2 &wui_iod3
+				    &wui_iod4 &wui_iod5 &wui_iod6 &wui_none>;
+
+			lvol-maps = <&lvol_iod0 &lvol_iod1 &lvol_iod2 &lvol_iod3
+				     &lvol_iod4 &lvol_iod5 &lvol_iod6 &lvol_none>;
+		};
+
+		gpioe: gpio@4009d000 {
+			wui-maps = <&wui_ioe0 &wui_ioe1 &wui_ioe2 &wui_ioe3
+				    &wui_ioe4 &wui_ioe5 &wui_none &wui_ioe7>;
+
+			lvol-maps = <&lvol_ioe0 &lvol_ioe1 &lvol_ioe2 &lvol_ioe3
+				     &lvol_ioe4 &lvol_ioe5 &lvol_none &lvol_ioe7>;
+		};
+
+		gpiof: gpio@4009f000 {
+			wui-maps = <&wui_iof0 &wui_iof1 &wui_iof2 &wui_iof3
+				    &wui_iof4 &wui_iof5 &wui_none &wui_none>;
+
+			lvol-maps = <&lvol_iof0 &lvol_iof1 &lvol_iof2 &lvol_iof3
+				     &lvol_iof4 &lvol_iof5 &lvol_none &lvol_none>;
+		};
+
+		/* ADC0 comparator configuration in npcx4 series */
+		adc0: adc@400d1000 {
+			channel-count = <26>;
+			threshold-count = <6>;
+		};
+
+		/* ADC1 which reference voltage is AVCC */
+		adc1: adc@400d5000 {
+			compatible = "nuvoton,npcx-adc";
+			#io-channel-cells = <1>;
+			reg = <0x400d5000 0x2000>;
+			interrupts = <22 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB1 NPCX_PWDWN_CTL4 3>;
+			vref-mv = <3300>;
+			channel-count = <26>;
+			threshold-count = <6>;
+			status = "disabled";
+		};
+
+		/* FIU0 configuration in npcx4 series */
+		qspi_fiu0: quadspi@40020000 {
+			clocks = <&pcc NPCX_CLOCK_BUS_FIU0 NPCX_PWDWN_CTL8 5>;
+		};
+
+		/* FIU1 configuration in npcx4 series */
+		qspi_fiu1: quadspi@40021000 {
+			compatible = "nuvoton,npcx-fiu-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x40021000 0x1000>;
+			clocks = <&pcc NPCX_CLOCK_BUS_FIU0 NPCX_PWDWN_CTL8 6>;
+		};
+
+		sha0: sha@13c {
+			compatible = "nuvoton,npcx-sha";
+			reg = <0x13c 0x3c>;
+			context-buffer-size = <228>;
+			status = "disabled";
+		};
+	};
+
+	soc-if {
+		i2c4_0: io_i2c_ctrl4_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x40>;
+			controller = <&i2c_ctrl4>;
+			status = "disabled";
+		};
+
+		i2c7_1: io_i2c_ctrl7_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x71>;
+			controller = <&i2c_ctrl7>;
+			status = "disabled";
+		};
+	};
+
+	soc-id {
+		family-id = <0x23>;
+		chip-id = <0x0a>;
+		revision-reg = <0x0000FFFC 4>;
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi
new file mode 100644
index 0000000000..b5e8c5b88a
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common pin-mux configurations in npcx family */
+#include <nuvoton/npcx/npcx-alts-map.dtsi>
+
+/* Specific pin-mux configurations in npcx4 series */
+/ {
+	npcx-alts-map {
+		compatible = "nuvoton,npcx-pinctrl-conf";
+
+		/* SCFG DEVALT 0 */
+		alt0_f_spi_cs1: alt04 {
+			alts = <&scfg 0x00 0x4 0>;
+		};
+		alt0_f_spi_quad: alt06 {
+			alts = <&scfg 0x00 0x6 0>;
+		};
+
+		/* SCFG DEVALT 2 */
+		alt2_i2c4_0_sl: alt27 {
+			alts = <&scfg 0x02 0x7 0>;
+		};
+
+		/* SCFG DEVALT 5 */
+		alt5_jen_lk: alt51 {
+			alts = <&scfg 0x05 0x1 0>;
+		};
+		alt5_gp_lk: alt57 {
+			alts = <&scfg 0x05 0x7 0>;
+		};
+
+		/* SCFG DEVALT E */
+		alte_cr_sin4_sl: alte6 {
+			alts = <&scfg 0x0E 0x6 0>;
+		};
+		alte_cr_sout4_sl: alte7 {
+			alts = <&scfg 0x0E 0x7 0>;
+		};
+
+		/* SCFG DEVALT F */
+		altf_adc10_sl: altf5 {
+			alts = <&scfg 0x0F 0x5 0>;
+		};
+		altf_adc11_sl: altf6 {
+			alts = <&scfg 0x0F 0x6 0>;
+		};
+
+		/* SCFG DEVALT A */
+		alta_32kclkin_sl: alta3 {
+			alts = <&scfg 0x0A 0x3 0>;
+		};
+
+		/* SCFG DEVALT C */
+		altc_gpio97_sl_inv: altc2-inv {
+			alts = <&scfg 0x0C 0x2 1>;
+		};
+
+		/* SCFG DEVALT F */
+		altf_adc12_sl: altf7 {
+			alts = <&scfg 0x0F 0x7 0>;
+		};
+
+		/* SCFG DEVALT G */
+		altg_vcc1_rst_pud: altg4 {
+			alts = <&scfg 0x10 0x4 0>;
+		};
+		altg_vcc1_rst_pud_lk: altg5 {
+			alts = <&scfg 0x10 0x5 0>;
+		};
+		altg_psl_out_sl: altg6 {
+			alts = <&scfg 0x10 0x6 0>;
+		};
+		altg_psl_gpo_sl: altg7 {
+			alts = <&scfg 0x10 0x7 0>;
+		};
+
+		/* SCFG DEVALT H */
+		alth_fcsi_typ: alth1 {
+			alts = <&scfg 0x11 0x1 0>;
+		};
+		alth_flm_quad: alth5 {
+			alts = <&scfg 0x11 0x5 0>;
+		};
+		alth_flm_mon_md: alth6-inv {
+			alts = <&scfg 0x11 0x6 1>;
+		};
+		alth_flm_sl: alth7 {
+			alts = <&scfg 0x11 0x7 0>;
+		};
+
+		/*
+		 * Note: DEVALT I is skipped in the datasheet, the offset of
+		 * DEVALT J is 0x12 not 0x13.
+		 */
+		/* SCFG DEVALT J */
+		altj_cr_sin1_sl1: altj0 {
+			alts = <&scfg 0x12 0x0 0>;
+		};
+		altj_cr_sout1_sl1: altj1 {
+			alts = <&scfg 0x12 0x1 0>;
+		};
+		altj_cr_sin1_sl2:  altj2 {
+			alts = <&scfg 0x12 0x2 0>;
+		};
+		altj_cr_sout1_sl2: altj3 {
+			alts = <&scfg 0x12 0x3 0>;
+		};
+		altj_cr_sin2_sl: altj4 {
+			alts = <&scfg 0x12 0x4 0>;
+		};
+		altj_cr_sout2_sl: altj5 {
+			alts = <&scfg 0x12 0x5 0>;
+		};
+		altj_cr_sin3_sl: altj6 {
+			alts = <&scfg 0x12 0x6 0>;
+		};
+		altj_cr_sout3_sl: altj7 {
+			alts = <&scfg 0x12 0x7 0>;
+		};
+
+		/* SCFG DEVALT K */
+		altk_i2c7_1_sl: altk7 {
+			alts = <&scfg 0x13 0x7 0>;
+		};
+
+		/* SCFG DEVALT L */
+		altl_adc13_sl: altl0 {
+			alts = <&scfg 0x14 0x0 0>;
+		};
+		altl_adc14_sl: altl1 {
+			alts = <&scfg 0x14 0x1 0>;
+		};
+		altl_adc15_sl:  altl2 {
+			alts = <&scfg 0x14 0x2 0>;
+		};
+		altl_adc16_sl: altl3 {
+			alts = <&scfg 0x14 0x3 0>;
+		};
+		altl_adc17_sl: altl4 {
+			alts = <&scfg 0x14 0x4 0>;
+		};
+		altl_adc18_sl: altl5 {
+			alts = <&scfg 0x14 0x5 0>;
+		};
+		altl_adc19_sl: altl6 {
+			alts = <&scfg 0x14 0x6 0>;
+		};
+		altl_adc20_sl: altl7 {
+			alts = <&scfg 0x14 0x7 0>;
+		};
+
+		/* SCFG DEVALT M */
+		altm_adc21_sl: altm0 {
+			alts = <&scfg 0x15 0x0 0>;
+		};
+		altm_adc22_sl: altm1 {
+			alts = <&scfg 0x15 0x1 0>;
+		};
+		altm_adc23_sl:  altm2 {
+			alts = <&scfg 0x15 0x2 0>;
+		};
+		altm_adc24_sl: altm3 {
+			alts = <&scfg 0x15 0x3 0>;
+		};
+		altm_adc25_sl: altm4 {
+			alts = <&scfg 0x15 0x4 0>;
+		};
+
+		/* SCFG DEVALT N */
+		altn_i3c1_sl: altn0 {
+			alts = <&scfg 0x16 0x0 0>;
+		};
+		altn_i3c2_sl: altn1 {
+			alts = <&scfg 0x16 0x1 0>;
+		};
+		altn_i3c3_sl:  altn2 {
+			alts = <&scfg 0x16 0x2 0>;
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi
new file mode 100644
index 0000000000..26a467f0a5
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common eSPI Virtual Wire (VW) mapping configurations in npcx family */
+#include <nuvoton/npcx/npcx-espi-vws-map.dtsi>
+
+/*
+ *   Specific eSPI Virtual Wire (VW) mapping configurations in npcx4 series
+ * |--------------------------------------------------------------------------|
+ * | VW idx | SLV reg | Wire Bit 3   | Wire Bit 2   | Wire Bit 1| Wire Bit 0  |
+ * |--------------------------------------------------------------------------|
+ * |       Output (Slave-to-Master) Virtual Wires (High at reset state)       |
+ * |--------------------------------------------------------------------------|
+ * | 50h[P] | VWGPSM0 | SLV_GPIO_3   | SLV_GPIO_2   | SLV_GPIO_1| SLV_GPIO_0  |
+ * | 51h[P] | VWGPSM1 | SLV_GPIO_7   | SLV_GPIO_6   | SLV_GPIO_5| SLV_GPIO_4  |
+ * |--------------------------------------------------------------------------|
+ *  [S] System-/[P] Platform-Specific Virtual Wires
+ */
+
+/ {
+	npcx-espi-vws-map {
+		compatible = "nuvoton,npcx-espi-vw-conf";
+
+		/*
+		 * Virtual wires for platform level usage (High at Reset state)
+		 */
+		/* index 50h (Out) */
+		vw_slv_gpio_0 {
+			vw-reg = <NPCX_VWGPSM0 0x01>;
+		};
+		vw_slv_gpio_1 {
+			vw-reg = <NPCX_VWGPSM0 0x02>;
+		};
+		vw_slv_gpio_2 {
+			vw-reg = <NPCX_VWGPSM0 0x04>;
+		};
+		vw_slv_gpio_3 {
+			vw-reg = <NPCX_VWGPSM0 0x08>;
+		};
+
+		/* index 51h (Out) */
+		vw_slv_gpio_4 {
+			vw-reg = <NPCX_VWGPSM1 0x01>;
+		};
+		vw_slv_gpio_5 {
+			vw-reg = <NPCX_VWGPSM1 0x02>;
+		};
+		vw_slv_gpio_6 {
+			vw-reg = <NPCX_VWGPSM1 0x04>;
+		};
+		vw_slv_gpio_7 {
+			vw-reg = <NPCX_VWGPSM1 0x08>;
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi
new file mode 100644
index 0000000000..e4a7a38798
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common Low-Voltage level configurations in npcx family */
+#include <nuvoton/npcx/npcx-lvol-ctrl-map.dtsi>
+
+/* Specific Low-Voltage level configurations in npcx4 series */
+/ {
+	def-lvol-conf-list {
+		compatible = "nuvoton,npcx-lvolctrl-conf";
+
+		/* Low-Voltage IO Control 1 */
+		lvol_io66: lvol17 {
+			lvols = <&scfg 1 7>;
+		};
+
+		/* Low-Voltage IO Control 2 */
+		lvol_ioe7: lvol26 {
+			lvols = <&scfg 2 6>;
+		};
+
+		/* Low-Voltage IO Control 5 */
+		lvol_io02: lvol54 {
+			lvols = <&scfg 5 4>;
+		};
+		lvol_io01: lvol55 {
+			lvols = <&scfg 5 5>;
+		};
+		lvol_ioe2: lvol56 {
+			lvols = <&scfg 5 6>;
+		};
+		lvol_iod6: lvol57 {
+			lvols = <&scfg 5 7>;
+		};
+
+		/* Low-Voltage IO Control 6 */
+		lvol_io03: lvol60 {
+			lvols = <&scfg 6 0>;
+		};
+		lvol_io05: lvol61 {
+			lvols = <&scfg 6 1>;
+		};
+		lvol_io04: lvol62 {
+			lvols = <&scfg 6 2>;
+		};
+		lvol_io06: lvol63 {
+			lvols = <&scfg 6 3>;
+		};
+		lvol_io07: lvol64 {
+			lvols = <&scfg 6 4>;
+		};
+		lvol_io10: lvol65 {
+			lvols = <&scfg 6 5>;
+		};
+		lvol_io11: lvol66 {
+			lvols = <&scfg 6 6>;
+		};
+		lvol_io13: lvol67 {
+			lvols = <&scfg 6 7>;
+		};
+
+		/* Low-Voltage IO Control 7 */
+		lvol_io14: lvol70 {
+			lvols = <&scfg 7 0>;
+		};
+		lvol_io15: lvol71 {
+			lvols = <&scfg 7 1>;
+		};
+		lvol_io16: lvol72 {
+			lvols = <&scfg 7 2>;
+		};
+		lvol_io17: lvol73 {
+			lvols = <&scfg 7 3>;
+		};
+		lvol_io20: lvol74 {
+			lvols = <&scfg 7 4>;
+		};
+		lvol_io21: lvol75 {
+			lvols = <&scfg 7 5>;
+		};
+		lvol_io22: lvol76 {
+			lvols = <&scfg 7 6>;
+		};
+		lvol_io23: lvol77 {
+			lvols = <&scfg 7 7>;
+		};
+
+		/* Low-Voltage IO Control 8 */
+		lvol_ioe0: lvol80 {
+			lvols = <&scfg 8 0>;
+		};
+		lvol_io41: lvol81 {
+			lvols = <&scfg 8 1>;
+		};
+		lvol_iof0: lvol82 {
+			lvols = <&scfg 8 2>;
+		};
+		lvol_io42: lvol83 {
+			lvols = <&scfg 8 3>;
+		};
+		lvol_io43: lvol84 {
+			lvols = <&scfg 8 4>;
+		};
+		lvol_io44: lvol85 {
+			lvols = <&scfg 8 5>;
+		};
+		lvol_io45: lvol86 {
+			lvols = <&scfg 8 6>;
+		};
+		lvol_ioe1: lvol87 {
+			lvols = <&scfg 8 7>;
+		};
+
+		/* Low-Voltage IO Control 9 */
+		lvol_iof1: lvol90 {
+			lvols = <&scfg 9 0>;
+		};
+		lvol_io61: lvol91 {
+			lvols = <&scfg 9 1>;
+		};
+		lvol_io62: lvol92 {
+			lvols = <&scfg 9 2>;
+		};
+		lvol_io63: lvol93 {
+			lvols = <&scfg 9 3>;
+		};
+		lvol_io67: lvol94 {
+			lvols = <&scfg 9 4>;
+		};
+		lvol_io70: lvol95 {
+			lvols = <&scfg 9 5>;
+		};
+		lvol_io76: lvol96 {
+			lvols = <&scfg 9 6>;
+		};
+		lvol_io83: lvol97 {
+			lvols = <&scfg 9 7>;
+		};
+
+		/* Low-Voltage IO Control A */
+		lvol_iob1: lvola0 {
+			lvols = <&scfg 10 0>;
+		};
+		lvol_iob6: lvola1 {
+			lvols = <&scfg 10 1>;
+		};
+		lvol_iob7: lvola2 {
+			lvols = <&scfg 10 2>;
+		};
+		lvol_ioc0: lvola3 {
+			lvols = <&scfg 10 3>;
+		};
+		lvol_ioc3: lvola4 {
+			lvols = <&scfg 10 4>;
+		};
+		lvol_ioc4: lvola5 {
+			lvols = <&scfg 10 5>;
+		};
+		lvol_iod2: lvola6 {
+			lvols = <&scfg 10 6>;
+		};
+		lvol_iod3: lvola7 {
+			lvols = <&scfg 10 7>;
+		};
+
+		/* Low-Voltage IO Control B */
+		lvol_iod4: lvolb0 {
+			lvols = <&scfg 11 0>;
+		};
+		lvol_iod5: lvolb1 {
+			lvols = <&scfg 11 1>;
+		};
+		lvol_ioe5: lvolb2 {
+			lvols = <&scfg 11 2>;
+		};
+		lvol_io60: lvolb7 {
+			lvols = <&scfg 11 7>;
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi
new file mode 100644
index 0000000000..d8c228b424
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common MIWU group-interrupt mapping configurations in npcx family */
+#include <nuvoton/npcx/npcx-miwus-int-map.dtsi>
+
+/* Specific MIWU group-interrupt mapping configurations in npcx4 series */
+/ {
+	/* Mapping between MIWU group and interrupts */
+	npcx-miwus-int-map {
+		map_miwu0_groups: map-miwu0-groups {
+			compatible = "nuvoton,npcx-miwu-int-map";
+			parent = <&miwu0>;
+
+			group_a0: group-a0-map {
+				irq        = <7>;
+				irq-prio   = <2>;
+				group-mask = <0x01>;
+			};
+			group_d0: group-d0-map {
+				irq        = <5>;
+				irq-prio   = <2>;
+				group-mask = <0x08>;
+			};
+			group_e0: group-e0-map {
+				irq        = <11>;
+				irq-prio   = <2>;
+				group-mask = <0x10>;
+			};
+			group_f0: group-f0-map {
+				irq        = <35>;
+				irq-prio   = <2>;
+				group-mask = <0x20>;
+			};
+			group_g0: group-g0-map {
+				irq        = <42>;
+				irq-prio   = <2>;
+				group-mask = <0x40>;
+			};
+			group_h0: group-h0-map {
+				irq        = <46>;
+				irq-prio   = <2>;
+				group-mask = <0x80>;
+			};
+		};
+
+		map_miwu2_groups: map-miwu2-groups {
+			compatible = "nuvoton,npcx-miwu-int-map";
+			parent = <&miwu2>;
+
+			group_e2: group-e2-map {
+				irq        = <64>;
+				irq-prio   = <2>;
+				group-mask = <0x10>;
+			};
+			group_f2: group-f2-map {
+				irq        = <59>;
+				irq-prio   = <2>;
+				group-mask = <0x20>;
+			};
+			group_g2: group-g2-map {
+				irq        = <55>;
+				irq-prio   = <2>;
+				group-mask = <0x40>;
+			};
+			group_h2: group-h2-map {
+				irq        = <82>;
+				irq-prio   = <2>;
+				group-mask = <0x80>;
+			};
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi
new file mode 100644
index 0000000000..ace5d4b156
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common Wake-Up Unit Input (WUI) mapping configurations in npcx family */
+#include <nuvoton/npcx/npcx-miwus-wui-map.dtsi>
+
+/* Specific Wake-Up Unit Input (WUI) mapping configurations in npcx4 series */
+/ {
+	/* Mapping between MIWU wui bits and source device */
+	npcx-miwus-wui-map {
+		compatible = "nuvoton,npcx-miwu-wui-map";
+
+		/* MIWU table 0 */
+		/* MIWU group H */
+		wui_ioe7: wui0-8-7 {
+			miwus = <&miwu0 7 7>; /* GPIOE7 */
+		};
+
+		/* MIWU table 1 */
+		/* MIWU group B */
+		wui_io13: wui1-2-3 {
+			miwus = <&miwu1 1 3>; /* GPIO13 */
+		};
+
+		/* MIWU group G */
+		wui_io66: wui1-7-6 {
+			miwus = <&miwu1 6 6>; /* GPIO66 */
+		};
+
+		/* MIWU table 2 */
+		/* MIWU group E */
+		wui_slp_msc: wui2-5-0 {
+			miwus = <&miwu2 4 0>; /* SLP_MSC */
+		};
+		wui_z8: wui2-5-1 {
+			miwus = <&miwu2 4 1>; /* Z8 */
+		};
+		wui_z9: wui2-5-2 {
+			miwus = <&miwu2 4 2>; /* Z9 */
+		};
+		wui_z10: wui2-5-3 {
+			miwus = <&miwu2 4 3>; /* Z10 */
+		};
+
+		/* MIWU group F */
+		wui_io12: wui2-6-0 {
+			miwus = <&miwu2 5 0>; /* GPIO12 */
+		};
+		wui_smb2: wui2-6-3 {
+			miwus = <&miwu2 5 3>; /* SMB2 */
+		};
+		wui_smb3: wui2-6-4 {
+			miwus = <&miwu2 5 4>; /* SMB3 */
+		};
+		wui_iod6: wui2-6-5 {
+			miwus = <&miwu2 5 5>; /* GPIOD6 */
+		};
+		wui_iob6: wui2-6-6 {
+			miwus = <&miwu2 5 6>; /* GPIOB6 */
+		};
+		wui_lct: wui2-6-7 {
+			miwus = <&miwu2 5 7>; /* LCT Event */
+		};
+
+		/* MIWU group G */
+		wui_cr_sin2: wui2-7-3 {
+			miwus = <&miwu2 6 3>; /* CR_SIN2 */
+		};
+		wui_cr_sin3: wui2-7-4 {
+			miwus = <&miwu2 6 4>; /* CR_SIN3 */
+		};
+		wui_cr_sin4: wui2-7-5 {
+			miwus = <&miwu2 6 5>; /* CR_SIN4 */
+		};
+		wui_i3c1_addrw: wui2-7-6 {
+			miwus = <&miwu2 6 6>; /* I3C1_ADDRW */
+		};
+		wui_i3c1_rstw: wui2-7-7 {
+			miwus = <&miwu2 6 7>; /* I3C1_RSTW */
+		};
+
+		/* MIWU group G */
+		wui_i3c2_addrw: wui2-8-0 {
+			miwus = <&miwu2 7 0>; /* I3C2_ADDRW */
+		};
+		wui_i3c2_rstw: wui2-8-1 {
+			miwus = <&miwu2 7 1>; /* I3C2_RSTW */
+		};
+		wui_i3c3_addrw: wui2-8-2 {
+			miwus = <&miwu2 7 2>; /* I3C3_ADDRW */
+		};
+		wui_i3c3_rstw: wui2-8-3 {
+			miwus = <&miwu2 7 3>; /* I3C3_RSTW */
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
new file mode 100644
index 0000000000..c795a41736
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
@@ -0,0 +1,558 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+&pinctrl {
+	/* Prebuild nodes for peripheral device's characteristics (Optional) */
+	/omit-if-no-ref/ vhif_lpc_sl: devctl-vhif-3p3v-lpc {
+		dev-ctl = <0x0 2 2 0x01>;
+	};
+
+	/omit-if-no-ref/ vhif_espi_shi_sl: devctl-vhif-1p8v-espi-shi {
+		dev-ctl = <0x0 2 2 0x02>;
+	};
+
+	/omit-if-no-ref/ vspi_3p3v_sl: devctl-vspi-3p3v {
+		dev-ctl = <0x0 4 2 0x01>;
+	};
+
+	/omit-if-no-ref/ vspi_1p8v_sl: devctl-vspi-1p8v {
+		dev-ctl = <0x0 4 2 0x02>;
+	};
+
+	/omit-if-no-ref/ ext_flash_tris_off: devctl-fiu-ext-tris-off {
+		dev-ctl = <0x0 6 1 0x00>;
+	};
+
+	/omit-if-no-ref/ ext_flash_tris_on: devctl-fiu-ext-tris-on {
+		dev-ctl = <0x0 6 1 0x01>;
+	};
+
+	/* Prebuild nodes for peripheral device's pin-muxing and pad properties */
+	/* Flash Interface Unit (FIU) */
+	/omit-if-no-ref/ fiu_ext_io0_io1_clk_cs_gpa4_96_a2_a0: periph-fiu-ext {
+		pinmux = <&alt0_gpio_no_fpip>;
+	};
+
+	/omit-if-no-ref/ fiu_ext_quad_io2_io3_gp93_a7: periph-fiu-ext-quad {
+		pinmux = <&alt0_f_spi_quad>;
+	};
+
+	/omit-if-no-ref/ ext_flash_cs1_sl: periph-ext-spi-flash-cs1 {
+		pinmux = <&alt0_f_spi_cs1>;
+	};
+
+	/* Host peripheral interfaces */
+	/omit-if-no-ref/ espi_lpc_gp46_47_51_52_53_54_55_57: periph-lpc-espi {
+		pinmux = <&alt1_no_lpc_espi>;
+	};
+
+	/* I2C peripheral interfaces */
+	/omit-if-no-ref/ i2c0_0_sda_scl_gpb4_b5: periph-i2c0-0 {
+		pinmux = <&alt2_i2c0_0_sl>;
+		periph-pupd = <0x00 0>;
+	};
+
+	/omit-if-no-ref/ i2c1_0_sda_scl_gp87_90: periph-i2c1-0 {
+		pinmux = <&alt2_i2c1_0_sl>;
+		periph-pupd = <0x00 2>;
+	};
+
+	/omit-if-no-ref/ i2c2_0_sda_scl_gp91_92: periph-i2c2-0 {
+		pinmux = <&alt2_i2c2_0_sl>;
+		periph-pupd = <0x00 4>;
+	};
+
+	/omit-if-no-ref/ i2c3_0_sda_scl_gpd0_d1: periph-i2c3-0 {
+		pinmux = <&alt2_i2c3_0_sl>;
+		periph-pupd = <0x00 6>;
+	};
+
+	/omit-if-no-ref/ i2c4_0_sda_scl_gp75_86: periph-i2c4-0 {
+		pinmux = <&alt2_i2c4_0_sl>;
+		periph-pupd = <0x00 7>;
+	};
+
+	/omit-if-no-ref/ i2c4_1_sda_scl_gpf2_f3: periph-i2c4-1 {
+		pinmux = <&alt6_i2c4_1_sl>;
+		periph-pupd = <0x01 2>;
+	};
+
+	/omit-if-no-ref/ i2c5_0_sda_scl_gp33_36: periph-i2c5-0 {
+		pinmux = <&alt2_i2c5_0_sl>;
+		periph-pupd = <0x00 5>;
+	};
+
+	/omit-if-no-ref/ i2c5_1_sda_scl_gpf4_f5: periph-i2c5-1 {
+		pinmux = <&alt6_i2c5_1_sl>;
+		periph-pupd = <0x01 1>;
+	};
+
+	/omit-if-no-ref/ i2c6_0_sda_scl_gpc1_c2: periph-i2c6-0 {
+		pinmux = <&alt2_i2c6_0_sl>;
+		periph-pupd = <0x00 3>;
+	};
+
+	/omit-if-no-ref/ i2c6_1_sda_scl_gpe3_e4: periph-i2c6-1 {
+		pinmux = <&alt6_i2c6_1_sl>;
+		periph-pupd = <0x01 0>;
+	};
+
+	/omit-if-no-ref/ i2c7_0_sda_scl_gpb2_b3: periph-i2c7-0 {
+		pinmux = <&alt2_i2c7_0_sl>;
+		periph-pupd = <0x00 1>;
+	};
+
+	/omit-if-no-ref/ i2c7_1_sda_scl_gpb7_c0: periph-i2c7-1 {
+		pinmux = <&altk_i2c7_1_sl>;
+		periph-pupd = <0x01 3>;
+	};
+
+	/* PS2 peripheral interfaces */
+	/omit-if-no-ref/ ps2_0_dat_clk_gp67_70: periph-ps2-0 {
+		pinmux = <&alt3_ps2_0_sl>;
+	};
+
+	/omit-if-no-ref/ ps2_1_dat_clk_gp62_63: periph-ps2-1 {
+		pinmux = <&alt3_ps2_1_sl>;
+	};
+
+	/omit-if-no-ref/ ps2_2_dat_clk_gp34_37: periph-ps2-2 {
+		pinmux = <&alt3_ps2_2_sl>;
+	};
+
+	/omit-if-no-ref/ ps2_3_2_dat_clk_gpa6_a7: periph-ps2-3-2 {
+		pinmux = <&altc_ps2_3_sl2>;
+	};
+
+	/* Tachometer peripheral interfaces */
+	/omit-if-no-ref/ ta1_1_in_gp40: periph-ta1-1 {
+		pinmux = <&alt3_ta1_sl1>;
+	};
+
+	/omit-if-no-ref/ ta1_2_in_gp93: periph-ta1-2 {
+		pinmux = <&altc_ta1_sl2>;
+	};
+
+	/omit-if-no-ref/ ta2_1_in_gp73: periph-ta2-1 {
+		pinmux = <&alt3_ta2_sl1>;
+	};
+
+	/omit-if-no-ref/ ta2_2_in_gpa6: periph-ta2-2 {
+		pinmux = <&altc_ta2_sl2>;
+	};
+
+	/omit-if-no-ref/ tb1_1_in_gpa4: periph-tb1-1 {
+		pinmux = <&alt3_tb1_sl1>;
+	};
+
+	/omit-if-no-ref/ tb1_2_in_gpd3: periph-tb1-2 {
+		pinmux = <&altc_tb1_sl2>;
+	};
+
+	/omit-if-no-ref/ tb2_2_in_gpa7: periph-tb2-2 {
+		pinmux = <&altc_tb2_sl2>;
+	};
+
+	/* PWM peripheral interfaces */
+	/omit-if-no-ref/ pwm0_gpc3: periph-pwm0 {
+		pinmux = <&alt4_pwm0_sl>;
+	};
+
+	/omit-if-no-ref/ pwm1_gpc2: periph-pwm1 {
+		pinmux = <&alt4_pwm1_sl>;
+	};
+
+	/omit-if-no-ref/ pwm2_gpc4: periph-pwm2 {
+		pinmux = <&alt4_pwm2_sl>;
+	};
+
+	/omit-if-no-ref/ pwm3_gp80: periph-pwm3 {
+		pinmux = <&alt4_pwm3_sl>;
+	};
+
+	/omit-if-no-ref/ pwm4_gpb6: periph-pwm4 {
+		pinmux = <&alt4_pwm4_sl>;
+	};
+
+	/omit-if-no-ref/ pwm5_gpb7: periph-pwm5 {
+		pinmux = <&alt4_pwm5_sl>;
+	};
+
+	/omit-if-no-ref/ pwm6_gpc0: periph-pwm6 {
+		pinmux = <&alt4_pwm6_sl>;
+	};
+
+	/omit-if-no-ref/ pwm7_gp60: periph-pwm7 {
+		pinmux = <&alt4_pwm7_sl>;
+	};
+
+	/* Keyboard peripheral interfaces. */
+	/omit-if-no-ref/ ksi0_gp31: periph-kbscan-ksi0 {
+		pinmux = <&alt7_no_ksi0_sl>;
+	};
+
+	/omit-if-no-ref/ ksi1_gp30: periph-kbscan-ksi1 {
+		pinmux = <&alt7_no_ksi1_sl>;
+	};
+
+	/omit-if-no-ref/ ksi2_gp27: periph-kbscan-ksi2 {
+		pinmux = <&alt7_no_ksi2_sl>;
+	};
+
+	/omit-if-no-ref/ ksi3_gp26: periph-kbscan-ksi3 {
+		pinmux = <&alt7_no_ksi3_sl>;
+	};
+
+	/omit-if-no-ref/ ksi4_gp25: periph-kbscan-ksi4 {
+		pinmux = <&alt7_no_ksi4_sl>;
+	};
+
+	/omit-if-no-ref/ ksi5_gp24: periph-kbscan-ksi5 {
+		pinmux = <&alt7_no_ksi5_sl>;
+	};
+
+	/omit-if-no-ref/ ksi6_gp23: periph-kbscan-ksi6 {
+		pinmux = <&alt7_no_ksi6_sl>;
+	};
+
+	/omit-if-no-ref/ ksi7_gp22: periph-kbscan-ksi7 {
+		pinmux = <&alt7_no_ksi7_sl>;
+	};
+
+	/omit-if-no-ref/ kso00_gp21: periph-kbscan-kso00 {
+		pinmux = <&alt8_no_kso00_sl>;
+	};
+
+	/omit-if-no-ref/ kso01_gp20: periph-kbscan-kso01 {
+		pinmux = <&alt8_no_kso01_sl>;
+	};
+
+	/omit-if-no-ref/ kso02_gp17: periph-kbscan-kso02 {
+		pinmux = <&alt8_no_kso02_sl>;
+	};
+
+	/omit-if-no-ref/ kso03_gp16: periph-kbscan-kso03 {
+		pinmux = <&alt8_no_kso03_sl>;
+	};
+
+	/omit-if-no-ref/ kso04_gp15: periph-kbscan-kso04 {
+		pinmux = <&alt8_no_kso04_sl>;
+	};
+
+	/omit-if-no-ref/ kso05_gp14: periph-kbscan-kso05 {
+		pinmux = <&alt8_no_kso05_sl>;
+	};
+
+	/omit-if-no-ref/ kso06_gp13: periph-kbscan-kso06 {
+		pinmux = <&alt8_no_kso06_sl>;
+	};
+
+	/omit-if-no-ref/ kso07_gp12: periph-kbscan-kso07 {
+		pinmux = <&alt8_no_kso07_sl>;
+	};
+
+	/omit-if-no-ref/ kso08_gp11: periph-kbscan-kso08 {
+		pinmux = <&alt9_no_kso08_sl>;
+	};
+
+	/omit-if-no-ref/ kso09_gp10: periph-kbscan-kso09 {
+		pinmux = <&alt9_no_kso09_sl>;
+	};
+
+	/omit-if-no-ref/ kso10_gp07: periph-kbscan-kso10 {
+		pinmux = <&alt9_no_kso10_sl>;
+	};
+
+	/omit-if-no-ref/ kso11_gp06: periph-kbscan-kso11 {
+		pinmux = <&alt9_no_kso11_sl>;
+	};
+
+	/omit-if-no-ref/ kso12_gp05: periph-kbscan-kso12 {
+		pinmux = <&alt9_no_kso12_sl>;
+	};
+
+	/omit-if-no-ref/ kso13_gp04: periph-kbscan-kso13 {
+		pinmux = <&alt9_no_kso13_sl>;
+	};
+
+	/omit-if-no-ref/ kso14_gp82: periph-kbscan-kso14 {
+		pinmux = <&alt9_no_kso14_sl>;
+	};
+
+	/omit-if-no-ref/ kso15_gp83: periph-kbscan-kso15 {
+		pinmux = <&alt9_no_kso15_sl>;
+	};
+
+	/omit-if-no-ref/ kso16_gp03: periph-kbscan-kso16 {
+		pinmux = <&alta_no_kso16_sl>;
+	};
+
+	/omit-if-no-ref/ kso17_gpb1: periph-kbscan-kso17 {
+		pinmux = <&alta_no_kso17_sl>;
+	};
+
+	/* Miscellaneous peripheral interfaces */
+	/omit-if-no-ref/ clk_32k_out_gp75: periph-clk-32k-out {
+		pinmux = <&alta_32k_out_sl>;
+	};
+
+	/omit-if-no-ref/ clk_32k_in_gpe7: periph-clk-32k-in {
+		pinmux = <&alta_32kclkin_sl>;
+	};
+
+	/omit-if-no-ref/ vcc1_rst_gp77: periph-vcc1-rst {
+		pinmux = <&alta_no_vcc1_rst>;
+	};
+
+	/omit-if-no-ref/ peci_dat_gp81: periph-peci-dat {
+		pinmux = <&alta_no_peci_en>;
+	};
+
+	/* Host UART peripheral interfaces */
+	/omit-if-no-ref/ huart_rxd_gp75: periph-host-uart-rxd {
+		pinmux = <&altb_rxd_sl>;
+	};
+
+	/omit-if-no-ref/ huart_txd_gp86: periph-host-uart-txd {
+		pinmux = <&altb_txd_sl>;
+	};
+
+	/omit-if-no-ref/ huart_rts_gp36: periph-host-uart-rts {
+		pinmux = <&altb_rts_sl>;
+	};
+
+	/omit-if-no-ref/ huart_cts_gp33: periph-host-uart-cts {
+		pinmux = <&altb_cts_sl>;
+	};
+
+	/omit-if-no-ref/ huart_ri_gp42: periph-host-uart-ri {
+		pinmux = <&altb_ri_sl>;
+	};
+
+	/omit-if-no-ref/ huart_dtr_bout_gpc7: periph-host-uart-dtr_bout {
+		pinmux = <&altb_dtr_bout_sl>;
+	};
+
+	/omit-if-no-ref/ huart_dcd_gpb3: periph-host-uart-dcd {
+		pinmux = <&altb_dcd_sl>;
+	};
+
+	/omit-if-no-ref/ huart_dsr_gpb2: periph-host-uart-dsr {
+		pinmux = <&altb_dsr_sl>;
+	};
+
+	/* SHI peripheral interfaces */
+	/omit-if-no-ref/ shi_gp46_47_53_55: periph-shi {
+		pinmux = <&altc_shi_sl>;
+		periph-pupd = <0x01 4>;
+	};
+
+	/* FLM peripheral interfaces */
+	/omit-if-no-ref/ flm_gp96_a0_a2_a4: periph-flm {
+		pinmux = <&alth_flm_sl>;
+	};
+
+	/omit-if-no-ref/ flm_quad_gp93_a7: periph-flm-quad {
+		pinmux = <&alth_flm_quad>;
+	};
+
+	/omit-if-no-ref/ flm_mon_md_gpd6: periph-flm-mon-md {
+		pinmux = <&alth_flm_mon_md>;
+	};
+
+
+	/* ADC peripheral interfaces. */
+	/omit-if-no-ref/ adc0_chan0_gp45: periph-adc0-0 {
+		pinmux = <&alt6_adc0_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan1_gp44: periph-adc0-1 {
+		pinmux = <&alt6_adc1_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan2_gp43: periph-adc0-2 {
+		pinmux = <&alt6_adc2_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan3_gp42: periph-adc0-3 {
+		pinmux = <&alt6_adc3_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan4_gp41: periph-adc0-4 {
+		pinmux = <&alt6_adc4_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan5_gp37: periph-adc0-5 {
+		pinmux = <&altf_adc5_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan6_gp34: periph-adc0-6 {
+		pinmux = <&altf_adc6_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan7_gpe1: periph-adc0-7 {
+		pinmux = <&altf_adc7_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan8_gpf1: periph-adc0-8 {
+		pinmux = <&altf_adc8_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan9_gpf0: periph-adc0-9 {
+		pinmux = <&altf_adc9_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan10_gpe0: periph-adc0-10 {
+		pinmux = <&altf_adc10_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan11_gpc7: periph-adc0-11 {
+		pinmux = <&altf_adc11_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan12_gp24: periph-adc0-12 {
+		pinmux = <&altf_adc12_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan13_gp26: periph-adc0-13 {
+		pinmux = <&altl_adc13_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan14_gp27: periph-adc0-14 {
+		pinmux = <&altl_adc14_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan15_gp31: periph-adc0-15 {
+		pinmux = <&altl_adc15_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan16_gp62: periph-adc0-16 {
+		pinmux = <&altl_adc16_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan17_gp63: periph-adc0-17 {
+		pinmux = <&altl_adc17_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan18_gp67: periph-adc0-18 {
+		pinmux = <&altl_adc18_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan19_gp70: periph-adc0-19 {
+		pinmux = <&altl_adc19_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan20_gp22: periph-adc0-20 {
+		pinmux = <&altl_adc20_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan21_gp23: periph-adc0-21 {
+		pinmux = <&altm_adc21_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan22_gpc1: periph-adc0-22 {
+		pinmux = <&altm_adc22_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan23_gp74: periph-adc0-23 {
+		pinmux = <&altm_adc23_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan24_gp25: periph-adc0-24 {
+		pinmux = <&altm_adc24_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan25_gp30: periph-adc0-25 {
+		pinmux = <&altm_adc25_sl>;
+	};
+
+	/* PSL peripheral interfaces */
+	/omit-if-no-ref/ psl_in1_gpd2: periph-psl-in1 {
+		pinmux = <&altd_npsl_in1_sl>;
+		psl-offset = <0>;
+		psl-polarity = <&altd_psl_in1_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_in2_gp00: periph-psl-in2 {
+		pinmux = <&altd_npsl_in2_sl>;
+		psl-offset = <1>;
+		psl-polarity = <&altd_psl_in2_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_in3_gp01: periph-psl-in3 {
+		pinmux = <&altd_psl_in3_sl>;
+		psl-offset = <2>;
+		psl-polarity = <&altd_psl_in3_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_in4_gp02: periph-psl-in4 {
+		pinmux = <&altd_psl_in4_sl>;
+		psl-offset = <3>;
+		psl-polarity = <&altd_psl_in4_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_gpo_gpd7: periph-psl-gpo {
+		pinmux = <&altg_psl_gpo_sl>;
+	};
+
+	/omit-if-no-ref/ psl_out_gp85: periph-psl-out {
+		pinmux = <&altg_psl_out_sl>;
+	};
+
+	/* I3C peripheral interfaces */
+	/omit-if-no-ref/ i3c1_sda_scl_gpe3_e4: periph-i3c1 {
+		pinmux = <&altn_i3c1_sl>;
+	};
+
+	/omit-if-no-ref/ i3c2_sda_scl_gp50_56: periph-i3c2 {
+		pinmux = <&altn_i3c2_sl>;
+	};
+
+	/omit-if-no-ref/ i3c3_sda_scl_gpf4_f5: periph-i3c3 {
+		pinmux = <&altn_i3c3_sl>;
+	};
+
+	/* UART peripheral interfaces */
+	/omit-if-no-ref/ uart1_1_sin_gp10: periph-uart1-1-sin {
+		pinmux = <&altj_cr_sin1_sl1>;
+	};
+
+	/omit-if-no-ref/ uart1_1_sout_gp11: periph-uart1-1-sout {
+		pinmux = <&altj_cr_sout1_sl1>;
+	};
+
+	/omit-if-no-ref/ uart1_2_sin_gp64: periph-uart1-2-sin {
+		pinmux = <&altj_cr_sin1_sl2>;
+	};
+
+	/omit-if-no-ref/ uart1_2_sout_gp65: periph-uart1-2-sout {
+		pinmux = <&altj_cr_sout1_sl2>;
+	};
+
+	/omit-if-no-ref/ uart2_sin_gp75: periph-uart2-sin {
+		pinmux = <&altj_cr_sin2_sl>;
+	};
+
+	/omit-if-no-ref/ uart2_sout_gp86: periph-uart2-sout {
+		pinmux = <&altj_cr_sout2_sl>;
+	};
+
+	/omit-if-no-ref/ uart3_sin_gpd4: periph-uart3-sin {
+		pinmux = <&altj_cr_sin3_sl>;
+	};
+
+	/omit-if-no-ref/ uart3_sout_gpd6: periph-uart3-sout {
+		pinmux = <&altj_cr_sout3_sl>;
+	};
+
+	/omit-if-no-ref/ uart4_sin_gpb1: periph-uart4-sin {
+		pinmux = <&alte_cr_sin4_sl>;
+	};
+
+	/omit-if-no-ref/ uart4_sout_gp35: periph-uart4-sout {
+		pinmux = <&alte_cr_sout4_sl>;
+	};
+};
diff --git a/dts/arm/nuvoton/npcx4m3f.dtsi b/dts/arm/nuvoton/npcx4m3f.dtsi
new file mode 100644
index 0000000000..334cd2db65
--- /dev/null
+++ b/dts/arm/nuvoton/npcx4m3f.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <mem.h>
+#include "npcx/npcx4.dtsi"
+
+/ {
+	flash0: flash@10088000 {
+		reg = <0x10088000 DT_SIZE_K(224)>;
+	};
+
+	flash1: flash@60000000 {
+		reg = <0x60000000 DT_SIZE_K(512)>;
+	};
+
+	sram0: memory@200c0000 {
+		compatible = "mmio-sram";
+		reg = <0x200C0000 DT_SIZE_K(96)>;
+	};
+
+	soc-id {
+		device-id = <0x25>;
+	};
+};
+
+&qspi_fiu0 {
+	status = "okay";
+
+	int_flash: w25q40@0 {
+		compatible ="nuvoton,npcx-fiu-nor";
+		size = <DT_SIZE_K(512 * 8)>;
+		reg = <0>;
+		status = "okay";
+
+		/* quad spi bus configuration of nor flash device */
+		qspi-flags = <NPCX_QSPI_SW_CS0>;
+		mapped-addr = <0x60000000>;
+	};
+};
diff --git a/dts/arm/nuvoton/npcx4m8f.dtsi b/dts/arm/nuvoton/npcx4m8f.dtsi
new file mode 100644
index 0000000000..ac141ab31b
--- /dev/null
+++ b/dts/arm/nuvoton/npcx4m8f.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <mem.h>
+#include "npcx/npcx4.dtsi"
+
+/ {
+	flash0: flash@10060000 {
+		reg = <0x10060000 DT_SIZE_K(384)>;
+	};
+
+	flash1: flash@60000000 {
+		reg = <0x60000000 DT_SIZE_M(1)>;
+	};
+
+	sram0: memory@200c0000 {
+		compatible = "mmio-sram";
+		reg = <0x200C0000 DT_SIZE_K(114)>;
+	};
+
+	soc-id {
+		device-id = <0x23>;
+	};
+};
+
+&qspi_fiu0 {
+	status = "okay";
+
+	int_flash: w25q80@0 {
+		compatible ="nuvoton,npcx-fiu-nor";
+		size = <DT_SIZE_M(1 * 8)>;
+		reg = <0>;
+		status = "okay";
+
+		/* quad spi bus configuration of nor flash device */
+		qspi-flags = <NPCX_QSPI_SW_CS0>;
+		mapped-addr = <0x60000000>;
+	};
+};
diff --git a/dts/bindings/clock/nuvoton,npcx-pcc.yaml b/dts/bindings/clock/nuvoton,npcx-pcc.yaml
index 7f66dd0f90..c825390387 100644
--- a/dts/bindings/clock/nuvoton,npcx-pcc.yaml
+++ b/dts/bindings/clock/nuvoton,npcx-pcc.yaml
@@ -23,202 +23,207 @@ compatible: "nuvoton,npcx-pcc"
 include: [clock-controller.yaml, base.yaml]
 
 properties:
-    reg:
-        required: true
+  reg:
+    required: true
 
-    clock-frequency:
-        required: true
-        type: int
-        description: |
-          Default frequency in Hz for HFCG output clock (OFMCLK). Currently,
-          only the following values are allowed:
-            100000000, 100 MHz
-            96000000, 96 MHz
-            90000000, 90 MHz
-            80000000, 80 MHz
-            66000000, 66 MHz
-            50000000, 50 MHz
-            48000000, 48 MHz
-            40000000, 40 MHz (default value after reset)
-            33000000, 33 MHz
-        enum:
-          - 100000000
-          - 96000000
-          - 90000000
-          - 80000000
-          - 66000000
-          - 50000000
-          - 48000000
-          - 40000000
-          - 33000000
+  clock-frequency:
+    required: true
+    type: int
+    description: |
+      Default frequency in Hz for HFCG output clock (OFMCLK). Currently,
+      only the following values are allowed:
+        120000000, 120 MHz
+        100000000, 100 MHz
+        96000000, 96 MHz
+        90000000, 90 MHz
+        80000000, 80 MHz
+        66000000, 66 MHz
+        50000000, 50 MHz
+        48000000, 48 MHz
+    enum:
+      - 120000000
+      - 100000000
+      - 96000000
+      - 90000000
+      - 80000000
+      - 66000000
+      - 50000000
+      - 48000000
 
-    core-prescaler:
-        type: int
-        required: true
-        description: |
-          Core clock prescaler (FPRED). It sets the Core frequency, CORE_CLK, by
-          dividing OFMCLK(MCLK) and needs to meet the following requirements.
-          - CORE_CLK must be set to 4MHz <= CORE_CLK <= 100MHz.
-          = Only the following values are allowed:
-            1, CORE_CLK = OFMCLK
-            2, CORE_CLK = OFMCLK / 2
-            3, CORE_CLK = OFMCLK / 3
-            4, CORE_CLK = OFMCLK / 4
-            5, CORE_CLK = OFMCLK / 5
-            6, CORE_CLK = OFMCLK / 6
-            7, CORE_CLK = OFMCLK / 7
-            8, CORE_CLK = OFMCLK / 8
-            9, CORE_CLK = OFMCLK / 9
-            10, CORE_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  core-prescaler:
+    type: int
+    required: true
+    description: |
+      Core clock prescaler (FPRED). It sets the Core frequency, CORE_CLK, by
+      dividing OFMCLK(MCLK) and needs to meet the following requirements.
+      - CORE_CLK must be set to 4MHz <= CORE_CLK <= 100MHz.
+      = Only the following values are allowed:
+        1, CORE_CLK = OFMCLK
+        2, CORE_CLK = OFMCLK / 2
+        3, CORE_CLK = OFMCLK / 3
+        4, CORE_CLK = OFMCLK / 4
+        5, CORE_CLK = OFMCLK / 5
+        6, CORE_CLK = OFMCLK / 6
+        7, CORE_CLK = OFMCLK / 7
+        8, CORE_CLK = OFMCLK / 8
+        9, CORE_CLK = OFMCLK / 9
+        10, CORE_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb1-prescaler:
-        type: int
-        required: true
-        description: |
-          APB1 prescaler. It sets the APB1 bus frequency, APB1_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB1_CLK must be set to 4MHz <= APB1_CLK <= 50MHz.
-          - APB1_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB1_CLK = OFMCLK
-            2, APB1_CLK = OFMCLK / 2
-            3, APB1_CLK = OFMCLK / 3
-            4, APB1_CLK = OFMCLK / 4
-            5, APB1_CLK = OFMCLK / 5
-            6, APB1_CLK = OFMCLK / 6
-            7, APB1_CLK = OFMCLK / 7
-            8, APB1_CLK = OFMCLK / 8
-            9, APB1_CLK = OFMCLK / 9
-            10, APB1_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb1-prescaler:
+    type: int
+    required: true
+    description: |
+      APB1 prescaler. It sets the APB1 bus frequency, APB1_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB1_CLK must be set to 4MHz <= APB1_CLK <= 50MHz.
+      - APB1_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB1_CLK = OFMCLK
+        2, APB1_CLK = OFMCLK / 2
+        3, APB1_CLK = OFMCLK / 3
+        4, APB1_CLK = OFMCLK / 4
+        5, APB1_CLK = OFMCLK / 5
+        6, APB1_CLK = OFMCLK / 6
+        7, APB1_CLK = OFMCLK / 7
+        8, APB1_CLK = OFMCLK / 8
+        9, APB1_CLK = OFMCLK / 9
+        10, APB1_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb2-prescaler:
-        type: int
-        required: true
-        description: |
-          APB2 prescaler. It sets the APB2 bus frequency, APB2_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB2_CLK must be set to 8MHz <= APB2_CLK <= 50MHz.
-          - APB2_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB2_CLK = OFMCLK
-            2, APB2_CLK = OFMCLK / 2
-            3, APB2_CLK = OFMCLK / 3
-            4, APB2_CLK = OFMCLK / 4
-            5, APB2_CLK = OFMCLK / 5
-            6, APB2_CLK = OFMCLK / 6
-            7, APB2_CLK = OFMCLK / 7
-            8, APB2_CLK = OFMCLK / 8
-            9, APB2_CLK = OFMCLK / 9
-            10, APB2_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb2-prescaler:
+    type: int
+    required: true
+    description: |
+      APB2 prescaler. It sets the APB2 bus frequency, APB2_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB2_CLK must be set to 8MHz <= APB2_CLK <= 50MHz.
+      - APB2_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB2_CLK = OFMCLK
+        2, APB2_CLK = OFMCLK / 2
+        3, APB2_CLK = OFMCLK / 3
+        4, APB2_CLK = OFMCLK / 4
+        5, APB2_CLK = OFMCLK / 5
+        6, APB2_CLK = OFMCLK / 6
+        7, APB2_CLK = OFMCLK / 7
+        8, APB2_CLK = OFMCLK / 8
+        9, APB2_CLK = OFMCLK / 9
+        10, APB2_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb3-prescaler:
-        type: int
-        required: true
-        description: |
-          APB3 prescaler. It sets the APB3 bus frequency, APB3_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB3_CLK must be set to 12.5MHz <= APB3_CLK <= 50MHz.
-          - APB3_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB3_CLK = OFMCLK
-            2, APB3_CLK = OFMCLK / 2
-            3, APB3_CLK = OFMCLK / 3
-            4, APB3_CLK = OFMCLK / 4
-            5, APB3_CLK = OFMCLK / 5
-            6, APB3_CLK = OFMCLK / 6
-            7, APB3_CLK = OFMCLK / 7
-            8, APB3_CLK = OFMCLK / 8
-            9, APB3_CLK = OFMCLK / 9
-            10, APB3_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb3-prescaler:
+    type: int
+    required: true
+    description: |
+      APB3 prescaler. It sets the APB3 bus frequency, APB3_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB3_CLK must be set to 12.5MHz <= APB3_CLK <= 50MHz.
+      - APB3_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB3_CLK = OFMCLK
+        2, APB3_CLK = OFMCLK / 2
+        3, APB3_CLK = OFMCLK / 3
+        4, APB3_CLK = OFMCLK / 4
+        5, APB3_CLK = OFMCLK / 5
+        6, APB3_CLK = OFMCLK / 6
+        7, APB3_CLK = OFMCLK / 7
+        8, APB3_CLK = OFMCLK / 8
+        9, APB3_CLK = OFMCLK / 9
+        10, APB3_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb4-prescaler:
-        type: int
-        required: false
-        description: |
-          APB4 prescaler. It sets the APB4 bus frequency, APB4_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB4_CLK must be set to 8MHz <= APB4_CLK <= 50MHz.
-          - APB4_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB4_CLK = OFMCLK
-            2, APB4_CLK = OFMCLK / 2
-            3, APB4_CLK = OFMCLK / 3
-            4, APB4_CLK = OFMCLK / 4
-            5, APB4_CLK = OFMCLK / 5
-            6, APB4_CLK = OFMCLK / 6
-            7, APB4_CLK = OFMCLK / 7
-            8, APB4_CLK = OFMCLK / 8
-            9, APB4_CLK = OFMCLK / 9
-            10, APB4_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb4-prescaler:
+    type: int
+    required: false
+    description: |
+      APB4 prescaler. It sets the APB4 bus frequency, APB4_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB4_CLK must be set to 8MHz <= APB4_CLK <= 50MHz.
+      - APB4_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB4_CLK = OFMCLK
+        2, APB4_CLK = OFMCLK / 2
+        3, APB4_CLK = OFMCLK / 3
+        4, APB4_CLK = OFMCLK / 4
+        5, APB4_CLK = OFMCLK / 5
+        6, APB4_CLK = OFMCLK / 6
+        7, APB4_CLK = OFMCLK / 7
+        8, APB4_CLK = OFMCLK / 8
+        9, APB4_CLK = OFMCLK / 9
+        10, APB4_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    ram-pd-depth:
-        required: false
-        type: int
-        enum:
-          - 12
-          - 15
-        description: |
-          Valid bit-depth of RAM block Power-Down control (RAM_PD) registers.
-          Each bit in RAM_PDn can power down the relevant RAM block by setting
-          itself to 1 for better power consumption and this valid bit-depth
-          varies in different NPCX series.
+  ram-pd-depth:
+    type: int
+    enum:
+      - 8
+      - 12
+      - 15
+    description: |
+      Valid bit-depth of RAM block Power-Down control (RAM_PD) registers.
+      Each bit in RAM_PDn can power down the relevant RAM block by setting
+      itself to 1 for better power consumption and this valid bit-depth
+      varies in different NPCX series.
+
+  pwdwn-ctl-val:
+    type: array
+    required: true
+    description: |
+      Power-down (turn off clock) the modules during system initialization for
+      better power consumption.
 
 clock-cells:
-    - bus
-    - ctl
-    - bit
+  - bus
+  - ctl
+  - bit
diff --git a/dts/bindings/espi/nuvoton,npcx-espi.yaml b/dts/bindings/espi/nuvoton,npcx-espi.yaml
index eb5cd9bdb6..61f0057358 100644
--- a/dts/bindings/espi/nuvoton,npcx-espi.yaml
+++ b/dts/bindings/espi/nuvoton,npcx-espi.yaml
@@ -8,25 +8,35 @@ compatible: "nuvoton,npcx-espi"
 include: [espi-controller.yaml, pinctrl-device.yaml]
 
 properties:
-    reg:
-      description: mmio register space
-      required: true
-
-    clocks:
-        required: true
-        description: configurations of device source clock controller
-
-    pinctrl-0:
-        required: true
-
-    pinctrl-names:
-        required: true
-
-    espi-rst-wui:
-        type: phandle
-        required: true
-        description: |
-            Mapping table between Wake-Up Input (WUI) and ESPI_RST signal.
-
-            For example the WUI mapping on NPCX7 would be
-               espi-rst-wui = <&wui_cr_sin1>;
+  reg:
+    description: mmio register space
+    required: true
+
+  clocks:
+    required: true
+    description: configurations of device source clock controller
+
+  pinctrl-0:
+    required: true
+
+  pinctrl-names:
+    required: true
+
+  espi-rst-wui:
+    type: phandle
+    required: true
+    description: |
+        Mapping table between Wake-Up Input (WUI) and ESPI_RST signal.
+
+        For example the WUI mapping on NPCX7 would be
+           espi-rst-wui = <&wui_cr_sin1>;
+
+  rx-plsize:
+    type: int
+    required: true
+    description: The amount of flash receive buffer register.
+
+  tx-plsize:
+    type: int
+    required: true
+    description: The amount of flash transmit buffer register.
diff --git a/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml b/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml
index 17414926b2..50d37d19d8 100644
--- a/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml
+++ b/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml
@@ -8,26 +8,26 @@ compatible: "nuvoton,npcx-adc"
 include: [adc-controller.yaml, pinctrl-device.yaml]
 
 properties:
-    reg:
-        required: true
-    clocks:
-        required: true
-    pinctrl-0:
-        required: true
-    pinctrl-names:
-        required: true
-    channel-count:
-        type: int
-        required: true
-        description: the number of ADC channels
-    threshold-reg-offset:
-        type: int
-        required: true
-        description: the offset of threshold detector register address
-    threshold-count:
-        type: int
-        required: true
-        description: the number of threshold detectors adc supports
+  reg:
+    required: true
+  clocks:
+    required: true
+  pinctrl-0:
+    required: true
+  pinctrl-names:
+    required: true
+  vref-mv:
+    type: int
+    required: true
+    description: ADC reference voltage (Unit:mV)
+  channel-count:
+    type: int
+    required: true
+    description: the number of ADC channels
+  threshold-count:
+    type: int
+    required: true
+    description: the number of threshold detectors adc supports
 
 io-channel-cells:
-    - input
+  - input
diff --git a/include/zephyr/dt-bindings/clock/npck_clock.h b/include/zephyr/dt-bindings/clock/npck_clock.h
new file mode 100644
index 0000000000..9d5a3d4809
--- /dev/null
+++ b/include/zephyr/dt-bindings/clock/npck_clock.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2020 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_CLOCK_H_
+#define ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_CLOCK_H_
+
+/* clock bus references */
+#define NPCX_CLOCK_BUS_FREERUN     0
+#define NPCX_CLOCK_BUS_LFCLK       1
+#define NPCX_CLOCK_BUS_OSC         2
+#define NPCX_CLOCK_BUS_FIU         3
+#define NPCX_CLOCK_BUS_CORE        4
+#define NPCX_CLOCK_BUS_APB1        5
+#define NPCX_CLOCK_BUS_APB2        6
+#define NPCX_CLOCK_BUS_APB3        7
+#define NPCX_CLOCK_BUS_APB4        8
+#define NPCX_CLOCK_BUS_AHB6        9
+#define NPCX_CLOCK_BUS_FMCLK       10
+
+/* clock enable/disable references */
+#define NPCX_PWDWN_CTL0            0
+#define NPCX_PWDWN_CTL1            1
+#define NPCX_PWDWN_CTL2            2
+#define NPCX_PWDWN_CTL3            3
+#define NPCX_PWDWN_CTL4            4
+#define NPCX_PWDWN_CTL5            5
+#define NPCX_PWDWN_CTL6            6
+#define NPCX_PWDWN_CTL_COUNT       7
+
+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCX_CLOCK_H_ */
diff --git a/include/zephyr/dt-bindings/clock/npcx_clock.h b/include/zephyr/dt-bindings/clock/npcx_clock.h
index adca438f2d..713a05c572 100644
--- a/include/zephyr/dt-bindings/clock/npcx_clock.h
+++ b/include/zephyr/dt-bindings/clock/npcx_clock.h
@@ -18,6 +18,8 @@
 #define NPCX_CLOCK_BUS_APB4        8
 #define NPCX_CLOCK_BUS_AHB6        9
 #define NPCX_CLOCK_BUS_FMCLK       10
+#define NPCX_CLOCK_BUS_FIU0        NPCX_CLOCK_BUS_FIU
+#define NPCX_CLOCK_BUS_FIU1        11
 
 /* clock enable/disable references */
 #define NPCX_PWDWN_CTL1            0
diff --git a/include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h b/include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h
new file mode 100644
index 0000000000..99dec3c5f2
--- /dev/null
+++ b/include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_FIU_QSPI_H_
+#define ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_FIU_QSPI_H_
+
+#include <zephyr/dt-bindings/dt-util.h>
+
+/* Software controlled Chip-Select number for UMA transactions */
+#define NPCX_QSPI_SW_CS0	BIT(0)
+#define NPCX_QSPI_SW_CS1	BIT(1)
+#define NPCX_QSPI_SW_CS2	BIT(2)
+#define NPCX_QSPI_SW_CS_MASK	(NPCX_QSPI_SW_CS0 | NPCX_QSPI_SW_CS1 | NPCX_QSPI_SW_CS2)
+
+/* Supported flash interfaces for UMA transactions */
+#define NPCX_QSPI_SEC_FLASH_SL	BIT(4)
+#define NPCX_QSPI_PVT_FLASH_SL	BIT(5)
+#define NPCX_QSPI_SHD_FLASH_SL	BIT(6)
+#define NPCX_QSPI_BKP_FLASH_SL	BIT(7)
+
+/* Supported read mode for Direct Read Access */
+#define NPCX_RD_MODE_NORMAL	0
+#define NPCX_RD_MODE_FAST	1
+#define NPCX_RD_MODE_FAST_DUAL	3
+
+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_FIU_QSPI_H_ */
diff --git a/include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h b/include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h
new file mode 100644
index 0000000000..70d20ee629
--- /dev/null
+++ b/include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2022 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_GPIO_NUVOTON_NPCX_GPIO_H_
+#define ZEPHYR_INCLUDE_DT_BINDINGS_GPIO_NUVOTON_NPCX_GPIO_H_
+
+/**
+ * @name GPIO pin voltage flags
+ *
+ * The voltage flags are a Zephyr specific extension of the standard GPIO flags
+ * specified by the Linux GPIO binding for use with the Nuvoton NPCX SoCs.
+ *
+ * @{
+ */
+
+/** @cond INTERNAL_HIDDEN */
+#define NPCX_GPIO_VOLTAGE_POS	11
+#define NPCX_GPIO_VOLTAGE_MASK	(1U << NPCX_GPIO_VOLTAGE_POS)
+/** @endcond */
+
+/** Set pin at the default voltage level (3.3V) */
+#define NPCX_GPIO_VOLTAGE_DEFAULT	(0U << NPCX_GPIO_VOLTAGE_POS)
+/** Set pin voltage level at 1.8 V */
+#define NPCX_GPIO_VOLTAGE_1P8		(1U << NPCX_GPIO_VOLTAGE_POS)
+
+/** @} */
+
+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_GPIO_NUVOTON_NPCX_GPIO_H_ */
diff --git a/soc/arm/nuvoton_npcx/Kconfig b/soc/arm/nuvoton_npcx/Kconfig
index ac5daf8e0b..8bf9bc6317 100644
--- a/soc/arm/nuvoton_npcx/Kconfig
+++ b/soc/arm/nuvoton_npcx/Kconfig
@@ -37,11 +37,14 @@ config NPCX_IMAGE_OUTPUT_HEX
 
 config NPCX_HEADER_CHIP
 	string
+	default "npck3m7" if SOC_NPCK3M7K
 	default "npcx7m6" if SOC_NPCX7M6FB || SOC_NPCX7M6FC
 	default "npcx7m7" if SOC_NPCX7M7FC
 	default "npcx9m3" if SOC_NPCX9M3F
 	default "npcx9m6" if SOC_NPCX9M6F
 	default "npcx9m7" if SOC_NPCX9M7F
+	default "npcx4m3" if SOC_NPCX4M3F
+	default "npcx4m8" if SOC_NPCX4M8F
 
 choice NPCX_HEADER_SPI_MAX_CLOCK_CHOICE
 	prompt "Clock rate to use for SPI flash"
@@ -139,7 +142,8 @@ config NPCX_HEADER_ENABLE_FIRMWARE_CRC
 choice NPCX_HEADER_FLASH_SIZE_CHOICE
 	prompt "Flash size"
 	default NPCX_HEADER_FLASH_SIZE_0P5M_1M if SOC_SERIES_NPCX7 || \
-						  SOC_SERIES_NPCX9
+						  SOC_SERIES_NPCX9 || \
+						  SOC_SERIES_NPCK3
 	default NPCX_HEADER_FLASH_SIZE_16M
 	help
 	  This sets the SPI flash size.
diff --git a/soc/arm/nuvoton_npcx/common/ecst/ecst.py b/soc/arm/nuvoton_npcx/common/ecst/ecst.py
old mode 100755
new mode 100644
index 33c2fe1c40..ff5be14302
--- a/soc/arm/nuvoton_npcx/common/ecst/ecst.py
+++ b/soc/arm/nuvoton_npcx/common/ecst/ecst.py
@@ -213,8 +213,8 @@ def _check_chip(output, ecst_args):
 
     if ecst_args.chip_name == INVALID_INPUT:
         message = f'Invalid chip name, '
-        message += "should be npcx9m8, npcx9m7, npcx9m6, npcx7m7," \
-                   " npcx7m6, npcx7m5, npcx5m5 or npcx5m6."
+        message += "should be npcx4m3, npcx4m8, npcx9m8, npcx9m7, npcx9m6, " \
+                   "npcx7m7, npcx7m6, npcx7m5, npck3m7k."
         _exit_with_failure_delete_file(output, message)
 
 def _set_anchor(output, ecst_args):
@@ -924,7 +924,7 @@ def _crc_update(cur, crc, table):
     :param crc
     :param table
     """
-    l_crc = (0x000000ff & cur)
+    l_crc = 0x000000ff & cur
 
     tmp = crc ^ l_crc
     crc = (crc >> 8) ^ table[(tmp & 0xff)]
diff --git a/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py b/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
old mode 100755
new mode 100644
index c596760e34..7da4e2ac15
--- a/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
+++ b/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
@@ -47,12 +47,15 @@ POINTER_OFFSET_DEFAULT = 0x0
 
 # Chips: convert from name to index.
 CHIPS_INFO = {
+    'npck3m7': {'ram_address': 0x10070000, 'ram_size': 0x50000},
     'npcx7m5': {'ram_address': 0x100a8000, 'ram_size': 0x20000},
     'npcx7m6': {'ram_address': 0x10090000, 'ram_size': 0x40000},
     'npcx7m7': {'ram_address': 0x10070000, 'ram_size': 0x60000},
     'npcx9m3': {'ram_address': 0x10080000, 'ram_size': 0x50000},
     'npcx9m6': {'ram_address': 0x10090000, 'ram_size': 0x40000},
     'npcx9m7': {'ram_address': 0x10070000, 'ram_size': 0x60000},
+    'npcx4m3': {'ram_address': 0x10088000, 'ram_size': 0x50000},
+    'npcx4m8': {'ram_address': 0x10060000, 'ram_size': 0x7c800},
 }
 DEFAULT_CHIP = 'npcx7m6'
 
@@ -180,7 +183,7 @@ def _create_parser(arg_list):
     else parses the given string
     """
 
-    parser = argparse.ArgumentParser(conflict_handler='resolve')
+    parser = argparse.ArgumentParser(conflict_handler='resolve', allow_abbrev=False)
     parser.add_argument("-i", nargs='?', dest="input")
     parser.add_argument("-o", nargs='?', dest="output")
     parser.add_argument("-chip", dest="chip")
diff --git a/soc/arm/nuvoton_npcx/common/pinctrl_soc.h b/soc/arm/nuvoton_npcx/common/pinctrl_soc.h
index cd8af7584b..8f03faa82b 100644
--- a/soc/arm/nuvoton_npcx/common/pinctrl_soc.h
+++ b/soc/arm/nuvoton_npcx/common/pinctrl_soc.h
@@ -16,6 +16,7 @@
  */
 enum npcx_pinctrl_type {
 	NPCX_PINCTRL_TYPE_PERIPH,
+	NPCX_PINCTRL_TYPE_DEVICE_CTRL,
 	NPCX_PINCTRL_TYPE_PSL_IN,
 	NPCX_PINCTRL_TYPE_RESERVED,
 };
@@ -81,6 +82,23 @@ struct npcx_periph {
 	uint16_t reserved: 2;
 } __packed;
 
+/**
+ * @brief NPCX device control structure
+ *
+ * Used to indicate the device's corresponding register/field for its io
+ * characteristics such as tri-state, power supply type selection, and so on.
+ */
+struct npcx_dev_ctl {
+	/** Related register offset for device configuration. */
+	uint16_t offest: 5;
+	/** Related register field offset for device control. */
+	uint16_t field_offset: 3;
+	/** Related register field size for device control. */
+	uint16_t field_size: 3;
+	/** field value */
+	uint16_t field_value: 5;
+} __packed;
+
 /**
  * @brief NPCX Power Switch Logic (PSL) input pad configuration structure
  *
@@ -103,6 +121,7 @@ struct npcx_psl_input {
 struct npcx_pinctrl {
 	union {
 		struct npcx_periph periph;
+		struct npcx_dev_ctl dev_ctl;
 		struct npcx_psl_input psl_in;
 		uint16_t cfg_word;
 	} cfg;
@@ -163,6 +182,21 @@ typedef struct npcx_pinctrl pinctrl_soc_pin_t;
 		.cfg.periph.inverted = DT_PHA(DT_PROP(node_id, prop), alts, inv),	\
 	},
 
+/**
+ * @brief Utility macro to initialize a periphral pinmux configuration.
+ *
+ * @param node_id Node identifier.
+ * @param prop Property name for pinmux configuration. (i.e. 'pinmux')
+ */
+#define Z_PINCTRL_NPCX_DEVICE_CONTROL_INIT(node_id, prop)			\
+	{									\
+		.flags.type = NPCX_PINCTRL_TYPE_DEVICE_CTRL,			\
+		.cfg.dev_ctl.offest = DT_PROP_BY_IDX(node_id, prop, 0),		\
+		.cfg.dev_ctl.field_offset = DT_PROP_BY_IDX(node_id, prop, 1),	\
+		.cfg.dev_ctl.field_size = DT_PROP_BY_IDX(node_id, prop, 2),	\
+		.cfg.dev_ctl.field_value = DT_PROP_BY_IDX(node_id, prop, 3),	\
+	},
+
 /**
  * @brief Utility macro to initialize a periphral pull-up/down configuration.
  *
@@ -227,6 +261,9 @@ typedef struct npcx_pinctrl pinctrl_soc_pin_t;
 	COND_CODE_1(Z_PINCTRL_NPCX_HAS_PSL_IN_PROP(DT_PROP_BY_IDX(node_id, prop, idx)),	\
 		(Z_PINCTRL_NPCX_PSL_IN_DETECT_CONF_INIT(				\
 			DT_PROP_BY_IDX(node_id, prop, idx), psl_polarity)), ())		\
+	COND_CODE_1(DT_NODE_HAS_PROP(DT_PROP_BY_IDX(node_id, prop, idx), dev_ctl),	\
+		(Z_PINCTRL_NPCX_DEVICE_CONTROL_INIT(					\
+			DT_PROP_BY_IDX(node_id, prop, idx), dev_ctl)), ())		\
 	COND_CODE_1(DT_NODE_HAS_PROP(DT_PROP_BY_IDX(node_id, prop, idx), pinmux),	\
 		(Z_PINCTRL_NPCX_PERIPH_PINMUX_INIT(					\
 			DT_PROP_BY_IDX(node_id, prop, idx), pinmux)), ())
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_access.h b/soc/arm/nuvoton_npcx/common/reg/reg_access.h
index 4f302f5146..90bf73a866 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_access.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_access.h
@@ -27,4 +27,8 @@
 	((reg) = ((reg) & (~(((1 << (f_size))-1) << (f_pos)))) \
 			| ((value) << (f_pos)))
 
+#define GET_POS(field) \
+	_GET_POS_(FIELD_POS(field))
+#define _GET_POS_(f_ops) f_ops
+
 #endif /* _NUVOTON_NPCX_REG_ACCESS_H */
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index c428a06342..861291bbf2 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -131,19 +131,9 @@ struct pmc_reg {
 	volatile uint8_t PWDWN_CTL7[1];
 };
 
-/* PMC internal inline functions for multi-registers */
-static inline uint32_t npcx_pwdwn_ctl_offset(uint32_t ctl_no)
-{
-	if (ctl_no < 6) {
-		return 0x008 + ctl_no;
-	} else {
-		return 0x024 + ctl_no - 6;
-	}
-}
-
 /* Macro functions for PMC multi-registers */
-#define NPCX_PWDWN_CTL(base, n) (*(volatile uint8_t *)(base + \
-						npcx_pwdwn_ctl_offset(n)))
+#define NPCX_PWDWN_CTL(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_PWDWN_CTL_OFFSET(n)))
 
 /* PMC register fields */
 #define NPCX_PMCSR_DI_INSTW                   0
@@ -158,6 +148,48 @@ static inline uint32_t npcx_pwdwn_ctl_offset(uint32_t ctl_no)
 #define NPCX_ENIDL_CTL_PECI_ENI               2
 #define NPCX_ENIDL_CTL_ADC_ACC_DIS            1
 
+/* Macro functions for Development and Debugger Interface (DDI) registers */
+#define NPCX_DBGCTRL(base)   (*(volatile uint8_t *)(base + 0x004))
+#define NPCX_DBGFRZEN1(base) (*(volatile uint8_t *)(base + 0x006))
+#define NPCX_DBGFRZEN2(base) (*(volatile uint8_t *)(base + 0x007))
+#define NPCX_DBGFRZEN3(base) (*(volatile uint8_t *)(base + 0x008))
+#define NPCX_DBGFRZEN4(base) (*(volatile uint8_t *)(base + 0x009))
+
+/* DDI register fields */
+#define NPCX_DBGCTRL_CCDEV_SEL		FIELD(6, 2)
+#define NPCX_DBGCTRL_CCDEV_DIR		5
+#define NPCX_DBGCTRL_SEQ_WK_EN		4
+#define NPCX_DBGCTRL_FRCLK_SEL_DIS	3
+#define NPCX_DBGFRZEN1_SPIFEN		7
+#define NPCX_DBGFRZEN1_HIFEN		6
+#define NPCX_DBGFRZEN1_ESPISEN		5
+#define NPCX_DBGFRZEN1_UART1FEN		4
+#define NPCX_DBGFRZEN1_SMB3FEN		3
+#define NPCX_DBGFRZEN1_SMB2FEN		2
+#define NPCX_DBGFRZEN1_MFT2FEN		1
+#define NPCX_DBGFRZEN1_MFT1FEN		0
+#define NPCX_DBGFRZEN2_ITIM6FEN		7
+#define NPCX_DBGFRZEN2_ITIM5FEN		6
+#define NPCX_DBGFRZEN2_ITIM4FEN		5
+#define NPCX_DBGFRZEN2_ITIM64FEN	3
+#define NPCX_DBGFRZEN2_SMB1FEN		2
+#define NPCX_DBGFRZEN2_SMB0FEN		1
+#define NPCX_DBGFRZEN2_MFT3FEN		0
+#define NPCX_DBGFRZEN3_GLBL_FRZ_DIS	7
+#define NPCX_DBGFRZEN3_ITIM3FEN		6
+#define NPCX_DBGFRZEN3_ITIM2FEN		5
+#define NPCX_DBGFRZEN3_ITIM1FEN		4
+#define NPCX_DBGFRZEN3_I3CFEN		2
+#define NPCX_DBGFRZEN3_SMB4FEN		1
+#define NPCX_DBGFRZEN3_SHMFEN		0
+#define NPCX_DBGFRZEN4_UART2FEN		6
+#define NPCX_DBGFRZEN4_UART3FEN		5
+#define NPCX_DBGFRZEN4_UART4FEN		4
+#define NPCX_DBGFRZEN4_LCTFEN		3
+#define NPCX_DBGFRZEN4_SMB7FEN		2
+#define NPCX_DBGFRZEN4_SMB6FEN		1
+#define NPCX_DBGFRZEN4_SMB5FEN		0
+
 /*
  * System Configuration (SCFG) device registers
  */
@@ -168,7 +200,16 @@ struct scfg_reg {
 	volatile uint8_t STRPST;
 	/* 0x002: Reset Control and Status */
 	volatile uint8_t RSTCTL;
-	volatile uint8_t reserved1[3];
+	/* 0x003: Reset Control and Status */
+	volatile uint8_t reserved5;
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	/* 0x004: Reset Control and Status */
+	volatile uint8_t DEV_CTL3;
+#else
+	volatile uint8_t reserved6;
+#endif /* CONFIG_SOC_SERIES_NPCK3 */
+	/* 0x005: Reset Control and Status */
+	volatile uint8_t reserved7;
 	/* 0x006: Device Control 4 */
 	volatile uint8_t DEV_CTL4;
 	volatile uint8_t reserved2[9];
@@ -186,40 +227,17 @@ struct scfg_reg {
 	volatile uint8_t LV_GPIO_CTL0[5];
 };
 
-/* SCFG internal inline functions for multi-registers */
-static inline uint32_t npcx_devalt_offset(uint32_t alt_no)
-{
-	return 0x010 + alt_no;
-}
-
-static inline uint32_t npcx_devalt_lk_offset(uint32_t alt_lk_no)
-{
-	return 0x210 + alt_lk_no;
-}
-
-static inline uint32_t npcx_pupd_en_offset(uint32_t pupd_en_no)
-{
-	return 0x28 + pupd_en_no;
-}
-
-static inline uint32_t npcx_lv_gpio_ctl_offset(uint32_t ctl_no)
-{
-	if (ctl_no < 5) {
-		return 0x02a + ctl_no;
-	} else {
-		return 0x026 + ctl_no - 5;
-	}
-}
-
 /* Macro functions for SCFG multi-registers */
-#define NPCX_DEVALT(base, n) (*(volatile uint8_t *)(base + \
-						npcx_devalt_offset(n)))
-#define NPCX_DEVALT_LK(base, n) (*(volatile uint8_t *)(base + \
-						npcx_devalt_lk_offset(n)))
-#define NPCX_PUPD_EN(base, n) (*(volatile uint8_t *)(base + \
-						npcx_pupd_en_offset(n)))
-#define NPCX_LV_GPIO_CTL(base, n) (*(volatile uint8_t *)(base + \
-						npcx_lv_gpio_ctl_offset(n)))
+#define NPCX_DEV_CTL(base, n) \
+	(*(volatile uint8_t *)(base + n))
+#define NPCX_DEVALT(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_DEVALT_OFFSET(n)))
+#define NPCX_DEVALT_LK(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_DEVALT_LK_OFFSET(n)))
+#define NPCX_PUPD_EN(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_PUPD_EN_OFFSET(n)))
+#define NPCX_LV_GPIO_CTL(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_LV_GPIO_CTL_OFFSET(n)))
 
 /* SCFG register fields */
 #define NPCX_DEVCNT_F_SPI_TRIS                6
@@ -278,6 +296,30 @@ struct glue_reg {
 	volatile uint8_t reserved6[5];
 	/* 0x027: PSL Control and Status */
 	volatile uint8_t PSL_CTS;
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	/* 0x028: PSL IN Posetive Edge Status */
+	volatile uint8_t PSL_IN_POS;
+	/* 0x029: PSL IN Negative Edge Status */
+	volatile uint8_t PSL_IN_NEG;
+	/* 0x02a: Voltage Detection Down Threshold */
+	volatile uint8_t VD_THD;
+	/* 0x02b: Voltage Detection Up Threshold */
+	volatile uint8_t VD_THU;
+	/* 0x02c: Voltage Detection Control */
+	volatile uint8_t VD_CTL;
+	/* 0x02d: Voltage Detection Control and Status */
+	volatile uint8_t VD_CTS;
+	volatile uint8_t reserved7[2];
+	/* 0x030: Exteral Power-Up Reset Control */
+	volatile uint8_t EPURST_CTL;
+	volatile uint8_t reserved8[7];
+	/* 0x038: PSL Control and Status 3 */
+	volatile uint8_t PSL_CTS3;
+	/* 0x039: PSL Control and Status 3 */
+	volatile uint8_t PSL_CTS4;
+	/* 0x03a: I3CI maxRd value */
+	volatile uint8_t I3CI_MAXRD;
+#endif
 };
 
 /* GLUE register fields */
@@ -313,6 +355,18 @@ struct uart_reg {
 	volatile uint8_t reserved7;
 	/* 0x00E: Baud Rate Prescaler */
 	volatile uint8_t UPSR;
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	volatile uint8_t reserved8[7];
+	/* 0x16: FIFO Control */
+	volatile uint8_t UFCTRL;
+	volatile uint8_t reserved9;
+	/* 0x18: TX FIFO Current Level */
+	volatile uint8_t UTXFLV;
+	volatile uint8_t reserved10;
+	/* 0x1A: RX FIFO Current Level Byte */
+	volatile uint8_t URXFLV;
+	volatile uint8_t reserved11[12];
+#else
 	volatile uint8_t reserved8[17];
 	/* 0x020: FIFO Mode Transmit Status */
 	volatile uint8_t UFTSTS;
@@ -325,6 +379,7 @@ struct uart_reg {
 	volatile uint8_t reserved11;
 	/* 0x026: FIFO Mode Receive Control */
 	volatile uint8_t UFRCTL;
+#endif
 };
 
 /* UART register fields */
@@ -362,95 +417,21 @@ struct uart_reg {
 #define NPCX_UFRCTL_RNEMPTY_EN                6
 #define NPCX_UFRCTL_ERR_EN                    7
 
-/*
- * Multi-Input Wake-Up Unit (MIWU) device registers
- */
-
-/* MIWU internal inline functions for multi-registers */
-static inline uint32_t npcx_wkedg_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x000 + (group * 2ul) + (group < 5 ? 0 : 0x1e);
-	} else { /* NPCX9 and later series */
-		return 0x000 + group * 0x10UL;
-	}
-}
-
-static inline uint32_t npcx_wkaedg_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x001 + (group * 2ul) + (group < 5 ? 0 : 0x1e);
-	} else { /* NPCX9 and later series */
-		return 0x001 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkmod_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x070 + group;
-	} else { /* NPCX9 and later series */
-		return 0x002 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkpnd_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x00a + (group * 4ul) + (group < 5 ? 0 : 0x10);
-	} else { /* NPCX9 and later series */
-		return 0x003 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkpcl_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x00c + (group * 4ul) + (group < 5 ? 0 : 0x10);
-	} else { /* NPCX9 and later series */
-		return 0x004 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wken_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x01e + (group * 2ul) + (group < 5 ? 0 : 0x12);
-	} else { /* NPCX9 and later series */
-		return 0x005 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkst_offset(uint32_t group)
-{
-	/* NPCX9 and later series only */
-	return 0x006 + group * 0x10ul;
-}
-
-static inline uint32_t npcx_wkinen_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x01f + (group * 2ul) + (group < 5 ? 0 : 0x12);
-	} else { /* NPCX9 and later series */
-		return 0x007 + group * 0x10ul;
-	}
-}
-
 /* Macro functions for MIWU multi-registers */
 #define NPCX_WKEDG(base, group) \
-	(*(volatile uint8_t *)(base +  npcx_wkedg_offset(group)))
+	(*(volatile uint8_t *)(base +  NPCX_WKEDG_OFFSET(group)))
 #define NPCX_WKAEDG(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkaedg_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKAEDG_OFFSET(group)))
 #define NPCX_WKPND(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkpnd_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKPND_OFFSET(group)))
 #define NPCX_WKPCL(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkpcl_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKPCL_OFFSET(group)))
 #define NPCX_WKEN(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wken_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKEN_OFFSET(group)))
 #define NPCX_WKINEN(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkinen_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKINEN_OFFSET(group)))
 #define NPCX_WKMOD(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkmod_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKMOD_OFFSET(group)))
 
 /*
  * General-Purpose I/O (GPIO) device registers
@@ -515,7 +496,9 @@ struct adc_reg {
 	volatile uint16_t ASCADD;
 	/* 0x008: ADC Scan Channels Select */
 	volatile uint16_t ADCCS;
-	volatile uint8_t reserved1[16];
+	/* 0x00A: ADC Scan Channels Select 2 */
+	volatile uint16_t ADCCS2;
+	volatile uint8_t reserved1[14];
 	/* 0x01A:  Threshold Status */
 	volatile uint16_t THRCTS;
 	volatile uint8_t reserved2[4];
@@ -528,12 +511,11 @@ struct adc_reg {
 	volatile uint16_t MEAST;
 };
 
-static inline uint32_t npcx_chndat_offset(uint32_t ch)
-{
-	return 0x40 + ch * 2;
-}
-
-#define CHNDAT(base, ch) (*(volatile uint16_t *)((base) + npcx_chndat_offset(ch)))
+/* ADC internal inline functions for multi-registers */
+#define CHNDAT(base, ch) \
+	(*(volatile uint16_t *)((base) + NPCX_CHNDAT_OFFSET(ch)))
+#define THRCTL(base, ctrl) \
+	(*(volatile uint16_t *)(base + NPCX_THRCTL_OFFSET(ctrl)))
 
 /* ADC register fields */
 #define NPCX_ATCTL_SCLKDIV_FIELD              FIELD(0, 6)
@@ -553,10 +535,6 @@ static inline uint32_t npcx_chndat_offset(uint32_t ch)
 #define NPCX_ADCCNF_STOP                      11
 #define NPCX_CHNDAT_CHDAT_FIELD               FIELD(0, 10)
 #define NPCX_CHNDAT_NEW                       15
-#define NPCX_THRCTL_THEN                      15
-#define NPCX_THRCTL_L_H                       14
-#define NPCX_THRCTL_CHNSEL                    FIELD(10, 4)
-#define NPCX_THRCTL_THRVAL                    FIELD(0, 10)
 #define NPCX_THRCTS_ADC_WKEN                  15
 #define NPCX_THRCTS_THR3_IEN                  10
 #define NPCX_THRCTS_THR2_IEN                  9
@@ -617,80 +595,127 @@ struct twd_reg {
  * Enhanced Serial Peripheral Interface (eSPI) device registers
  */
 struct espi_reg {
-	/* 0x000: eSPI Identification */
+	/* 0x000 - 0x003: eSPI Identification */
 	volatile uint32_t ESPIID;
-	/* 0x004: eSPI Configuration */
+	/* 0x004 - 0x007: eSPI Configuration */
 	volatile uint32_t ESPICFG;
-	/* 0x008: eSPI Status */
+	/* 0x008 - 0x00B: eSPI Status */
 	volatile uint32_t ESPISTS;
-	/* 0x00C: eSPI Interrupt Enable */
+	/* 0x00C - 0x00F: eSPI Interrupt Enable */
 	volatile uint32_t ESPIIE;
-	/* 0x010: eSPI Wake-Up Enable */
+	/* 0x010 - 0x013: eSPI Wake-Up Enable */
 	volatile uint32_t ESPIWE;
-	/* 0x014: Virtual Wire Register Index */
+	/* 0x014 - 0x017: Virtual Wire Register Index */
 	volatile uint32_t VWREGIDX;
-	/* 0x018: Virtual Wire Register Data */
+	/* 0x018 - 0x01B: Virtual Wire Register Data */
 	volatile uint32_t VWREGDATA;
-	/* 0x01C: OOB Receive Buffer Read Head */
+	/* 0x01C - 0x01F: OOB Receive Buffer Read Head */
 	volatile uint32_t OOBRXRDHEAD;
-	/* 0x020: OOB Transmit Buffer Write Head */
+	/* 0x020 - 0x023: OOB Transmit Buffer Write Head */
 	volatile uint32_t OOBTXWRHEAD;
-	/* 0x024: OOB Channel Control */
+	/* 0x024 - 0x027: OOB Channel Control */
 	volatile uint32_t OOBCTL;
-	/* 0x028: Flash Receive Buffer Read Head */
+	/* 0x028 - 0x02B: Flash Receive Buffer Read Head */
 	volatile uint32_t FLASHRXRDHEAD;
-	/* 0x02C: Flash Transmit Buffer Write Head */
+	/* 0x02C - 0x02F: Flash Transmit Buffer Write Head */
 	volatile uint32_t FLASHTXWRHEAD;
+	/* 0x030 - 0x033 */
 	volatile uint32_t reserved1;
-	/* 0x034: Flash Channel Configuration */
+	/* 0x034 - 0x037: Flash Channel Configuration */
 	volatile uint32_t FLASHCFG;
-	/* 0x038: Flash Channel Control */
+	/* 0x038 - 0x03B: Flash Channel Control */
 	volatile uint32_t FLASHCTL;
-	/* 0x03C: eSPI Error Status */
+	/* 0x03C - 0x03F: eSPI Error Status */
 	volatile uint32_t ESPIERR;
-	/* 0x040: Peripheral Bus Master Receive Buffer Read Head */
+	/* 0x040 - 0x043: Peripheral Bus Master Receive Buffer Read Head */
 	volatile uint32_t PBMRXRDHEAD;
-	/* 0x044: Peripheral Bus Master Transmit Buffer Write Head */
+	/* 0x044 - 0x047: Peripheral Bus Master Transmit Buffer Write Head */
 	volatile uint32_t PBMTXWRHEAD;
-	/* 0x048: Peripheral Channel Configuration */
+	/* 0x048 - 0x04B: Peripheral Channel Configuration */
 	volatile uint32_t PERCFG;
-	/* 0x04C: Peripheral Channel Control */
+	/* 0x04C - 0x04F: Peripheral Channel Control */
 	volatile uint32_t PERCTL;
-	/* 0x050: Status Image Register */
+	/* 0x050 - 0x051: Status Image Register */
 	volatile uint16_t STATUS_IMG;
-	volatile uint16_t reserved2[79];
+	/* 0x052 - 0x053 */
+	volatile uint16_t reserved2;
+	/* 0x054 - 0x055: eSPI SAF Lock Control */
+	volatile uint16_t SAFLOCKCTL;
+	/* 0x056 - 0x057 */
+	volatile uint16_t reserved3;
+	/* 0x058 - 0x059: eSPI SAF illegal Access Region */
+	volatile uint16_t SAFILL_REG;
+	/* 0x05A - 0x05B */
+	volatile uint16_t reserved4;
+	/* 0x05C - 0x05D: Protection Region Dirty Access */
+	volatile uint16_t PRDIRTY;
+	/* 0x05E - 0x0EF */
+	volatile uint16_t reserved5[73];
 	/* 0x0F0: NPCX specific eSPI Register1 */
 	volatile uint8_t NPCX_ONLY_ESPI_REG1;
 	/* 0x0F1: NPCX specific eSPI Register2 */
 	volatile uint8_t NPCX_ONLY_ESPI_REG2;
-	volatile uint16_t reserved3[7];
+	/* 0x0F2 - 0x0FF */
+	volatile uint16_t reserved6[7];
 	/* 0x100 - 127: Virtual Wire Event Slave-to-Master 0 - 9 */
 	volatile uint32_t VWEVSM[10];
-	volatile uint32_t reserved4[6];
+	/* 0x128 - 0x13B*/
+	volatile uint32_t reserved7[5];
+	/* 0x13C - 0x13F: Virtual Wire Software IRQ Register */
+	volatile uint32_t VWSWIRQ;
 	/* 0x140 - 16F: Virtual Wire Event Master-to-Slave 0 - 11 */
 	volatile uint32_t VWEVMS[12];
-	volatile uint32_t reserved5[4];
+	/* 0x170 - 0x17F*/
+	volatile uint32_t reserved8[4];
 	/* 0x180 - 1BF: Virtual Wire GPIO Event Master-to-Slave 0 - 15 */
 	volatile uint32_t VWGPSM[16];
-	volatile uint32_t reserved6[79];
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	volatile uint32_t reserved6_1[16];
+	/* 0x200: Virtual Wire Event Master-to-Slave Status */
+	volatile uint32_t VWEVMSSTS;
+	volatile uint32_t reserved6_2;
+	/* 0x208: Virtual Wire Event Slave-to-Master Type */
+	volatile uint32_t VWEVSMTYPE;
+	volatile uint32_t reserved6_3[60];
+#else
+	volatile uint32_t reserved6_1[79];
+#endif
 	/* 0x2FC: Virtual Wire Channel Control */
 	volatile uint32_t VWCTL;
-	/* 0x300 - 34F: OOB Receive Buffer 0 - 19 */
+	/* 0x300 - 0x34F: OOB Receive Buffer 0 - 19 */
 	volatile uint32_t OOBRXBUF[20];
-	volatile uint32_t reserved7[12];
+	/* 0x350 - 0x37F */
+	volatile uint32_t reserved11[12];
 	/* 0x380 - 3CF: OOB Transmit Buffer 0-19 */
 	volatile uint32_t OOBTXBUF[20];
-	volatile uint32_t reserved8[11];
-	/* 0x3FC: OOB Channel Control used in 'direct' mode */
+	/* 0x3D0 - 0x3FB */
+	volatile uint32_t reserved12[11];
+	/* 0x3FC - 0x3FF: OOB Channel Control used in 'direct' mode */
 	volatile uint32_t OOBCTL_DIRECT;
-	/* 0x400 - 443: Flash Receive Buffer 0-16 */
-	volatile uint32_t FLASHRXBUF[17];
-	volatile uint32_t reserved9[15];
-	/* 0x480 - 497: Flash Transmit Buffer 0-5 */
-	volatile uint32_t FLASHTXBUF[6];
-	volatile uint32_t reserved10[25];
-	/* 0x4FC: Flash Channel Control used in 'direct' mode */
+	/* 0x400 - 0x447: Flash Receive Buffer 0-17 */
+	volatile uint32_t FLASHRXBUF[18];
+	/* 0x448 - 0x47F */
+	volatile uint32_t reserved13[14];
+	/* 0x480 - 0x4C3: Flash Transmit Buffer 0-16 */
+	volatile uint32_t FLASHTXBUF[17];
+	/* 0x4C4 - 0x4EF */
+	volatile uint32_t reserved14[11];
+	/* 0x4F0 - 0x4F3: Flash base */
+	volatile uint32_t FLASHBASE;
+	/* 0x4F4 - 0x4FB*/
+	volatile uint32_t reserved15[2];
+	/* 0x4FC - 0x4FF: Flash Channel Control used in 'direct' mode */
 	volatile uint32_t FLASHCTL_DIRECT;
+	/* 0x500 - 0x5FF */
+	volatile uint32_t reserved16[64];
+	/* 0x600 - 0x64F */
+	volatile uint32_t FLASH_PRTR_BADDR[20];
+	/* 0x650 - 0x69F */
+	volatile uint32_t FLASH_PRTR_HADDR[20];
+	/* 0x6A0 - 0x6EF */
+	volatile uint32_t FLASH_RGN_TAG_OVR[20];
+	/* 0x6F0 - 0x8FF*/
+	volatile uint32_t reserved17[132];
 };
 
 /* eSPI register fields */
@@ -706,6 +731,11 @@ struct espi_reg {
 #define NPCX_ESPICFG_HCHANS_FIELD        FIELD(4, 4)
 #define NPCX_ESPICFG_IOMODE_FIELD        FIELD(8, 2)
 #define NPCX_ESPICFG_MAXFREQ_FIELD       FIELD(10, 3)
+#define NPCX_ESPICFG_FLCHANMODE          16
+#define NPCX_ESPICFG_OPFREQ              FIELD(17, 3)
+#define NPCX_ESPICFG_IOMODESEL           FIELD(20, 2)
+#define NPCX_ESPICFG_ALERTMODE           22
+#define NPCX_ESPICFG_CRC_CHK_EN          23
 #define NPCX_ESPICFG_PCCHN_SUPP          24
 #define NPCX_ESPICFG_VWCHN_SUPP          25
 #define NPCX_ESPICFG_OOBCHN_SUPP         26
@@ -715,7 +745,7 @@ struct espi_reg {
 #define NPCX_ESPIIE_BERRIE               2
 #define NPCX_ESPIIE_OOBRXIE              3
 #define NPCX_ESPIIE_FLASHRXIE            4
-#define NPCX_ESPIIE_SFLASHRDIE           5
+#define NPCX_ESPIIE_FLNACSIE             5
 #define NPCX_ESPIIE_PERACCIE             6
 #define NPCX_ESPIIE_DFRDIE               7
 #define NPCX_ESPIIE_VWUPDIE              8
@@ -733,6 +763,7 @@ struct espi_reg {
 #define NPCX_ESPIWE_BERRWE               2
 #define NPCX_ESPIWE_OOBRXWE              3
 #define NPCX_ESPIWE_FLASHRXWE            4
+#define NPCX_ESPIWE_FLNACSWE             5
 #define NPCX_ESPIWE_PERACCWE             6
 #define NPCX_ESPIWE_DFRDWE               7
 #define NPCX_ESPIWE_VWUPDWE              8
@@ -744,6 +775,7 @@ struct espi_reg {
 #define NPCX_ESPISTS_BERR                2
 #define NPCX_ESPISTS_OOBRX               3
 #define NPCX_ESPISTS_FLASHRX             4
+#define NPCX_ESPISTS_FLNACS              5
 #define NPCX_ESPISTS_PERACC              6
 #define NPCX_ESPISTS_DFRD                7
 #define NPCX_ESPISTS_VWUPD               8
@@ -758,6 +790,14 @@ struct espi_reg {
 #define NPCX_ESPISTS_BMBURSTERR          22
 #define NPCX_ESPISTS_BMBURSTDONE         23
 #define NPCX_ESPISTS_ESPIRST_LVL         24
+#define NPCX_VWSWIRQ_IRQ_NUM             FIELD(0, 7)
+#define NPCX_VWSWIRQ_IRQ_LVL             7
+#define NPCX_VWSWIRQ_INDEX               FIELD(8, 7)
+#define NPCX_VWSWIRQ_INDEX_EN            15
+#define NPCX_VWSWIRQ_DIRTY               16
+#define NPCX_VWSWIRQ_ENPLTRST            17
+#define NPCX_VWSWIRQ_ENCDRST             19
+#define NPCX_VWSWIRQ_EDGE_IRQ            28
 #define NPCX_VWEVMS_WIRE                 FIELD(0, 4)
 #define NPCX_VWEVMS_VALID                FIELD(4, 4)
 #define NPCX_VWEVMS_IE                   18
@@ -774,6 +814,9 @@ struct espi_reg {
 #define NPCX_FLASHCFG_FLASHBLERSSIZE     FIELD(7, 3)
 #define NPCX_FLASHCFG_FLASHPLSIZE        FIELD(10, 3)
 #define NPCX_FLASHCFG_FLASHREQSIZE       FIELD(13, 3)
+#define NPCX_FLASHCFG_FLCAPA             FIELD(16, 2)
+#define NPCX_FLASHCFG_TRGFLEBLKSIZE      FIELD(18, 8)
+#define NPCX_FLASHCFG_FLREQSUP           FIELD(0, 3)
 #define NPCX_FLASHCTL_FLASH_NP_FREE      0
 #define NPCX_FLASHCTL_FLASH_TX_AVAIL     1
 #define NPCX_FLASHCTL_STRPHDR            2
@@ -783,10 +826,20 @@ struct espi_reg {
 #define NPCX_FLASHCTL_CRCEN              14
 #define NPCX_FLASHCTL_CHKSUMSEL          15
 #define NPCX_FLASHCTL_AMTEN              16
-
+#define NPCX_FLASHCTL_SAF_AUTO_READ      18
+#define NPCX_FLASHCTL_AUTO_RD_DIS_CTL    19
+#define NPCX_FLASHCTL_BLK_FLASH_NP_FREE  20
+#define NPCX_FLASHBASE_FLBASE_ADDR       FIELD(16, 13)
+#define NPCX_FLASH_PRTR_BADDR            FIELD(12, 17)
+#define NPCX_FRGN_WPR                    31
+#define NPCX_FRGN_RPR                    30
+#define NPCX_FLASH_PRTR_HADDR            FIELD(12, 17)
+#define NPCX_FLASH_TAG_OVR_RPR           FIELD(16, 16)
+#define NPCX_FLASH_TAG_OVR_WPR           FIELD(0, 16)
 #define NPCX_ONLY_ESPI_REG1_UNLOCK_REG2         0x55
 #define NPCX_ONLY_ESPI_REG1_LOCK_REG2           0
 #define NPCX_ONLY_ESPI_REG2_TRANS_END_CONFIG    4
+
 /*
  * Mobile System Wake-Up Control (MSWC) device registers
  */
@@ -955,6 +1008,7 @@ struct shm_reg {
 #define NPCX_DP80CTL_RFIFO               4
 #define NPCX_DP80CTL_CIEN                5
 #define NPCX_DP80CTL_DP80_HF_CFG         7
+#define NPCX_DP80BUF_OFFS_FIELD          FIELD(8, 3)
 
 /*
  * Keyboard and Mouse Controller (KBC) device registers
@@ -1110,89 +1164,99 @@ struct smb_reg {
 	volatile uint8_t reserved7;
 	/* 0x00E: SMB Control 3 */
 	volatile uint8_t SMBCTL3;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+	/* 0x00F: DMA Control */
+	volatile uint8_t DMA_CTRL;
+#else
 	/* 0x00F: SMB Bus Timeout */
 	volatile uint8_t SMBT_OUT;
-	/* 0x010: SMB Own Address 3 */
-	volatile uint8_t SMBADDR3;
-	/* 0x011: SMB Own Address 7 */
-	volatile uint8_t SMBADDR7;
-	/* 0x012: SMB Own Address 4 */
-	volatile uint8_t SMBADDR4;
-	/* 0x013: SMB Own Address 8 */
-	volatile uint8_t SMBADDR8;
-	/* 0x014: SMB Own Address 5 */
-	volatile uint8_t SMBADDR5;
-	volatile uint8_t reserved8;
-	/* 0x016: SMB Own Address 6 */
-	volatile uint8_t SMBADDR6;
-	volatile uint8_t reserved9;
-	/* 0x018: SMB Control Status 2 */
-	volatile uint8_t SMBCST2;
-	/* 0x019: SMB Control Status 3 */
-	volatile uint8_t SMBCST3;
-	/* 0x01A: SMB Control 4 */
-	volatile uint8_t SMBCTL4;
-	volatile uint8_t reserved10;
-	/* 0x01C: SMB SCL Low Time */
-	volatile uint8_t SMBSCLLT;
-	/* 0x01D: SMB FIFO Control */
-	volatile uint8_t SMBFIF_CTL;
-	/* 0x01E: SMB SCL High Time */
-	volatile uint8_t SMBSCLHT;
-	volatile uint8_t reserved11;
-};
-
-/*
- * SMBUS (SMB) FIFO device registers
- */
-struct smb_fifo_reg {
-	/* 0x000: SMB Serial Data */
-	volatile uint8_t SMBSDA;
-	volatile uint8_t reserved1;
-	/* 0x002: SMB Status */
-	volatile uint8_t SMBST;
-	volatile uint8_t reserved2;
-	/* 0x004: SMB Control Status */
-	volatile uint8_t SMBCST;
-	volatile uint8_t reserved3;
-	/* 0x006: SMB Control 1 */
-	volatile uint8_t SMBCTL1;
-	volatile uint8_t reserved4;
-	/* 0x008: SMB Own Address */
-	volatile uint8_t SMBADDR1;
-	volatile uint8_t reserved5;
-	/* 0x00A: SMB Control 2 */
-	volatile uint8_t SMBCTL2;
-	volatile uint8_t reserved6;
-	/* 0x00C: SMB Own Address */
-	volatile uint8_t SMBADDR2;
-	volatile uint8_t reserved7;
-	/* 0x00E: SMB Control 3 */
-	volatile uint8_t SMBCTL3;
-	/* 0x00F: SMB Bus Timeout */
-	volatile uint8_t SMBT_OUT;
-	/* 0x010: SMB FIFO Control */
-	volatile uint8_t SMBFIF_CTS;
-	volatile uint8_t reserved8;
-	/* 0x012: SMB Tx-FIFO Control */
-	volatile uint8_t SMBTXF_CTL;
-	volatile uint8_t reserved9;
-	/* 0x014: SMB Bus Timeout */
-	volatile uint8_t SMB_T_OUT;
-	volatile uint8_t reserved10[3];
-	/* 0x018: SMB Control Status 2 */
-	volatile uint8_t SMBCST2;
-	/* 0x019: SMB Control Status 3 */
-	volatile uint8_t SMBCST3;
-	/* 0x01A: SMB Tx-FIFO Status */
-	volatile uint8_t SMBTXF_STS;
-	volatile uint8_t reserved11;
-	/* 0x01C: SMB Rx-FIFO Status */
-	volatile uint8_t SMBRXF_STS;
-	volatile uint8_t reserved12;
-	/* 0x01E: SMB Rx-FIFO Control */
-	volatile uint8_t SMBRXF_CTL;
-	volatile uint8_t reserved13;
+#endif
+	union {
+		/* Bank 0 */
+		struct {
+			/* 0x010: SMB Own Address 3 */
+			volatile uint8_t SMBADDR3;
+			/* 0x011: SMB Own Address 7 */
+			volatile uint8_t SMBADDR7;
+			/* 0x012: SMB Own Address 4 */
+			volatile uint8_t SMBADDR4;
+			/* 0x013: SMB Own Address 8 */
+			volatile uint8_t SMBADDR8;
+			/* 0x014: SMB Own Address 5 */
+			volatile uint8_t SMBADDR5;
+			volatile uint8_t reserved8;
+			/* 0x016: SMB Own Address 6 */
+			volatile uint8_t SMBADDR6;
+			volatile uint8_t reserved9;
+			/* 0x018: SMB Control Status 2 */
+			volatile uint8_t SMBCST2;
+			/* 0x019: SMB Control Status 3 */
+			volatile uint8_t SMBCST3;
+			/* 0x01A: SMB Control 4 */
+			volatile uint8_t SMBCTL4;
+			volatile uint8_t reserved10;
+			/* 0x01C: SMB SCL Low Time */
+			volatile uint8_t SMBSCLLT;
+			/* 0x01D: SMB FIFO Control */
+			volatile uint8_t SMBFIF_CTL;
+			/* 0x01E: SMB SCL High Time */
+			volatile uint8_t SMBSCLHT;
+			volatile uint8_t reserved11;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+			/* 0x20h DMA Address Byte 1 */
+			volatile uint8_t DMA_ADDR1;
+			/* 0x21h DMA Address Byte 2 */
+			volatile uint8_t DMA_ADDR2;
+			/* 0x22h DMA Address Byte 3 */
+			volatile uint8_t DMA_ADDR3;
+			/* 0x23h DMA Address Byte 4 */
+			volatile uint8_t DMA_ADDR4;
+			/* 0x24h Data Length Byte 1 */
+			volatile uint8_t DATA_LEN1;
+			/* 0x25h Data Length Byte 2 */
+			volatile uint8_t DATA_LEN2;
+			/* 0x26h Data Counter Byte 1 */
+			volatile uint8_t DATA_CNT1;
+			/* 0x27h Data Counter Byte 2 */
+			volatile uint8_t DATA_CNT2;
+			volatile uint8_t reserved18;
+			/* 0x29h Timeout Control 1 Byte */
+			volatile uint8_t TIMEOUT_CTL1;
+			/* 0x2Ah Timeout Control 2 Byte */
+			volatile uint8_t TIMEOUT_CTL2;
+			/* 0x2Bh SMB PEC Data */
+			volatile uint8_t SMBnPEC;
+			volatile uint8_t reserved19[4];
+#else
+			volatile uint8_t reserved20[16];
+#endif /* CONFIG_I2C_NPCX_DMA_DRIVEN */
+		};
+		/* Bank 1 */
+		struct {
+			/* 0x010: SMB FIFO Control */
+			volatile uint8_t SMBFIF_CTS;
+			volatile uint8_t reserved12;
+			/* 0x012: SMB Tx-FIFO Control */
+			volatile uint8_t SMBTXF_CTL;
+			volatile uint8_t reserved13;
+			/* 0x014: SMB Bus Timeout */
+			volatile uint8_t SMB_T_OUT;
+			volatile uint8_t reserved14[3];
+			/* 0x018: SMB Control Status 2 (FIFO) */
+			volatile uint8_t SMBCST2_FIFO;
+			/* 0x019: SMB Control Status 3 (FIFO) */
+			volatile uint8_t SMBCST3_FIFO;
+			/* 0x01A: SMB Tx-FIFO Status */
+			volatile uint8_t SMBTXF_STS;
+			volatile uint8_t reserved15;
+			/* 0x01C: SMB Rx-FIFO Status */
+			volatile uint8_t SMBRXF_STS;
+			volatile uint8_t reserved16;
+			/* 0x01E: SMB Rx-FIFO Control */
+			volatile uint8_t SMBRXF_CTL;
+			volatile uint8_t reserved17[1];
+		};
+	};
 };
 
 /* SMB register fields */
@@ -1257,6 +1321,13 @@ struct smb_fifo_reg {
 #define NPCX_SMBFIF_CTL_FIFO_EN          4
 #define NPCX_SMBRXF_STS_RX_THST          6
 
+/* DMA_CTRL  register fields */
+#define NPCX_DMA_CTL_INTCLR              0
+#define NPCX_DMA_CTL_ENABLE              1
+#define NPCX_DMA_CTL_LAST_PEC            2
+#define NPCX_DMA_CTL_DMA_STALL           3
+#define NPCX_DMA_CTL_IRQSTS              7
+
 /* RX FIFO threshold */
 #define NPCX_SMBRXF_CTL_RX_THR           FIELD(0, 6)
 #define NPCX_SMBRXF_CTL_LAST             7
@@ -1495,11 +1566,53 @@ struct fiu_reg {
 	volatile uint8_t FIU_DMM_CYC;
 	/* 0x033: FIU Extended Configuration */
 	volatile uint8_t FIU_EXT_CFG;
+#if defined(CONFIG_SOC_SERIES_NPCX9)
+	/* 0x034: UMA address byte 0-3 */
+	volatile uint32_t UMA_AB0_3;
+	/* 0x038-0x3C */
+	volatile uint8_t reserved8[5];
+	/* 0x03D: SPI Device */
+	volatile uint8_t SPI1_DEV;
+	/* 0x03E-0x3F */
+	volatile uint8_t reserved9[2];
+#elif defined(CONFIG_SOC_SERIES_NPCX4)
+	/* 0x034: UMA address byte 0-3 */
+	volatile uint32_t UMA_AB0_3;
+	/* 0x038-0x3B */
+	volatile uint8_t reserved8[4];
+	/* 0x03C: SPI Device */
+	volatile uint8_t SPI_DEV;
+	/* 0x03D */
+	volatile uint8_t reserved9;
+	/* 0x03E */
+	volatile uint8_t SPI_DEV_SIZE;
+	/* 0x03F */
+	volatile uint8_t reserved10;
+#elif defined(CONFIG_SOC_SERIES_NPCK3)
+	/* 0x034: UMA address byte 0-3 */
+	volatile uint32_t UMA_AB0_3;
+	volatile uint8_t reserved8[4];
+	/* 0x03C: Set command enable in 4 byte address mode */
+	volatile uint8_t SET_CMD_EN;
+	/* 0x03D: 4 byte address mode enable */
+	volatile uint8_t FIU_4B_EN;
+	/* 0x03E-0x040*/
+	volatile uint8_t reserved9[3];
+	/* 0x041: Master Inactive Counter Threshold */
+	volatile uint8_t MI_CNT_THRSH;
+	/* 0x042: FIU Matser Status */
+	volatile uint8_t FIU_MSR_STS;
+	/* 0x043: FIU Master Interrupt Enable and Configuration */
+	volatile uint8_t FIU_MSR_IE_CFG;
+#endif
 };
 
 /* FIU register fields */
+#define NPCX_BURST_CFG_SPI_DEV_SEL       FIELD(4, 2)
 #define NPCX_RESP_CFG_IAD_EN             0
 #define NPCX_RESP_CFG_DEV_SIZE_EX        2
+#define NPCX_RESP_CFG_QUAD_EN            3
+#define NPCX_SPI_FL_CFG_RD_MODE          FIELD(6, 2)
 #define NPCX_UMA_CTS_A_SIZE              3
 #define NPCX_UMA_CTS_C_SIZE              4
 #define NPCX_UMA_CTS_RD_WR               5
@@ -1509,6 +1622,20 @@ struct fiu_reg {
 #define NPCX_UMA_ECTS_SW_CS1             1
 #define NPCX_UMA_ECTS_SEC_CS             2
 #define NPCX_UMA_ECTS_UMA_LOCK           3
+#define NPCX_UMA_ECTS_UMA_ADDR_SIZE      FIELD(4, 3)
+#define NPCX_SPI1_DEV_FOUR_BADDR_CS10    6
+#define NPCX_SPI1_DEV_FOUR_BADDR_CS11    7
+#define NPCX_SPI1_DEV_SPI1_LO_DEV_SIZE   FIELD(0, 4)
+#define NPCX_FIU_EXT_CFG_SET_DMM_EN      2
+#define NPCX_FIU_EXT_CFG_SET_CMD_EN      1
+#define NPCX_SPI_DEV_NADDRB              FIELD(5, 3)
+
+#define NPCX_UMA_ECTS_UMA_DEV_BKP        3
+#define NPCX_MSR_IE_CFG_UMA_BLOCK        3
+
+#define NPCX_MSR_FIU_4B_EN_PVT_4B        4
+#define NPCX_MSR_FIU_4B_EN_SHD_4B        5
+#define NPCX_MSR_FIU_4B_EN_BKP_4B        6
 
 /* UMA fields selections */
 #define UMA_FLD_ADDR     BIT(NPCX_UMA_CTS_A_SIZE)  /* 3-bytes ADR field */
@@ -1590,4 +1717,130 @@ struct peci_reg {
 #define PECI_HIGH_SPEED_MIN_VAL          0x07
 
 #define NPCX_PECI_RATE_EHSP              6
+
+/* KBS (Keyboard Scan) device registers */
+struct kbs_reg {
+	volatile uint8_t reserved1[4];
+	/* 0x004: Keyboard Scan In */
+	volatile uint8_t KBSIN;
+	/* 0x005: Keyboard Scan In Pull-Up Enable */
+	volatile uint8_t KBSINPU;
+	/* 0x006: Keyboard Scan Out 0 */
+	volatile uint16_t KBSOUT0;
+	/* 0x008: Keyboard Scan Out 1 */
+	volatile uint16_t KBSOUT1;
+	/* 0x00A: Keyboard Scan Buffer Index */
+	volatile uint8_t KBS_BUF_INDX;
+	/* 0x00B: Keyboard Scan Buffer Data */
+	volatile uint8_t KBS_BUF_DATA;
+	/* 0x00C: Keyboard Scan Event */
+	volatile uint8_t KBSEVT;
+	/* 0x00D: Keyboard Scan Control */
+	volatile uint8_t KBSCTL;
+	/* 0x00E: Keyboard Scan Configuration Index */
+	volatile uint8_t KBS_CFG_INDX;
+	/* 0x00F: Keyboard Scan Configuration Data */
+	volatile uint8_t KBS_CFG_DATA;
+};
+
+/* KBS register fields */
+#define NPCX_KBSBUFINDX                  0
+#define NPCX_KBSEVT_KBSDONE              0
+#define NPCX_KBSEVT_KBSERR               1
+#define NPCX_KBSCTL_START                0
+#define NPCX_KBSCTL_KBSMODE              1
+#define NPCX_KBSCTL_KBSIEN               2
+#define NPCX_KBSCTL_KBSINC               3
+#define NPCX_KBSCTL_KBHDRV_FIELD         FIELD(6, 2)
+#define NPCX_KBSCFGINDX                  0
+/* Index of 'Automatic Scan' configuration register */
+#define KBS_CFG_INDX_DLY1                0 /* Keyboard Scan Delay T1 Byte */
+#define KBS_CFG_INDX_DLY2                1 /* Keyboard Scan Delay T2 Byte */
+#define KBS_CFG_INDX_RTYTO               2 /* Keyboard Scan Retry Timeout */
+#define KBS_CFG_INDX_CNUM                3 /* Keyboard Scan Columns Number */
+#define KBS_CFG_INDX_CDIV                4 /* Keyboard Scan Clock Divisor */
+
+/* SHI (Serial Host Interface) registers */
+struct shi_reg {
+	volatile uint8_t reserved1;
+	/* 0x001: SHI Configuration 1 */
+	volatile uint8_t SHICFG1;
+	/* 0x002: SHI Configuration 2 */
+	volatile uint8_t SHICFG2;
+	volatile uint8_t reserved2[2];
+	/* 0x005: Event Enable */
+	volatile uint8_t EVENABLE;
+	/* 0x006: Event Status */
+	volatile uint8_t EVSTAT;
+	/* 0x007: SHI Capabilities */
+	volatile uint8_t CAPABILITY;
+	/* 0x008: Status */
+	volatile uint8_t STATUS;
+	volatile uint8_t reserved3;
+	/* 0x00A: Input Buffer Status */
+	volatile uint8_t IBUFSTAT;
+	/* 0x00B: Output Buffer Status */
+	volatile uint8_t OBUFSTAT;
+	/* 0x00C: SHI Configuration 3 */
+	volatile uint8_t SHICFG3;
+	/* 0x00D: SHI Configuration 4 */
+	volatile uint8_t SHICFG4;
+	/* 0x00E: SHI Configuration 5 */
+	volatile uint8_t SHICFG5;
+	/* 0x00F: Event Status 2 */
+	volatile uint8_t EVSTAT2;
+	/* 0x010: Event Enable 2 */
+	volatile uint8_t EVENABLE2;
+	volatile uint8_t reserved4[15];
+	/* 0x20~0x9F: Output Buffer */
+	volatile uint8_t OBUF[128];
+	/* 0xA0~0x11F: Input Buffer */
+	volatile uint8_t IBUF[128];
+};
+
+/* SHI register fields */
+#define NPCX_SHICFG1_EN                  0
+#define NPCX_SHICFG1_MODE                1
+#define NPCX_SHICFG1_WEN                 2
+#define NPCX_SHICFG1_AUTIBF              3
+#define NPCX_SHICFG1_AUTOBE              4
+#define NPCX_SHICFG1_DAS                 5
+#define NPCX_SHICFG1_CPOL                6
+#define NPCX_SHICFG1_IWRAP               7
+#define NPCX_SHICFG2_SIMUL               0
+#define NPCX_SHICFG2_BUSY                1
+#define NPCX_SHICFG2_ONESHOT             2
+#define NPCX_SHICFG2_SLWU                3
+#define NPCX_SHICFG2_REEN                4
+#define NPCX_SHICFG2_RESTART             5
+#define NPCX_SHICFG2_REEVEN              6
+#define NPCX_EVENABLE_OBEEN              0
+#define NPCX_EVENABLE_OBHEEN             1
+#define NPCX_EVENABLE_IBFEN              2
+#define NPCX_EVENABLE_IBHFEN             3
+#define NPCX_EVENABLE_EOREN              4
+#define NPCX_EVENABLE_EOWEN              5
+#define NPCX_EVENABLE_STSREN             6
+#define NPCX_EVENABLE_IBOREN             7
+#define NPCX_EVSTAT_OBE                  0
+#define NPCX_EVSTAT_OBHE                 1
+#define NPCX_EVSTAT_IBF                  2
+#define NPCX_EVSTAT_IBHF                 3
+#define NPCX_EVSTAT_EOR                  4
+#define NPCX_EVSTAT_EOW                  5
+#define NPCX_EVSTAT_STSR                 6
+#define NPCX_EVSTAT_IBOR                 7
+#define NPCX_STATUS_OBES                 6
+#define NPCX_STATUS_IBFS                 7
+#define NPCX_SHICFG3_OBUFLVLDIS          7
+#define NPCX_SHICFG4_IBUFLVLDIS          7
+#define NPCX_SHICFG5_IBUFLVL2            FIELD(0, 6)
+#define NPCX_SHICFG5_IBUFLVL2DIS         7
+#define NPCX_EVSTAT2_IBHF2               0
+#define NPCX_EVSTAT2_CSNRE               1
+#define NPCX_EVSTAT2_CSNFE               2
+#define NPCX_EVENABLE2_IBHF2EN           0
+#define NPCX_EVENABLE2_CSNREEN           1
+#define NPCX_EVENABLE2_CSNFEEN           2
+
 #endif /* _NUVOTON_NPCX_REG_DEF_H */
diff --git a/soc/arm/nuvoton_npcx/common/registers.c b/soc/arm/nuvoton_npcx/common/registers.c
index 566a063abb..61438078f9 100644
--- a/soc/arm/nuvoton_npcx/common/registers.c
+++ b/soc/arm/nuvoton_npcx/common/registers.c
@@ -27,17 +27,30 @@ NPCX_REG_OFFSET_CHECK(scfg_reg, DEVALT0, 0x010);
 NPCX_REG_OFFSET_CHECK(scfg_reg, LV_GPIO_CTL0, 0x02a);
 
 /* GLUE register structure check */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_SIZE_CHECK(glue_reg, 0x03b);
+#else
 NPCX_REG_SIZE_CHECK(glue_reg, 0x028);
+#endif
 NPCX_REG_OFFSET_CHECK(glue_reg, SMB_EEN, 0x003);
 NPCX_REG_OFFSET_CHECK(glue_reg, SDPD0, 0x010);
 NPCX_REG_OFFSET_CHECK(glue_reg, SMB_SEL, 0x021);
 NPCX_REG_OFFSET_CHECK(glue_reg, PSL_CTS, 0x027);
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_OFFSET_CHECK(glue_reg, EPURST_CTL, 0x030);
+NPCX_REG_OFFSET_CHECK(glue_reg, PSL_CTS3, 0x038);
+#endif
 
 /* UART register structure check */
 NPCX_REG_SIZE_CHECK(uart_reg, 0x027);
 NPCX_REG_OFFSET_CHECK(uart_reg, UPSR, 0x00e);
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_OFFSET_CHECK(uart_reg, UFCTRL, 0x016);
+NPCX_REG_OFFSET_CHECK(uart_reg, URXFLV, 0x01A);
+#else
 NPCX_REG_OFFSET_CHECK(uart_reg, UFTSTS, 0x020);
 NPCX_REG_OFFSET_CHECK(uart_reg, UFRCTL, 0x026);
+#endif
 
 /* GPIO register structure check */
 NPCX_REG_SIZE_CHECK(gpio_reg, 0x008);
@@ -62,7 +75,7 @@ NPCX_REG_OFFSET_CHECK(twd_reg, TWMWD, 0x00e);
 NPCX_REG_OFFSET_CHECK(twd_reg, WDCP, 0x010);
 
 /* ESPI register structure check */
-NPCX_REG_SIZE_CHECK(espi_reg, 0x500);
+NPCX_REG_SIZE_CHECK(espi_reg, 0x900);
 NPCX_REG_OFFSET_CHECK(espi_reg, FLASHCFG, 0x034);
 NPCX_REG_OFFSET_CHECK(espi_reg, NPCX_ONLY_ESPI_REG1, 0x0f0);
 NPCX_REG_OFFSET_CHECK(espi_reg, VWEVMS, 0x140);
@@ -117,17 +130,20 @@ NPCX_REG_OFFSET_CHECK(c2h_reg, CRSMAE, 0x008);
 NPCX_REG_OFFSET_CHECK(c2h_reg, SIBCTRL, 0x00a);
 
 /* SMB register structure check */
-NPCX_REG_SIZE_CHECK(smb_reg, 0x020);
+NPCX_REG_SIZE_CHECK(smb_reg, 0x030);
 NPCX_REG_OFFSET_CHECK(smb_reg, SMBCTL1, 0x006);
-NPCX_REG_OFFSET_CHECK(smb_reg, SMBT_OUT, 0x00f);
 NPCX_REG_OFFSET_CHECK(smb_reg, SMBADDR6, 0x016);
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBCST2, 0x018);
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBTXF_STS, 0x01a);
 NPCX_REG_OFFSET_CHECK(smb_reg, SMBSCLHT, 0x01e);
-
-NPCX_REG_SIZE_CHECK(smb_fifo_reg, 0x020);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBT_OUT, 0x00f);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBCST2, 0x018);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBTXF_STS, 0x01a);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBRXF_CTL, 0x01e);
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBRXF_CTL, 0x01e);
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+NPCX_REG_OFFSET_CHECK(smb_reg, DMA_CTRL, 0x00f);
+NPCX_REG_OFFSET_CHECK(smb_reg, DMA_ADDR3, 0x022);
+NPCX_REG_OFFSET_CHECK(smb_reg, TIMEOUT_CTL1, 0x029);
+#else
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBT_OUT, 0x00f);
+#endif /* CONFIG_I2C_NPCX_DMA_DRIVEN */
 
 /* ITIM register structure check */
 NPCX_REG_SIZE_CHECK(itim32_reg, 0x00c);
@@ -165,7 +181,13 @@ NPCX_REG_OFFSET_CHECK(ps2_reg, PSISIG, 0x008);
 NPCX_REG_OFFSET_CHECK(ps2_reg, PSIEN, 0x00a);
 
 /* FIU register structure check */
+#if defined(CONFIG_SOC_SERIES_NPCX9) || defined(CONFIG_SOC_SERIES_NPCX4)
+NPCX_REG_SIZE_CHECK(fiu_reg, 0x040);
+#elif defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_SIZE_CHECK(fiu_reg, 0x044);
+#else
 NPCX_REG_SIZE_CHECK(fiu_reg, 0x034);
+#endif
 NPCX_REG_OFFSET_CHECK(fiu_reg, BURST_CFG, 0x001);
 NPCX_REG_OFFSET_CHECK(fiu_reg, SPI_FL_CFG, 0x014);
 NPCX_REG_OFFSET_CHECK(fiu_reg, UMA_CTS, 0x01e);
@@ -178,3 +200,9 @@ NPCX_REG_SIZE_CHECK(peci_reg, 0x050);
 NPCX_REG_OFFSET_CHECK(peci_reg, PECI_ADDR, 0x002);
 NPCX_REG_OFFSET_CHECK(peci_reg, PECI_WR_LENGTH, 0x007);
 NPCX_REG_OFFSET_CHECK(peci_reg, PECI_WR_FCS, 0x00b);
+
+/* KBS register structure check */
+NPCX_REG_SIZE_CHECK(kbs_reg, 0x010);
+NPCX_REG_OFFSET_CHECK(kbs_reg, KBSIN, 0x004);
+NPCX_REG_OFFSET_CHECK(kbs_reg, KBSOUT0, 0x006);
+NPCX_REG_OFFSET_CHECK(kbs_reg, KBS_BUF_INDX, 0x00a);
diff --git a/soc/arm/nuvoton_npcx/common/scfg.c b/soc/arm/nuvoton_npcx/common/scfg.c
index 8641676266..7f44cc52b3 100644
--- a/soc/arm/nuvoton_npcx/common/scfg.c
+++ b/soc/arm/nuvoton_npcx/common/scfg.c
@@ -4,7 +4,7 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-#include <zephyr/device.h>
+#include <zephyr/init.h>
 #include <zephyr/drivers/gpio.h>
 #include <zephyr/dt-bindings/pinctrl/npcx-pinctrl.h>
 #include <zephyr/kernel.h>
@@ -19,6 +19,7 @@ LOG_MODULE_REGISTER(pimux_npcx, LOG_LEVEL_ERR);
 struct npcx_scfg_config {
 	/* scfg device base address */
 	uintptr_t base_scfg;
+	uintptr_t base_dbg;
 	uintptr_t base_glue;
 };
 
@@ -45,6 +46,7 @@ static const struct npcx_alt def_alts[] = {
 
 static const struct npcx_scfg_config npcx_scfg_cfg = {
 	.base_scfg = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), scfg),
+	.base_dbg = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), dbg),
 	.base_glue = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), glue),
 };
 
@@ -94,23 +96,42 @@ bool npcx_lvol_get_detect_level(int lvol_ctrl, int lvol_bit)
 
 void npcx_pinctrl_i2c_port_sel(int controller, int port)
 {
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	const uint32_t scfg_base = npcx_scfg_cfg.base_scfg;
+
+	/* Set DEVALTC bit to select port b, otherwise select port a */
+	if (port != 0) {
+		NPCX_DEVALT(scfg_base, 0x0c) |= BIT(7 - controller);
+	} else {
+		NPCX_DEVALT(scfg_base, 0x0c) &= ~BIT(7 - controller);
+	}
+#else
 	struct glue_reg *const inst_glue = HAL_GLUE_INST();
 
+	/* Set SMB_SEL bit to select port 1, otherwise select port 0 */
 	if (port != 0) {
 		inst_glue->SMB_SEL |= BIT(controller);
 	} else {
 		inst_glue->SMB_SEL &= ~BIT(controller);
 	}
+#endif
 }
 
 int npcx_pinctrl_flash_write_protect_set(void)
 {
 	struct scfg_reg *inst_scfg = HAL_SFCG_INST();
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst_scfg->DEV_CTL3 |= BIT(NPCk_DEV_CTL3_WP_IF);
+	if (!IS_BIT_SET(inst_scfg->DEV_CTL3, NPCk_DEV_CTL3_WP_IF)) {
+		return -EIO;
+	}
+#else
 	inst_scfg->DEV_CTL4 |= BIT(NPCX_DEV_CTL4_WP_IF);
 	if (!IS_BIT_SET(inst_scfg->DEV_CTL4, NPCX_DEV_CTL4_WP_IF)) {
 		return -EIO;
 	}
+#endif
 
 	return 0;
 }
@@ -129,19 +150,20 @@ void npcx_host_interface_sel(enum npcx_hif_type hif_type)
 	SET_FIELD(inst_scfg->DEVCNT, NPCX_DEVCNT_HIF_TYP_SEL_FIELD, hif_type);
 }
 
-/* Pin-control driver registration */
-static int npcx_scfg_init(const struct device *dev)
+void npcx_dbg_freeze_enable(bool enable)
 {
-	struct scfg_reg *inst_scfg = HAL_SFCG_INST();
+	const uintptr_t dbg_base = npcx_scfg_cfg.base_dbg;
 
-	/*
-	 * Set bit 7 of DEVCNT again for npcx7 series. Please see Errata
-	 * for more information. It will be fixed in next chip.
-	 */
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		inst_scfg->DEVCNT |= BIT(7);
+	if (enable) {
+		NPCX_DBGFRZEN3(dbg_base) &= ~BIT(NPCX_DBGFRZEN3_GLBL_FRZ_DIS);
+	} else {
+		NPCX_DBGFRZEN3(dbg_base) |= BIT(NPCX_DBGFRZEN3_GLBL_FRZ_DIS);
 	}
+}
 
+/* Pin-control driver registration */
+static int npcx_scfg_init(void)
+{
 	/* Change all pads whose default functionality isn't IO to GPIO */
 	for (int i = 0; i < ARRAY_SIZE(def_alts); i++) {
 		npcx_pinctrl_alt_sel(&def_alts[i], 0);
diff --git a/soc/arm/nuvoton_npcx/common/soc_clock.h b/soc/arm/nuvoton_npcx/common/soc_clock.h
index 99656d38c8..eb3a3cee52 100644
--- a/soc/arm/nuvoton_npcx/common/soc_clock.h
+++ b/soc/arm/nuvoton_npcx/common/soc_clock.h
@@ -44,31 +44,38 @@ struct npcx_clk_cfg {
 #define APB3DIV_VAL (DT_PROP(DT_NODELABEL(pcc), apb3_prescaler) - 1)
 /* APB4 clock divider if supported */
 #if DT_NODE_HAS_PROP(DT_NODELABEL(pcc), apb4_prescaler)
-#if defined(CONFIG_SOC_SERIES_NPCX9)
+#if defined(CONFIG_CLOCK_CONTROL_NPCX_SUPP_APB4) /* Supported in NPCX9 and later series */
 #define APB4DIV_VAL (DT_PROP(DT_NODELABEL(pcc), apb4_prescaler) - 1)
 #else
 #error "APB4 clock divider is not supported but defined in pcc node!"
+#endif /* CONFIG_CLOCK_CONTROL_NPCX_SUPP_APB4 */
 #endif
-#endif
+
+/* Construct a uint8_t array from 'pwdwn-ctl-val' prop for PWDWN_CTL initialization. */
+#define NPCX_PWDWN_CTL_ITEMS_INIT(node, prop, idx) DT_PROP_BY_IDX(node, prop, idx),
+#define NPCX_PWDWN_CTL_INIT DT_FOREACH_PROP_ELEM(DT_NODELABEL(pcc), \
+				pwdwn_ctl_val, NPCX_PWDWN_CTL_ITEMS_INIT)
 
 /*
  * NPCX7 and later series clock tree macros:
  * (Please refer Figure 58. for more information.)
  *
- * Suggestion:
- * - OFMCLK > 50MHz, XF_RANGE should be 1, else 0.
- * - CORE_CLK > 50MHz, AHB6DIV should be 1, else 0.
- * - CORE_CLK > 50MHz, FIUDIV should be 1, else 0.
+ * Maximum OFMCLK in npcx7/9 series is 100MHz,
+ * Maximum OFMCLK in npcx4 series is 120MHz,
+ *
+ * Suggestion for npcx series:
+ * - OFMCLK   > MAX_OFMCLK/2, XF_RANGE should be 1, else 0.
+ * - CORE_CLK > MAX_OFMCLK/2, AHB6DIV should be 1, else 0.
+ * - CORE_CLK > MAX_OFMCLK/2, FIUDIV should be 1, else 0.
  */
-
 /* Core domain clock */
 #define CORE_CLK (OFMCLK / DT_PROP(DT_NODELABEL(pcc), core_prescaler))
 /* Low Frequency clock */
 #define LFCLK 32768
 
 /* FMUL clock */
-#if (OFMCLK > 50000000)
-#define FMCLK (OFMCLK / 2) /* FMUL clock = OFMCLK/2 if OFMCLK > 50MHz */
+#if (OFMCLK > (MAX_OFMCLK / 2))
+#define FMCLK (OFMCLK / 2) /* FMUL clock = OFMCLK/2 */
 #else
 #define FMCLK OFMCLK /* FMUL clock = OFMCLK */
 #endif
@@ -77,18 +84,27 @@ struct npcx_clk_cfg {
 #define APBSRC_CLK OFMCLK
 
 /* AHB6 clock */
-#if (CORE_CLK > 50000000)
-#define AHB6DIV_VAL 1 /* AHB6_CLK = CORE_CLK/2 if CORE_CLK > 50MHz */
+#if (CORE_CLK > (MAX_OFMCLK / 2))
+#define AHB6DIV_VAL 1 /* AHB6_CLK = CORE_CLK/2 */
 #else
 #define AHB6DIV_VAL 0 /* AHB6_CLK = CORE_CLK */
 #endif
+
 /* FIU clock divider */
-#if (CORE_CLK > 50000000)
+#if (CORE_CLK > (MAX_OFMCLK / 2))
 #define FIUDIV_VAL 1 /* FIU_CLK = CORE_CLK/2 */
 #else
 #define FIUDIV_VAL 0 /* FIU_CLK = CORE_CLK */
 #endif
 
+#if defined(CONFIG_CLOCK_CONTROL_NPCX_SUPP_FIU1)
+#if (CORE_CLK > (MAX_OFMCLK / 2))
+#define FIU1DIV_VAL 1 /* FIU1_CLK = CORE_CLK/2 */
+#else
+#define FIU1DIV_VAL 0 /* FIU1_CLK = CORE_CLK */
+#endif
+#endif /* CONFIG_CLOCK_CONTROL_NPCX_SUPP_FIU1 */
+
 /* Get APB clock freq */
 #define NPCX_APB_CLOCK(no) (APBSRC_CLK / (APB##no##DIV_VAL + 1))
 
@@ -96,12 +112,15 @@ struct npcx_clk_cfg {
  * Frequency multiplier M/N value definitions according to the requested
  * OFMCLK (Unit:Hz).
  */
-#if (OFMCLK > 50000000)
-#define HFCGN_VAL    0x82 /* Set XF_RANGE as 1 if OFMCLK > 50MHz */
+#if (OFMCLK > (MAX_OFMCLK / 2))
+#define HFCGN_VAL    0x82 /* Set XF_RANGE as 1 */
 #else
 #define HFCGN_VAL    0x02
 #endif
-#if   (OFMCLK == 100000000)
+#if   (OFMCLK == 120000000)
+#define HFCGMH_VAL   0x0E
+#define HFCGML_VAL   0x4E
+#elif (OFMCLK == 100000000)
 #define HFCGMH_VAL   0x0B
 #define HFCGML_VAL   0xEC
 #elif (OFMCLK == 96000000)
@@ -122,12 +141,6 @@ struct npcx_clk_cfg {
 #elif (OFMCLK == 48000000)
 #define HFCGMH_VAL   0x0B
 #define HFCGML_VAL   0x72
-#elif (OFMCLK == 40000000)
-#define HFCGMH_VAL   0x09
-#define HFCGML_VAL   0x89
-#elif (OFMCLK == 33000000)
-#define HFCGMH_VAL   0x07
-#define HFCGML_VAL   0xDE
 #else
 #error "Unsupported OFMCLK Frequency"
 #endif
diff --git a/soc/arm/nuvoton_npcx/common/soc_dbg.h b/soc/arm/nuvoton_npcx/common/soc_dbg.h
new file mode 100644
index 0000000000..dc8f2ce120
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/common/soc_dbg.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _NUVOTON_NPCX_SOC_DBG_H_
+#define _NUVOTON_NPCX_SOC_DBG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Configure the Automatic Freeze mode. If this mode is enabled, whenever
+ * the Core is halted, various modulesâ clocks, counters are stopped and
+ * destructive reads are disabled, pending the respective module enable bit for
+ * debugging.
+ */
+void npcx_dbg_freeze_enable(bool enable);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NUVOTON_NPCX_SOC_DBG_H_ */
diff --git a/soc/arm/nuvoton_npcx/common/soc_espi_taf.h b/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
new file mode 100644
index 0000000000..6c5b9adbd2
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _NUVOTON_NPCX_SOC_ESPI_TAF_H_
+#define _NUVOTON_NPCX_SOC_ESPI_TAF_H_
+
+#include <zephyr/device.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* data operation for eSPI TAF packet */
+#define MSN(var8)        ((uint8_t)((uint8_t)(var8) >> 4))
+#define LSN(var8)        ((uint8_t)((uint8_t)(var8) & 0x0F))
+
+#define MSB0(var32)      ((uint8_t)(((uint32_t)(var32) & 0xFF000000) >> 24))
+#define MSB1(var32)      ((uint8_t)(((uint32_t)(var32) & 0xFF0000) >> 16))
+#define MSB2(var32)      ((uint8_t)(((uint16_t)(var32) & 0xFF00) >> 8))
+#define MSB3(var32)      ((uint8_t)((var32) & 0xFF))
+
+#define MAKE8(nlo, nhi)  ((uint8_t)(((uint8_t)(nlo)) | (((uint8_t)(nhi)) << 4)))
+
+/* Successful Completion Without Data     */
+#define CYC_SCS_CMP_WITHOUT_DATA                   0x06
+/* Successful middle Completion With Data */
+#define CYC_SCS_CMP_WITH_DATA_MIDDLE               0x09
+/* Successful first Completion With Data  */
+#define CYC_SCS_CMP_WITH_DATA_FIRST                0x0B
+/* Successful last Completion With Data   */
+#define CYC_SCS_CMP_WITH_DATA_LAST                 0x0D
+/* Successful only Completion With Data   */
+#define CYC_SCS_CMP_WITH_DATA_ONLY                 0x0F
+/* Unsuccessful Completion Without Data   */
+#define CYC_UNSCS_CMP_WITHOUT_DATA                 0x08
+/* Unsuccessful Last Completion Without Data */
+#define CYC_UNSCS_CMP_WITHOUT_DATA_LAST            0x0C
+/* Unsuccessful Only Completion Without Data */
+#define CYC_UNSCS_CMP_WITHOUT_DATA_ONLY            0x0E
+
+/* TAF EC Portal read/write flash access limited to 1-64 bytes*/
+#define MAX_FLASH_REQUEST                          64u
+
+/* Clear RSTBUFHEADS, FLASH_ACC_TX_AVAIL, and FLASH_ACC_NP_FREE */
+#define FLASHCTL_ACCESS_MASK                       (~0x00002003)
+
+/* Flash Sharing Capability Support */
+#define ESPI_FLASH_SHARING_CAP_SUPP_CAF_DEF        0
+#define ESPI_FLASH_SHARING_CAP_SUPP_CAF            1
+#define ESPI_FLASH_SHARING_CAP_SUPP_TAF            2
+#define ESPI_FLASH_SHARING_CAP_SUPP_TAF_AND_CAF    3
+
+#define _4KB_                                      (4 * 1024)
+#define _32KB_                                     (32 * 1024)
+#define _64KB_                                     (64 * 1024)
+#define _128KB_                                    (128 * 1024)
+
+enum ESPI_TAF_MODE {
+	ESPI_TAF_STANDARD_MODE                     = 0,
+	ESPI_TAF_AUTO_MODE                         = 1,
+};
+
+enum ESPI_FLASH_TAF_REQ {
+	ESPI_FLASH_TAF_REQ_READ                    = 0,
+	ESPI_FLASH_TAF_REQ_WRITE                   = 1,
+	ESPI_FLASH_TAF_REQ_ERASE                   = 2,
+	ESPI_FLASH_TAF_REQ_RPMC_OP1                = 3,
+	ESPI_FLASH_TAF_REQ_RPMC_OP2                = 4,
+	ESPI_FLASH_TAF_REQ_UNKNOWN                 = 5,
+};
+
+/* ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_4KB is default */
+enum ESPI_FLASH_TAF_ERASE_BLOCK_SIZE {
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_1KB        = 0,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_2KB        = 1,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_4KB        = 2,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_8KB        = 3,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_16KB       = 4,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_32KB       = 5,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_64KB       = 6,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_128KB      = 7,
+};
+
+/* ESPI_FLASH_TAF_MAX_READ_REQ_64B is default */
+enum ESPI_FLASH_TAF_MAX_READ_REQ {
+	ESPI_FLASH_TAF_MAX_READ_REQ_64B            = 1,
+	ESPI_FLASH_TAF_MAX_READ_REQ_128B           = 2,
+	ESPI_FLASH_TAF_MAX_READ_REQ_256B           = 3,
+	ESPI_FLASH_TAF_MAX_READ_REQ_512B           = 4,
+	ESPI_FLASH_TAF_MAX_READ_REQ_1024B          = 5,
+	ESPI_FLASH_TAF_MAX_READ_REQ_2048B          = 6,
+	ESPI_FLASH_TAF_MAX_READ_REQ_4096B          = 7,
+};
+
+struct espi_saf_hw_cfg {
+	uint8_t  version;
+	enum ESPI_TAF_MODE mode;
+};
+
+struct espi_saf_pr {
+	uint32_t start;
+	uint32_t end;
+	uint16_t override_r;
+	uint16_t override_w;
+	uint8_t  master_bm_we;
+	uint8_t  master_bm_rd;
+	uint8_t  pr_num;
+	uint8_t  flags;
+};
+
+struct espi_saf_protection {
+	size_t nregions;
+	const struct espi_saf_pr *pregions;
+};
+
+struct espi_taf_npcx_pckt {
+	uint8_t tag;
+	uint8_t *data;
+};
+
+struct espi_saf_packet;
+
+struct espi_taf_pckt {
+	uint8_t  type;
+	uint8_t  tag;
+	uint32_t addr;
+	uint16_t len;
+	uint32_t src[16];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/soc/arm/nuvoton_npcx/common/soc_miwu.h b/soc/arm/nuvoton_npcx/common/soc_miwu.h
index c7b51b4f21..2284e9d619 100644
--- a/soc/arm/nuvoton_npcx/common/soc_miwu.h
+++ b/soc/arm/nuvoton_npcx/common/soc_miwu.h
@@ -50,6 +50,12 @@ enum miwu_int_trig {
 	NPCX_MIWU_TRIG_BOTH, /** Both edge rising and failing detection */
 };
 
+/* NPCX miwu driver callback type */
+enum {
+	NPCX_MIWU_CALLBACK_GPIO,
+	NPCX_MIWU_CALLBACK_DEV,
+};
+
 /**
  * @brief NPCX wake-up input source structure
  *
@@ -79,46 +85,50 @@ typedef void (*miwu_dev_callback_handler_t)(const struct device *source,
  */
 struct miwu_io_params {
 	uint8_t pin_mask; /** A mask of pins the callback is interested in. */
-	uint8_t reserved;
 	uint8_t gpio_port; /** GPIO device index */
+	uint8_t cb_type; /** Callback type */
 	struct npcx_wui wui; /** Wake-up input source of GPIO */
 };
 
 /**
- * @brief MIWU callback structure for a GPIO input
+ * @brief MIWU/generic device information structure
  *
- * Used to register a GPIO callback in the driver instance callback list.
- * Beware such structure should not be allocated on stack and its size must
- * equal struct gpio_callback.
- *
- * Note: To help setting it, see npcx_miwu_init_gpio_callback() below
+ * It contains the information used for MIWU generic device event. Please notice
+ * the offset of cb_type must be the same as cb_type in struct miwu_io_params.
  */
-struct miwu_io_callback {
-	/** Node of single-linked list */
-	sys_snode_t node;
-	/** Callback function being called when GPIO event occurred */
-	gpio_callback_handler_t handler;
-	/** GPIO callback parameters used in MIWU ISR */
-	struct miwu_io_params params;
+struct miwu_dev_params {
+	uint8_t reserve1;
+	uint8_t reserve2;
+	uint8_t cb_type; /** Callback type */
+	struct npcx_wui wui; /** Device instance register callback function */
+	const struct device *source; /** Wake-up input source */
 };
 
 /**
- * @brief MIWU callback structure for a device input
+ * @brief MIWU callback structure for a gpio or device input
  *
- * Used to register a generic hardware device callback in the driver instance
+ * Used to register a generic gpio/device callback in the driver instance
  * callback list. Beware such structure should not be allocated on stack.
  *
- * Note: To help setting it, see npcx_miwu_init_dev_callback() below
+ * Note: To help setting it, see npcx_miwu_init_dev_callback() and
+ *       npcx_miwu_manage_callback() below
  */
-struct miwu_dev_callback {
+struct miwu_callback {
 	/** Node of single-linked list */
 	sys_snode_t node;
-	/** Callback function being called when device event occurred */
-	miwu_dev_callback_handler_t handler;
-	/** Device instance register callback function */
-	const struct device *source;
-	/* Wake-up input source */
-	struct npcx_wui wui;
+	union {
+		struct {
+			/** Callback function being called when GPIO event occurred */
+			gpio_callback_handler_t handler;
+			struct miwu_io_params params;
+		} io_cb;
+
+		struct {
+			/** Callback function being called when device event occurred */
+			miwu_dev_callback_handler_t handler;
+			struct miwu_dev_params params;
+		} dev_cb;
+	};
 };
 
 /**
@@ -181,50 +191,38 @@ int npcx_miwu_interrupt_configure(const struct npcx_wui *wui,
 		enum miwu_int_mode mode, enum miwu_int_trig trig);
 
 /**
- * @brief Function to initialize a struct miwu_io_callback properly
+ * @brief Function to initialize a struct miwu_callback with gpio properly
  *
  * @param callback Pointer to io callback structure for initialization
  * @param io_wui Pointer to wake-up input IO source
  * @param port GPIO port issued a callback function
  */
-void npcx_miwu_init_gpio_callback(struct miwu_io_callback *callback,
+void npcx_miwu_init_gpio_callback(struct miwu_callback *callback,
 				const struct npcx_wui *io_wui, int port);
 
 /**
- * @brief Function to initialize a struct miwu_dev_callback properly
+ * @brief Function to initialize a struct miwu_callback with device properly
  *
  * @param callback Pointer to device callback structure for initialization
  * @param dev_wui Pointer to wake-up input device source
  * @param handler A function called when its device input event issued
  * @param source Pointer to device instance issued a callback function
  */
-void npcx_miwu_init_dev_callback(struct miwu_dev_callback *callback,
+void npcx_miwu_init_dev_callback(struct miwu_callback *callback,
 				const struct npcx_wui *dev_wui,
 				miwu_dev_callback_handler_t handler,
 				const struct device *source);
 
 /**
- * @brief Function to insert or remove a IO callback from a callback list
- *
- * @param callback Pointer to io callback structure
- * @param set A boolean indicating insertion or removal of the callback
- *
- * @retval 0 If successful.
- * @retval -EINVAL Invalid parameters
- */
-int npcx_miwu_manage_gpio_callback(struct miwu_io_callback *callback, bool set);
-
-
-/**
- * @brief Function to insert or remove a device callback from a callback list
+ * @brief Function to insert or remove a miwu callback from a callback list
  *
- * @param callback Pointer to device callback structure
+ * @param callback Pointer to miwu callback structure
  * @param set A boolean indicating insertion or removal of the callback
  *
  * @retval 0 If successful.
  * @retval -EINVAL Invalid parameters
  */
-int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set);
+int npcx_miwu_manage_callback(struct miwu_callback *cb, bool set);
 
 #ifdef __cplusplus
 }
diff --git a/soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt b/soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt
new file mode 100644
index 0000000000..f78735512f
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: Apache-2.0
+
+zephyr_include_directories(${ZEPHYR_BASE}/drivers)
+
+zephyr_sources(
+  soc.c
+)
+
+# set(SOC_LINKER_SCRIPT ${ZEPHYR_BASE}/include/zephyr/arch/arm/aarch32/cortex_m/scripts/linker.ld CACHE INTERNAL "")
+
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f
new file mode 100644
index 0000000000..d56b4fac92
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f
@@ -0,0 +1,11 @@
+# Nuvoton Cortex-M4 Embedded Controller
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_NPCX4M3F
+
+config SOC
+	default "npcx4m3f"
+
+endif # SOC_NPCX4M3F
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f
new file mode 100644
index 0000000000..00ba5b3b62
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f
@@ -0,0 +1,11 @@
+# Nuvoton Cortex-M4 Embedded Controller
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_NPCX4M8F
+
+config SOC
+	default "npcx4m8f"
+
+endif # SOC_NPCX4M8F
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series
new file mode 100644
index 0000000000..171489c0d1
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series
@@ -0,0 +1,28 @@
+# Nuvoton Cortex-M4 Embedded Controller
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_SERIES_NPCX4
+
+config SOC_SERIES
+	default "npcx4"
+
+config NUM_IRQS
+	default 128
+
+config CORTEX_M_SYSTICK
+	default !NPCX_ITIM_TIMER
+
+config ESPI_NPCX
+	default y
+	depends on ESPI
+
+config ESPI_TAF_NPCX
+    bool "ESPI TAF configuration option"
+	default y
+	depends on ESPI_SAF
+
+source "soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4*"
+
+endif # SOC_SERIES_NPCX4
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.series b/soc/arm/nuvoton_npcx/npcx4/Kconfig.series
new file mode 100644
index 0000000000..1585ace4e9
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.series
@@ -0,0 +1,16 @@
+# Nuvoton Cortex-M4 Embedded Controller NPCX4 series
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config SOC_SERIES_NPCX4
+	bool "Nuvoton NPCX4 Series"
+	select ARM
+	select CPU_CORTEX_M4
+	select CPU_CORTEX_M_HAS_DWT
+	select CPU_HAS_FPU
+	select CPU_HAS_ARM_MPU
+	select SOC_FAMILY_NPCX
+	select HAS_PM
+	help
+	  Enable support for Nuvoton NPCX4 series
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.soc b/soc/arm/nuvoton_npcx/npcx4/Kconfig.soc
new file mode 100644
index 0000000000..3e5f5e1d19
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.soc
@@ -0,0 +1,16 @@
+# Nuvoton NPCX4 EC series
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+choice
+	prompt "NPCX4 Selection"
+	depends on SOC_SERIES_NPCX4
+
+config SOC_NPCX4M3F
+	bool "NPCX4M3F"
+
+config SOC_NPCX4M8F
+	bool "NPCX4M8F"
+
+endchoice
diff --git a/soc/arm/nuvoton_npcx/npcx4/linker.ld b/soc/arm/nuvoton_npcx/npcx4/linker.ld
new file mode 100644
index 0000000000..4856bf0a71
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/linker.ld
@@ -0,0 +1,9 @@
+/* linker.ld - Linker command/script file */
+
+/*
+ * Copyright (c) 2020 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/arch/arm/aarch32/cortex_m/scripts/linker.ld>
diff --git a/soc/arm/nuvoton_npcx/npcx4/soc.c b/soc/arm/nuvoton_npcx/npcx4/soc.c
new file mode 100644
index 0000000000..28b868bda6
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/soc.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/kernel.h>
+#include <zephyr/device.h>
+#include <zephyr/init.h>
+#include <soc.h>
+#include <zephyr/logging/log.h>
+
+LOG_MODULE_REGISTER(soc, CONFIG_SOC_LOG_LEVEL);
+
+#define NPCX_FIU_INST_INIT(node_id) DT_REG_ADDR(node_id),
+
+static uintptr_t fiu_insts[] = {
+	DT_FOREACH_STATUS_OKAY(nuvoton_npcx_fiu_qspi, NPCX_FIU_INST_INIT)
+};
+
+static int soc_npcx4_init(void)
+{
+	/*
+	 * Make sure UMA_ADDR_SIZE field of UMA_ECTS register is zero in npcx4
+	 * series. There should be no address field in UMA mode by default.
+	 */
+	for (int i = 0; i < ARRAY_SIZE(fiu_insts); i++) {
+		struct fiu_reg *const inst = (struct fiu_reg *)(fiu_insts[i]);
+
+		SET_FIELD(inst->UMA_ECTS, NPCX_UMA_ECTS_UMA_ADDR_SIZE, 0);
+	}
+
+	return 0;
+}
+
+SYS_INIT(soc_npcx4_init, PRE_KERNEL_1, 0);
diff --git a/soc/arm/nuvoton_npcx/npcx4/soc.h b/soc/arm/nuvoton_npcx/npcx4/soc.h
new file mode 100644
index 0000000000..c1614169f1
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/soc.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _NUVOTON_NPCX_SOC_H_
+#define _NUVOTON_NPCX_SOC_H_
+
+/* CMSIS required definitions */
+#define __FPU_PRESENT  CONFIG_CPU_HAS_FPU
+#define __MPU_PRESENT  CONFIG_CPU_HAS_ARM_MPU
+
+/* NPCX4 SCFG multi-registers */
+#define NPCX_DEVALT_OFFSET(n)		(0x010 + n)
+#define NPCX_PUPD_EN_OFFSET(n)		(0x02b + n)
+#define NPCX_LV_GPIO_CTL_OFFSET(n)	(0x150 + n)
+#define NPCX_DEVALT_LK_OFFSET(n)	(0x210 + n)
+
+/* NPCX4 MIWU multi-registers */
+#define NPCX_WKEDG_OFFSET(n)		(0x000 + (n * 0x010))
+#define NPCX_WKAEDG_OFFSET(n)		(0x001 + (n * 0x010))
+#define NPCX_WKMOD_OFFSET(n)		(0x002 + (n * 0x010))
+#define NPCX_WKPND_OFFSET(n)		(0x003 + (n * 0x010))
+#define NPCX_WKPCL_OFFSET(n)		(0x004 + (n * 0x010))
+#define NPCX_WKEN_OFFSET(n)		(0x005 + (n * 0x010))
+#define NPCX_WKST_OFFSET(n)		(0x006 + (n * 0x010))
+#define NPCX_WKINEN_OFFSET(n)		(0x007 + (n * 0x010))
+
+/* NPCX4 PMC multi-registers */
+#define NPCX_PWDWN_CTL_OFFSET(n)	((n < 6) ? (0x008 + n) : (0x01e + n))
+
+/* NPCX4 ADC multi-registers */
+#define NPCX_CHNDAT_OFFSET(n)		(0x040 + n * 2)
+#define NPCX_THRCTL_OFFSET(n)		(0x080 + n * 2)
+#define NPCX_THEN_OFFSET		0x090
+#define THEN(base)			(*(volatile uint16_t *)(base + NPCX_THEN_OFFSET))
+
+/* NPCX4 ADC register fields */
+#define NPCX_THRCTL_L_H			15
+#define NPCX_THRCTL_CHNSEL		FIELD(10, 5)
+#define NPCX_THRCTL_THRVAL		FIELD(0, 10)
+
+/* NPCX4 FIU register fields */
+#define NPCX_FIU_EXT_CFG_SPI1_2DEV	6
+
+/* NPCX4 supported group mask of DEVALT_LK */
+#define NPCX_DEVALT_LK_GROUP_MASK \
+	(BIT(0) | BIT(2) | BIT(3) | BIT(4) | \
+	 BIT(5) | BIT(6) | BIT(11) | BIT(13) | \
+	 BIT(15) | BIT(16) | BIT(17) | BIT(18) | \
+	 BIT(19) | BIT(21))	/* DEVALT0_LK - DEVALTN_LK */
+
+/* NPCX4 Clock Configuration */
+#define MAX_OFMCLK 120000000
+
+#include <reg/reg_access.h>
+#include <reg/reg_def.h>
+#include <soc_dt.h>
+#include <soc_clock.h>
+#include <soc_pins.h>
+#include <soc_power.h>
+
+/* NPCX4 Clock prescaler configurations */
+#define VAL_HFCGP   ((FPRED_VAL << 4) | AHB6DIV_VAL)
+#define VAL_HFCBCD  ((FIU1DIV_VAL << 4) | (FIUDIV_VAL << 2))
+#define VAL_HFCBCD1 (APB1DIV_VAL | (APB2DIV_VAL << 4))
+#define VAL_HFCBCD2 (APB3DIV_VAL | (APB4DIV_VAL << 4))
+
+#endif /* _NUVOTON_NPCX_SOC_H_ */
-- 
2.43.0.windows.1

