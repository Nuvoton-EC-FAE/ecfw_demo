From 451a557d66bac81d8cc986f954f5a7c84b7a3aff Mon Sep 17 00:00:00 2001
From: BrookLiu <brookliu888@gmail.com>
Date: Fri, 29 Dec 2023 08:52:40 +0800
Subject: [PATCH] soc: porting NPCX4 series to Zephyr v3.2

---
 drivers/adc/Kconfig.npcx                      |   16 +
 drivers/adc/adc_npcx.c                        |  253 ++--
 drivers/bbram/bbram_npcx.c                    |    9 +-
 drivers/clock_control/Kconfig.npcx            |   12 +
 .../clock_control/clock_control_mchp_xec.c    |   12 +-
 drivers/clock_control/clock_control_npcx.c    |   69 +-
 drivers/console/uart_console.c                |    2 +-
 drivers/crypto/CMakeLists.txt                 |    1 +
 drivers/crypto/Kconfig                        |    1 +
 drivers/crypto/Kconfig.npcx                   |   11 +
 drivers/crypto/crypto_npcx_sha.c              |  216 +++
 drivers/espi/CMakeLists.txt                   |    6 +-
 drivers/espi/Kconfig                          |   17 +-
 drivers/espi/Kconfig.npcx                     |   51 +
 drivers/espi/Kconfig.xec                      |  125 +-
 drivers/espi/espi_mchp_xec.c                  |   41 +-
 drivers/espi/espi_npcx.c                      |  159 ++-
 drivers/espi/espi_saf_mchp_xec_v2.c           | 1175 +++++++++++++++++
 drivers/espi/espi_taf_npcx.c                  |  491 +++++++
 drivers/espi/host_subs_npcx.c                 |  126 +-
 drivers/flash/CMakeLists.txt                  |    3 +-
 drivers/flash/Kconfig                         |    2 +
 drivers/flash/Kconfig.npcx_fiu                |   73 +
 drivers/flash/flash_npcx_fiu_nor.c            |  623 +++++++++
 drivers/flash/flash_npcx_fiu_qspi.c           |  340 +++++
 drivers/flash/flash_npcx_fiu_qspi.h           |   88 ++
 drivers/gpio/gpio_npcx.c                      |   20 +-
 drivers/i2c/CMakeLists.txt                    |    2 +-
 drivers/i2c/Kconfig.npcx                      |   29 +-
 drivers/i2c/i2c_npcx_controller.c             |  933 ++++++++++---
 drivers/i2c/i2c_npcx_controller.h             |   26 +
 drivers/i2c/i2c_npcx_port.c                   |   38 +-
 drivers/interrupt_controller/Kconfig          |   13 +
 .../interrupt_controller/intc_mchp_ecia_xec.c |    2 +-
 drivers/interrupt_controller/intc_miwu.c      |  151 +--
 drivers/led/CMakeLists.txt                    |    1 +
 drivers/led/Kconfig                           |    1 +
 drivers/led/Kconfig.xec                       |   11 +
 drivers/led/led_mchp_xec.c                    |  292 ++++
 drivers/peci/peci_mchp_xec.c                  |    3 +
 drivers/peci/peci_npcx.c                      |    8 +-
 drivers/pinctrl/pinctrl_npcx.c                |   41 +-
 drivers/ps2/Kconfig.npcx                      |    3 +-
 drivers/ps2/ps2_npcx_controller.c             |    4 +-
 drivers/pwm/pwm_npcx.c                        |    8 +-
 drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig   |   28 +
 .../nuvoton_adc_cmp_npcx/adc_cmp_npcx.c       |   41 +-
 .../nuvoton_tach_npcx/tach_nuvoton_npcx.c     |   10 +-
 drivers/serial/uart_npcx.c                    |  112 +-
 drivers/spi/CMakeLists.txt                    |    2 +-
 drivers/spi/Kconfig                           |    2 +-
 drivers/timer/npcx_itim_timer.c               |   11 +-
 drivers/watchdog/wdt_npcx.c                   |   30 +-
 dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi  |    2 +-
 dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi  |    3 -
 dts/arm/nuvoton/npcx/npcx.dtsi                |  681 ++++++++++
 dts/arm/nuvoton/npcx/npcx4.dtsi               |  325 +++++
 .../nuvoton/npcx/npcx4/npcx4-alts-map.dtsi    |  184 +++
 .../npcx/npcx4/npcx4-espi-vws-map.dtsi        |   58 +
 .../npcx/npcx4/npcx4-lvol-ctrl-map.dtsi       |  183 +++
 .../npcx/npcx4/npcx4-miwus-int-map.dtsi       |   76 ++
 .../npcx/npcx4/npcx4-miwus-wui-map.dtsi       |   99 ++
 dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi |  558 ++++++++
 dts/arm/nuvoton/npcx4m3f.dtsi                 |   42 +
 dts/arm/nuvoton/npcx4m8f.dtsi                 |   42 +
 dts/bindings/clock/nuvoton,npcx-pcc.yaml      |  385 +++---
 dts/bindings/espi/nuvoton,npcx-espi.yaml      |   54 +-
 dts/bindings/iio/adc/nuvoton,npcx-adc.yaml    |   42 +-
 include/zephyr/dt-bindings/clock/npck_clock.h |   32 +
 include/zephyr/dt-bindings/clock/npcx_clock.h |    2 +
 .../flash_controller/npcx_fiu_qspi.h          |   28 +
 .../dt-bindings/gpio/nuvoton-npcx-gpio.h      |   30 +
 soc/arm/nuvoton_npcx/Kconfig                  |    6 +-
 soc/arm/nuvoton_npcx/common/ecst/ecst.py      |    6 +-
 soc/arm/nuvoton_npcx/common/ecst/ecst_args.py |    5 +-
 soc/arm/nuvoton_npcx/common/pinctrl_soc.h     |   37 +
 soc/arm/nuvoton_npcx/common/reg/reg_access.h  |    4 +
 soc/arm/nuvoton_npcx/common/reg/reg_def.h     |  767 +++++++----
 soc/arm/nuvoton_npcx/common/registers.c       |   46 +-
 soc/arm/nuvoton_npcx/common/scfg.c            |   42 +-
 soc/arm/nuvoton_npcx/common/soc_clock.h       |   55 +-
 soc/arm/nuvoton_npcx/common/soc_dbg.h         |   26 +
 soc/arm/nuvoton_npcx/common/soc_espi_taf.h    |  138 ++
 soc/arm/nuvoton_npcx/common/soc_miwu.h        |   84 +-
 soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt     |   10 +
 .../npcx4/Kconfig.defconfig.npcx4m3f          |   11 +
 .../npcx4/Kconfig.defconfig.npcx4m8f          |   11 +
 .../npcx4/Kconfig.defconfig.series            |   28 +
 soc/arm/nuvoton_npcx/npcx4/Kconfig.series     |   16 +
 soc/arm/nuvoton_npcx/npcx4/Kconfig.soc        |   16 +
 soc/arm/nuvoton_npcx/npcx4/linker.ld          |    9 +
 soc/arm/nuvoton_npcx/npcx4/soc.c              |   36 +
 soc/arm/nuvoton_npcx/npcx4/soc.h              |   70 +
 93 files changed, 8836 insertions(+), 1157 deletions(-)
 create mode 100644 drivers/crypto/Kconfig.npcx
 create mode 100644 drivers/crypto/crypto_npcx_sha.c
 create mode 100644 drivers/espi/espi_saf_mchp_xec_v2.c
 create mode 100644 drivers/espi/espi_taf_npcx.c
 create mode 100644 drivers/flash/Kconfig.npcx_fiu
 create mode 100644 drivers/flash/flash_npcx_fiu_nor.c
 create mode 100644 drivers/flash/flash_npcx_fiu_qspi.c
 create mode 100644 drivers/flash/flash_npcx_fiu_qspi.h
 create mode 100644 drivers/led/Kconfig.xec
 create mode 100644 drivers/led/led_mchp_xec.c
 create mode 100644 dts/arm/nuvoton/npcx/npcx.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi
 create mode 100644 dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
 create mode 100644 dts/arm/nuvoton/npcx4m3f.dtsi
 create mode 100644 dts/arm/nuvoton/npcx4m8f.dtsi
 create mode 100644 include/zephyr/dt-bindings/clock/npck_clock.h
 create mode 100644 include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h
 create mode 100644 include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h
 mode change 100755 => 100644 soc/arm/nuvoton_npcx/common/ecst/ecst.py
 mode change 100755 => 100644 soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
 create mode 100644 soc/arm/nuvoton_npcx/common/soc_dbg.h
 create mode 100644 soc/arm/nuvoton_npcx/common/soc_espi_taf.h
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.series
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/Kconfig.soc
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/linker.ld
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/soc.c
 create mode 100644 soc/arm/nuvoton_npcx/npcx4/soc.h

diff --git a/drivers/adc/Kconfig.npcx b/drivers/adc/Kconfig.npcx
index 8f48aefe76..0209fd845d 100644
--- a/drivers/adc/Kconfig.npcx
+++ b/drivers/adc/Kconfig.npcx
@@ -11,3 +11,19 @@ config ADC_NPCX
 	  This option enables the ADC driver for NPCX family of
 	  processors.
 	  Say y if you wish to use ADC channels on NPCX MCU.
+
+if ADC_NPCX
+
+config ADC_NPCX_CMP_V1
+	bool "ADC comparator version 1 support"
+	default y if SOC_SERIES_NPCX7 || SOC_SERIES_NPCX9
+	help
+	  This option enables ADC comparator V1 support.
+
+config ADC_NPCX_CMP_V2
+	bool "ADC comparator version 2 support"
+	default y if SOC_SERIES_NPCX4
+	help
+	  This option enables ADC comparator V2 support.
+
+endif #ADC_NPCX
diff --git a/drivers/adc/adc_npcx.c b/drivers/adc/adc_npcx.c
index aeae39fdef..cfbcb929d0 100644
--- a/drivers/adc/adc_npcx.c
+++ b/drivers/adc/adc_npcx.c
@@ -19,42 +19,48 @@
 #include "adc_context.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(adc_npcx, CONFIG_ADC_LOG_LEVEL);
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+/* ADC speed/delay values during initialization */
+#define ADC_REGULAR_DLY_VAL	0x02
+#define ADC_REGULAR_ADCCNF2_VAL	0x8901
+#define ADC_REGULAR_GENDLY_VAL	0x0100
+#define ADC_REGULAR_MEAST_VAL	0x0405
+#else
 /* ADC speed/delay values during initialization */
 #define ADC_REGULAR_DLY_VAL	0x03
 #define ADC_REGULAR_ADCCNF2_VAL	0x8B07
 #define ADC_REGULAR_GENDLY_VAL	0x0100
 #define ADC_REGULAR_MEAST_VAL	0x0001
-
-/* ADC channel number */
-#define NPCX_ADC_CH_COUNT DT_INST_PROP(0, channel_count)
+#endif
 
 /* ADC targeted operating frequency (2MHz) */
 #define NPCX_ADC_CLK 2000000
 
-/* ADC internal reference voltage (Unit:mV) */
-#define NPCX_ADC_VREF_VOL 2816
-
 /* ADC conversion mode */
 #define NPCX_ADC_CHN_CONVERSION_MODE	0
 #define NPCX_ADC_SCAN_CONVERSION_MODE	1
 
+/* Max channel number to be converted in ADCCS */
+#define NPCX_ADCCS_MAX_CHANNEL_COUNT	16
+
 #define ADC_NPCX_THRVAL_RESOLUTION	10
 #define ADC_NPCX_THRVAL_MAX		BIT_MASK(ADC_NPCX_THRVAL_RESOLUTION)
 
-#define THRCTL(dev, ctl_no) (*((volatile uint16_t *) npcx_thrctl_reg(dev, ctl_no)))
-
 /* Device config */
 struct adc_npcx_config {
 	/* adc controller base address */
 	uintptr_t base;
 	/* clock configuration */
 	struct npcx_clk_cfg clk_cfg;
+	/* the number of ADC channels */
+	const uint8_t channel_count;
 	/* amount of thresholds supported */
 	const uint8_t threshold_count;
-	/* threshold control register offset */
-	const uint16_t threshold_reg_offset;
+	/* routine for configuring ADC's ISR */
+	void (*irq_cfg_func)(void);
 	const struct pinctrl_dev_config *pcfg;
 };
 
@@ -74,7 +80,7 @@ struct adc_npcx_threshold_control {
 	/* Sets the threshold value to which measured data is compared. */
 	uint16_t thrval;
 	/*
-	 * Pointer of work queue thread to be notified when threshold assertion
+	 * Pointer of work queue item to be notified when threshold assertion
 	 * occurs.
 	 */
 	struct k_work *work;
@@ -87,7 +93,7 @@ struct adc_npcx_threshold_data {
 	 * channels being used in repetitive mode in order to set ADC registers
 	 * back to threshold detection when adc_npcx_read is completed.
 	 */
-	uint16_t repetitive_channels;
+	uint32_t repetitive_channels;
 	/*
 	 * While threshold interruption is enabled, adc_npcx_read must disable
 	 * all active threshold running to avoid race condition, this variable
@@ -109,7 +115,7 @@ struct adc_npcx_data {
 	 * Bit-mask indicating the channels to be included in each sampling
 	 * of this sequence.
 	 */
-	uint16_t channels;
+	uint32_t channels;
 	/* ADC Device pointer used in api functions */
 	const struct device *adc_dev;
 	uint16_t *buffer;
@@ -123,6 +129,12 @@ struct adc_npcx_data {
 #endif
 };
 
+/*
+ * Pointer of internal work queue thread to be notified when threshold assertion
+ * occurs if CONFIG_ADC_CMP_NPCX_WORKQUEUE is enabled.
+ */
+struct k_work_q *work_q;
+
 /* Driver convenience defines */
 #define HAL_INSTANCE(dev) ((struct adc_reg *)((const struct adc_npcx_config *)(dev)->config)->base)
 
@@ -144,12 +156,39 @@ static void adc_npcx_pm_policy_state_lock_put(struct adc_npcx_data *data)
 }
 #endif
 
-static inline uint32_t npcx_thrctl_reg(const struct device *dev,
-				       uint32_t ctl_no)
+static inline void adc_npcx_config_channels(const struct device *dev, uint32_t channels)
 {
 	const struct adc_npcx_config *config = dev->config;
+	struct adc_reg *const inst = HAL_INSTANCE(dev);
+
+	inst->ADCCS = channels & BIT_MASK(NPCX_ADCCS_MAX_CHANNEL_COUNT);
 
-	return (config->base + config->threshold_reg_offset) + (ctl_no - 1) * 2;
+	/* Only npcx4 and later series support over 16 ADC channels */
+	if (config->channel_count > NPCX_ADCCS_MAX_CHANNEL_COUNT) {
+		inst->ADCCS2 = (channels >> NPCX_ADCCS_MAX_CHANNEL_COUNT) &
+			       BIT_MASK(NPCX_ADCCS_MAX_CHANNEL_COUNT);
+	}
+}
+
+static inline void adc_npcx_enable_threshold_detect(const struct device *dev, uint8_t th_sel,
+						    bool enable)
+{
+	const struct adc_npcx_config *config = dev->config;
+
+	if (enable) {
+#ifdef CONFIG_ADC_NPCX_CMP_V2
+		THEN(config->base) |= BIT(th_sel);
+#else /* CONFIG_ADC_NPCX_CMP_V1 */
+		THRCTL(config->base, th_sel) |= BIT(NPCX_THRCTL_THEN);
+#endif
+
+	} else {
+#ifdef CONFIG_ADC_NPCX_CMP_V2
+		THEN(config->base) &= ~BIT(th_sel);
+#else /* CONFIG_ADC_NPCX_CMP_V1 */
+		THRCTL(config->base, th_sel) &= ~BIT(NPCX_THRCTL_THEN);
+#endif
+	}
 }
 
 static void adc_npcx_isr(const struct device *dev)
@@ -192,12 +231,12 @@ static void adc_npcx_isr(const struct device *dev)
 		if (IS_ENABLED(CONFIG_ADC_CMP_NPCX) &&
 		    t_data->active_thresholds) {
 			/* Set repetitive channels back */
-			inst->ADCCS = t_data->repetitive_channels;
+			adc_npcx_config_channels(dev, t_data->repetitive_channels);
 			/* Start conversion */
 			inst->ADCCNF |= BIT(NPCX_ADCCNF_START);
 		} else {
 			/* Disable all channels */
-			inst->ADCCS = 0;
+			adc_npcx_config_channels(dev, 0);
 			/* Turn off ADC */
 			inst->ADCCNF &= ~(BIT(NPCX_ADCCNF_ADCEN));
 
@@ -223,9 +262,10 @@ static void adc_npcx_isr(const struct device *dev)
 			/* Clear threshold status */
 			thrcts |= BIT(i);
 			inst->THRCTS = thrcts;
-			/* Notify work thread */
 			if (t_data->control[i].work) {
-				k_work_submit(t_data->control[i].work);
+				/* Notify work thread */
+				k_work_submit_to_queue(work_q ? work_q : &k_sys_work_q,
+						       t_data->control[i].work);
 			}
 		}
 	}
@@ -238,11 +278,12 @@ static void adc_npcx_isr(const struct device *dev)
 static int adc_npcx_validate_buffer_size(const struct device *dev,
 					const struct adc_sequence *sequence)
 {
+	const struct adc_npcx_config *config = dev->config;
 	uint8_t channels = 0;
 	uint32_t mask;
 	size_t needed;
 
-	for (mask = BIT(NPCX_ADC_CH_COUNT - 1); mask != 0; mask >>= 1) {
+	for (mask = BIT(config->channel_count - 1); mask != 0; mask >>= 1) {
 		if (mask & sequence->channels) {
 			channels++;
 		}
@@ -262,6 +303,7 @@ static int adc_npcx_validate_buffer_size(const struct device *dev,
 
 static void adc_npcx_start_scan(const struct device *dev)
 {
+	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_data *const data = dev->data;
 	struct adc_reg *const inst = HAL_INSTANCE(dev);
 
@@ -278,7 +320,7 @@ static void adc_npcx_start_scan(const struct device *dev)
 	inst->ADCSTS |= BIT(NPCX_ADCSTS_EOCCEV);
 
 	/* Update selected channels in scan mode by channels mask */
-	inst->ADCCS |= data->channels;
+	adc_npcx_config_channels(dev, data->channels);
 
 	/* Select 'Scan' Conversion mode. */
 	SET_FIELD(inst->ADCCNF, NPCX_ADCCNF_ADCMD_FIELD,
@@ -290,18 +332,24 @@ static void adc_npcx_start_scan(const struct device *dev)
 	/* Start conversion */
 	inst->ADCCNF |= BIT(NPCX_ADCCNF_START);
 
-	LOG_DBG("Start ADC scan conversion and ADCCNF,ADCCS are (%04X,%04X)\n",
+	if (config->channel_count > NPCX_ADCCS_MAX_CHANNEL_COUNT) {
+		LOG_DBG("Start ADC scan conversion and ADCCNF,ADCCS, ADCCS2 are "
+			"(%04X,%04X,%04X)\n", inst->ADCCNF, inst->ADCCS, inst->ADCCS2);
+	} else {
+		LOG_DBG("Start ADC scan conversion and ADCCNF,ADCCS are (%04X,%04X)\n",
 			inst->ADCCNF, inst->ADCCS);
+	}
 }
 
 static int adc_npcx_start_read(const struct device *dev,
 					const struct adc_sequence *sequence)
 {
+	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_data *const data = dev->data;
 	int error = 0;
 
 	if (!sequence->channels ||
-	    (sequence->channels & ~BIT_MASK(NPCX_ADC_CH_COUNT))) {
+	    (sequence->channels & ~BIT_MASK(config->channel_count))) {
 		LOG_ERR("Invalid ADC channels");
 		return -EINVAL;
 	}
@@ -356,9 +404,10 @@ static void adc_context_update_buffer_pointer(struct adc_context *ctx,
 static int adc_npcx_channel_setup(const struct device *dev,
 				 const struct adc_channel_cfg *channel_cfg)
 {
+	const struct adc_npcx_config *config = dev->config;
 	uint8_t channel_id = channel_cfg->channel_id;
 
-	if (channel_id >= NPCX_ADC_CH_COUNT) {
+	if (channel_id >= config->channel_count) {
 		LOG_ERR("Invalid channel %d", channel_id);
 		return -EINVAL;
 	}
@@ -435,18 +484,21 @@ static void adc_npcx_set_repetitive(const struct device *dev, int chnsel,
 		/* Set ADC conversion code to SW conversion mode */
 		SET_FIELD(inst->ADCCNF, NPCX_ADCCNF_ADCMD_FIELD,
 			  NPCX_ADC_SCAN_CONVERSION_MODE);
-		/* Update number of channel to be converted */
-		inst->ADCCS |= BIT(chnsel);
+
+		/* Add selected ADC channel to be converted */
+		t_data->repetitive_channels |= BIT(chnsel);
+		adc_npcx_config_channels(dev, t_data->repetitive_channels);
+
 		/* Set conversion type to repetitive (runs continuously) */
 		inst->ADCCNF |= BIT(NPCX_ADCCNF_ADCRPTC);
 
-		t_data->repetitive_channels |= BIT(chnsel);
 		/* Start conversion */
 		inst->ADCCNF |= BIT(NPCX_ADCCNF_START);
 	} else {
-		inst->ADCCS &= ~BIT(chnsel);
-
+		/* Remove selected ADC channel to be converted */
 		t_data->repetitive_channels &= ~BIT(chnsel);
+		adc_npcx_config_channels(dev, t_data->repetitive_channels);
+
 		if (!t_data->repetitive_channels) {
 			/* No thesholdd active left, disable repetitive mode */
 			inst->ADCCNF &= ~BIT(NPCX_ADCCNF_ADCRPTC);
@@ -485,7 +537,7 @@ int adc_npcx_threshold_ctrl_set_param(const struct device *dev,
 	adc_context_lock(&data->ctx, false, NULL);
 	switch (param->type) {
 	case ADC_NPCX_THRESHOLD_PARAM_CHNSEL:
-		if (param->val >= NPCX_ADC_CH_COUNT) {
+		if (param->val >= config->channel_count) {
 			ret = -EINVAL;
 			break;
 		}
@@ -522,6 +574,7 @@ static int adc_npcx_threshold_ctrl_setup(const struct device *dev,
 					 const uint8_t th_sel)
 {
 	struct adc_npcx_data *const data = dev->data;
+	struct adc_driver_api *api = (struct adc_driver_api *)dev->api;
 	struct adc_npcx_threshold_data *const t_data = data->threshold_data;
 	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_threshold_control *const t_ctrl =
@@ -540,24 +593,24 @@ static int adc_npcx_threshold_ctrl_setup(const struct device *dev,
 		return -EBUSY;
 	}
 
-	if (t_ctrl->chnsel >= NPCX_ADC_CH_COUNT ||
-	    t_ctrl->thrval >= NPCX_ADC_VREF_VOL ||
+	if (t_ctrl->chnsel >= config->channel_count ||
+	    t_ctrl->thrval >= api->ref_internal ||
 	    t_ctrl->thrval == 0 || t_ctrl->work == 0) {
 		adc_context_release(&data->ctx, 0);
 		LOG_ERR("Threshold selected (%d) is not configured!", th_sel);
 		return -EINVAL;
 	}
 
-	SET_FIELD(THRCTL(dev, (th_sel + 1)),
+	SET_FIELD(THRCTL(config->base, th_sel),
 		  NPCX_THRCTL_CHNSEL, t_ctrl->chnsel);
 
 	if (t_ctrl->l_h) {
-		THRCTL(dev, (th_sel + 1)) |= BIT(NPCX_THRCTL_L_H);
+		THRCTL(config->base, th_sel) |= BIT(NPCX_THRCTL_L_H);
 	} else {
-		THRCTL(dev, (th_sel + 1)) &= ~BIT(NPCX_THRCTL_L_H);
+		THRCTL(config->base, th_sel) &= ~BIT(NPCX_THRCTL_L_H);
 	}
 	/* Set the threshold value. */
-	SET_FIELD(THRCTL(dev, (th_sel + 1)), NPCX_THRCTL_THRVAL,
+	SET_FIELD(THRCTL(config->base, th_sel), NPCX_THRCTL_THRVAL,
 		  t_ctrl->thrval);
 
 	adc_context_release(&data->ctx, 0);
@@ -568,6 +621,7 @@ static int adc_npcx_threshold_enable_irq(const struct device *dev,
 				  const uint8_t th_sel)
 {
 	struct adc_reg *const inst = HAL_INSTANCE(dev);
+	struct adc_driver_api *api = (struct adc_driver_api *)dev->api;
 	struct adc_npcx_data *const data = dev->data;
 	const struct adc_npcx_config *config = dev->config;
 	struct adc_npcx_threshold_data *const t_data = data->threshold_data;
@@ -581,8 +635,8 @@ static int adc_npcx_threshold_enable_irq(const struct device *dev,
 	}
 
 	adc_context_lock(&data->ctx, false, NULL);
-	if (t_ctrl->chnsel >= NPCX_ADC_CH_COUNT ||
-	    t_ctrl->thrval >= NPCX_ADC_VREF_VOL ||
+	if (t_ctrl->chnsel >= config->channel_count ||
+	    t_ctrl->thrval >= api->ref_internal ||
 	    t_ctrl->thrval == 0 || t_ctrl->work == 0) {
 		adc_context_release(&data->ctx, 0);
 		LOG_ERR("Threshold selected (%d) is not configured!", th_sel);
@@ -596,7 +650,7 @@ static int adc_npcx_threshold_enable_irq(const struct device *dev,
 	thrcts = inst->THRCTS & ~GENMASK(config->threshold_count - 1, 0);
 
 	/* Enable threshold detection */
-	THRCTL(dev, (th_sel + 1)) |= BIT(NPCX_THRCTL_THEN);
+	adc_npcx_enable_threshold_detect(dev, th_sel, true);
 
 	/* clear threshold status */
 	thrcts |= BIT(th_sel);
@@ -644,7 +698,7 @@ int adc_npcx_threshold_disable_irq(const struct device *dev,
 	inst->THRCTS = thrcts;
 
 	/* Disable threshold detection */
-	THRCTL(dev, (th_sel + 1)) &= ~BIT(NPCX_THRCTL_THEN);
+	adc_npcx_enable_threshold_detect(dev, th_sel, false);
 
 	/* Update active threshold */
 	t_data->active_thresholds &= ~BIT(th_sel);
@@ -679,59 +733,48 @@ int adc_npcx_threshold_ctrl_enable(const struct device *dev, uint8_t th_sel,
 	return ret;
 }
 
-int adc_npcx_threshold_mv_to_thrval(uint32_t val_mv, uint32_t *thrval)
+int adc_npcx_threshold_mv_to_thrval(const struct device *dev, uint32_t val_mv,
+								uint32_t *thrval)
 {
+	struct adc_driver_api *api = (struct adc_driver_api *)dev->api;
+
 	if (!IS_ENABLED(CONFIG_ADC_CMP_NPCX)) {
 		return -EOPNOTSUPP;
 	}
 
-	if (val_mv >= NPCX_ADC_VREF_VOL) {
+	if (val_mv >= api->ref_internal) {
 		return -EINVAL;
 	}
 
 	*thrval = (val_mv << ADC_NPCX_THRVAL_RESOLUTION) /
-		NPCX_ADC_VREF_VOL;
+		api->ref_internal;
 	return 0;
 }
 
-/* ADC driver registration */
-static const struct adc_driver_api adc_npcx_driver_api = {
-	.channel_setup = adc_npcx_channel_setup,
-	.read = adc_npcx_read,
-#if defined(CONFIG_ADC_ASYNC)
-	.read_async = adc_npcx_read_async,
-#endif
-	.ref_internal = NPCX_ADC_VREF_VOL,
-};
-
-static int adc_npcx_init(const struct device *dev);
+#if defined(CONFIG_ADC_CMP_NPCX_WORKQUEUE)
+struct k_work_q adc_npcx_work_q;
 
-PINCTRL_DT_INST_DEFINE(0);
-BUILD_ASSERT(DT_NUM_INST_STATUS_OKAY(DT_DRV_COMPAT) == 1,
-	"only one 'nuvoton_npcx_adc' compatible node may be present");
+static K_KERNEL_STACK_DEFINE(adc_npcx_work_q_stack,
+			CONFIG_ADC_CMP_NPCX_WORKQUEUE_STACK_SIZE);
 
-static const struct adc_npcx_config adc_npcx_cfg_0 = {
-	.base = DT_INST_REG_ADDR(0),
-	.clk_cfg = NPCX_DT_CLK_CFG_ITEM(0),
-	.threshold_count = DT_INST_PROP(0, threshold_count),
-	.threshold_reg_offset = DT_INST_PROP(0, threshold_reg_offset),
-	.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(0),
-};
+static int adc_npcx_init_cmp_work_q(void)
+{
+	struct k_work_queue_config cfg = {
+		.name = "adc_cmp_work",
+		.no_yield = false,
+	};
 
-static struct adc_npcx_threshold_data threshold_data_0;
+	k_work_queue_start(&adc_npcx_work_q,
+			   adc_npcx_work_q_stack,
+			   K_KERNEL_STACK_SIZEOF(adc_npcx_work_q_stack),
+			   CONFIG_ADC_CMP_NPCX_WORKQUEUE_PRIORITY, &cfg);
 
-static struct adc_npcx_data adc_npcx_data_0 = {
-	ADC_CONTEXT_INIT_TIMER(adc_npcx_data_0, ctx),
-	ADC_CONTEXT_INIT_LOCK(adc_npcx_data_0, ctx),
-	ADC_CONTEXT_INIT_SYNC(adc_npcx_data_0, ctx),
-};
+	work_q = &adc_npcx_work_q;
+	return 0;
+}
 
-DEVICE_DT_INST_DEFINE(0,
-		    adc_npcx_init, NULL,
-		    &adc_npcx_data_0, &adc_npcx_cfg_0,
-		    PRE_KERNEL_1,
-		    CONFIG_ADC_INIT_PRIORITY,
-		    &adc_npcx_driver_api);
+SYS_INIT(adc_npcx_init_cmp_work_q, POST_KERNEL, CONFIG_SENSOR_INIT_PRIORITY);
+#endif
 
 static int adc_npcx_init(const struct device *dev)
 {
@@ -750,14 +793,14 @@ static int adc_npcx_init(const struct device *dev)
 	data->adc_dev = dev;
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on ADC clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&config->clk_cfg, &data->input_clk);
 	if (ret < 0) {
 		LOG_ERR("Get ADC clock rate error %d", ret);
@@ -765,7 +808,7 @@ static int adc_npcx_init(const struct device *dev)
 	}
 
 	/* Configure the ADC clock */
-	prescaler = ceiling_fraction(data->input_clk, NPCX_ADC_CLK);
+	prescaler = DIV_ROUND_UP(data->input_clk, NPCX_ADC_CLK);
 	if (prescaler > 0x40) {
 		prescaler = 0x40;
 	}
@@ -781,14 +824,8 @@ static int adc_npcx_init(const struct device *dev)
 	inst->GENDLY = ADC_REGULAR_GENDLY_VAL;
 	inst->MEAST = ADC_REGULAR_MEAST_VAL;
 
-	if (IS_ENABLED(CONFIG_ADC_CMP_NPCX)) {
-		data->threshold_data = &threshold_data_0;
-	}
-
 	/* Configure ADC interrupt and enable it */
-	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority), adc_npcx_isr,
-			    DEVICE_DT_INST_GET(0), 0);
-	irq_enable(DT_INST_IRQN(0));
+	config->irq_cfg_func();
 
 	/* Initialize mutex of ADC channels */
 	adc_context_unlock_unconditionally(&data->ctx);
@@ -802,3 +839,45 @@ static int adc_npcx_init(const struct device *dev)
 
 	return 0;
 }
+
+#define NPCX_ADC_INIT(n)							\
+										\
+	static void adc_npcx_irq_cfg_func_##n(void)				\
+	{									\
+		IRQ_CONNECT(DT_INST_IRQN(n), DT_INST_IRQ(n, priority),		\
+			    adc_npcx_isr, DEVICE_DT_INST_GET(n), 0);		\
+		irq_enable(DT_INST_IRQN(n));					\
+	}									\
+										\
+	static const struct adc_driver_api adc_npcx_driver_api_##n = {		\
+		.channel_setup = adc_npcx_channel_setup,			\
+		.read = adc_npcx_read,						\
+		.ref_internal = DT_INST_PROP(n, vref_mv),			\
+		IF_ENABLED(CONFIG_ADC_ASYNC,					\
+			(.read_async = adc_npcx_read_async,))			\
+	};									\
+										\
+	PINCTRL_DT_INST_DEFINE(n);						\
+										\
+	static const struct adc_npcx_config adc_npcx_cfg_##n = {		\
+		.base = DT_INST_REG_ADDR(n),					\
+		.clk_cfg = NPCX_DT_CLK_CFG_ITEM(n),				\
+		.channel_count = DT_INST_PROP(n, channel_count),		\
+		.threshold_count = DT_INST_PROP(n, threshold_count),		\
+		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),			\
+		.irq_cfg_func = adc_npcx_irq_cfg_func_##n,			\
+	};									\
+	static struct adc_npcx_threshold_data threshold_data_##n;		\
+	static struct adc_npcx_data adc_npcx_data_##n = {			\
+		ADC_CONTEXT_INIT_TIMER(adc_npcx_data_##n, ctx),			\
+		ADC_CONTEXT_INIT_LOCK(adc_npcx_data_##n, ctx),			\
+		ADC_CONTEXT_INIT_SYNC(adc_npcx_data_##n, ctx),			\
+		.threshold_data = &threshold_data_##n,				\
+	};									\
+	DEVICE_DT_INST_DEFINE(n,						\
+			     adc_npcx_init, NULL,				\
+			     &adc_npcx_data_##n, &adc_npcx_cfg_##n,		\
+			     PRE_KERNEL_1, CONFIG_ADC_INIT_PRIORITY,		\
+			     &adc_npcx_driver_api_##n);
+
+DT_INST_FOREACH_STATUS_OKAY(NPCX_ADC_INIT)
diff --git a/drivers/bbram/bbram_npcx.c b/drivers/bbram/bbram_npcx.c
index 87c5166b77..b9b02f90eb 100644
--- a/drivers/bbram/bbram_npcx.c
+++ b/drivers/bbram/bbram_npcx.c
@@ -99,13 +99,6 @@ static const struct bbram_driver_api bbram_npcx_driver_api = {
 	.write = bbram_npcx_write,
 };
 
-static int bbram_npcx_init(const struct device *dev)
-{
-	ARG_UNUSED(dev);
-
-	return 0;
-}
-
 #define BBRAM_INIT(inst)                                                                           \
 	static struct {                                                                            \
 	} bbram_data_##inst;                                                                       \
@@ -114,7 +107,7 @@ static int bbram_npcx_init(const struct device *dev)
 		.size = DT_INST_REG_SIZE_BY_NAME(inst, memory),                                    \
 		.status_reg_addr = DT_INST_REG_ADDR_BY_NAME(inst, status),                         \
 	};                                                                                         \
-	DEVICE_DT_INST_DEFINE(inst, bbram_npcx_init, NULL, &bbram_data_##inst, &bbram_cfg_##inst,  \
+	DEVICE_DT_INST_DEFINE(inst, NULL, NULL, &bbram_data_##inst, &bbram_cfg_##inst,             \
 			      PRE_KERNEL_1, CONFIG_BBRAM_INIT_PRIORITY, &bbram_npcx_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(BBRAM_INIT);
diff --git a/drivers/clock_control/Kconfig.npcx b/drivers/clock_control/Kconfig.npcx
index b4b91d5f8d..76e5acf985 100644
--- a/drivers/clock_control/Kconfig.npcx
+++ b/drivers/clock_control/Kconfig.npcx
@@ -18,3 +18,15 @@ config CLOCK_CONTROL_NPCX_EXTERNAL_SRC
 	  is generated by the on-chip Crystal Oscillator (XTOSC).
 	  This includes an on-chip oscillator, to which an external crystal
 	  and the related passive components are connected.
+
+config CLOCK_CONTROL_NPCX_SUPP_APB4
+	bool "Indicates that the clock controller supports APB4 bus"
+	default y if !SOC_SERIES_NPCX7
+	help
+	  Selected if NPCX series supports APB4 bus.
+
+config CLOCK_CONTROL_NPCX_SUPP_FIU1
+	bool "Indicates that the clock controller supports FIU1 bus"
+	default y if SOC_SERIES_NPCX4
+	help
+	  Selected if NPCX series supports FIU1 bus.
diff --git a/drivers/clock_control/clock_control_mchp_xec.c b/drivers/clock_control/clock_control_mchp_xec.c
index a8731704a8..42a9e5b57e 100644
--- a/drivers/clock_control/clock_control_mchp_xec.c
+++ b/drivers/clock_control/clock_control_mchp_xec.c
@@ -559,11 +559,19 @@ static int xec_clock_control_get_subsys_rate(const struct device *dev,
 	switch (bus) {
 	case MCHP_XEC_PCR_CLK_CORE:
 	case MCHP_XEC_PCR_CLK_PERIPH_FAST:
-		*rate = MHZ(96);
+		if (pcr->TURBO_CLK & MCHP_PCR_TURBO_CLK_96M) {
+			*rate = MHZ(96);
+		} else {
+			*rate = MHZ(48);
+		}
 		break;
 	case MCHP_XEC_PCR_CLK_CPU:
 		/* if PCR PROC_CLK_CTRL is 0 the chip is not running */
-		*rate = MHZ(96) / pcr->PROC_CLK_CTRL;
+		if (pcr->TURBO_CLK & MCHP_PCR_TURBO_CLK_96M) {
+			*rate = MHZ(96) / pcr->PROC_CLK_CTRL;
+		} else {
+			*rate = MHZ(48) / pcr->PROC_CLK_CTRL;
+		}
 		break;
 	case MCHP_XEC_PCR_CLK_BUS:
 	case MCHP_XEC_PCR_CLK_PERIPH:
diff --git a/drivers/clock_control/clock_control_npcx.c b/drivers/clock_control/clock_control_npcx.c
index 82199d6111..345e575646 100644
--- a/drivers/clock_control/clock_control_npcx.c
+++ b/drivers/clock_control/clock_control_npcx.c
@@ -8,8 +8,11 @@
 
 #include <soc.h>
 #include <zephyr/drivers/clock_control.h>
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+#include <zephyr/dt-bindings/clock/npck_clock.h>
+#else /* NPCX7, NPCX9 and so on NPCX series */
 #include <zephyr/dt-bindings/clock/npcx_clock.h>
-
+#endif
 #include <zephyr/logging/log.h>
 LOG_MODULE_REGISTER(clock_control_npcx, LOG_LEVEL_ERR);
 
@@ -28,6 +31,8 @@ struct npcx_pcc_config {
 #define HAL_PMC_INST(dev) \
 	((struct pmc_reg *)((const struct npcx_pcc_config *)(dev)->config)->base_pmc)
 
+static uint8_t pddwn_ctl_val[] = {NPCX_PWDWN_CTL_INIT};
+
 /* Clock controller local functions */
 static inline int npcx_clock_control_on(const struct device *dev,
 					 clock_control_subsys_t sub_system)
@@ -89,6 +94,11 @@ static int npcx_clock_control_get_subsys_rate(const struct device *dev,
 	case NPCX_CLOCK_BUS_FIU:
 		*rate = CORE_CLK/(FIUDIV_VAL + 1);
 		break;
+#if defined(FIU1DIV_VAL)
+	case NPCX_CLOCK_BUS_FIU1:
+		*rate = CORE_CLK/(FIU1DIV_VAL + 1);
+		break;
+#endif
 	case NPCX_CLOCK_BUS_CORE:
 		*rate = CORE_CLK;
 		break;
@@ -144,30 +154,36 @@ static struct clock_control_driver_api npcx_clock_control_api = {
 };
 
 /* valid clock frequency check */
-BUILD_ASSERT(CORE_CLK <= MHZ(100) && CORE_CLK >= MHZ(4) &&
+BUILD_ASSERT(OFMCLK <= MAX_OFMCLK, "Exceed maximum OFMCLK setting");
+BUILD_ASSERT(CORE_CLK <= MAX_OFMCLK && CORE_CLK >= MHZ(4) &&
 	     OFMCLK % CORE_CLK == 0 &&
 	     OFMCLK / CORE_CLK <= 10,
 	     "Invalid CORE_CLK setting");
-BUILD_ASSERT(CORE_CLK / (FIUDIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(CORE_CLK / (FIUDIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     CORE_CLK / (FIUDIV_VAL + 1) >= MHZ(4),
 	     "Invalid FIUCLK setting");
-BUILD_ASSERT(CORE_CLK / (AHB6DIV_VAL + 1) <= MHZ(50) &&
+#if defined(FIU1DIV_VAL)
+BUILD_ASSERT(CORE_CLK / (FIU1DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
+	     CORE_CLK / (FIU1DIV_VAL + 1) >= MHZ(4),
+	     "Invalid FIU1CLK setting");
+#endif
+BUILD_ASSERT(CORE_CLK / (AHB6DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     CORE_CLK / (AHB6DIV_VAL + 1) >= MHZ(4),
 	     "Invalid AHB6_CLK setting");
-BUILD_ASSERT(APBSRC_CLK / (APB1DIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(APBSRC_CLK / (APB1DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     APBSRC_CLK / (APB1DIV_VAL + 1) >= MHZ(4) &&
 	     (APB1DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB1_CLK setting");
-BUILD_ASSERT(APBSRC_CLK / (APB2DIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(APBSRC_CLK / (APB2DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     APBSRC_CLK / (APB2DIV_VAL + 1) >= MHZ(8) &&
 	     (APB2DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB2_CLK setting");
-BUILD_ASSERT(APBSRC_CLK / (APB3DIV_VAL + 1) <= MHZ(50) &&
+BUILD_ASSERT(APBSRC_CLK / (APB3DIV_VAL + 1) <= (MAX_OFMCLK / 2) &&
 	     APBSRC_CLK / (APB3DIV_VAL + 1) >= KHZ(12500) &&
 	     (APB3DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB3_CLK setting");
 #if defined(APB4DIV_VAL)
-BUILD_ASSERT(APBSRC_CLK / (APB4DIV_VAL + 1) <= MHZ(100) &&
+BUILD_ASSERT(APBSRC_CLK / (APB4DIV_VAL + 1) <= MAX_OFMCLK &&
 	     APBSRC_CLK / (APB4DIV_VAL + 1) >= MHZ(8) &&
 	     (APB4DIV_VAL + 1) % (FPRED_VAL + 1) == 0,
 	     "Invalid APB4_CLK setting");
@@ -205,36 +221,23 @@ static int npcx_clock_control_init(const struct device *dev)
 	}
 
 	/* Set all clock prescalers of core and peripherals. */
-	inst_cdcg->HFCGP   = ((FPRED_VAL << 4) | AHB6DIV_VAL);
-	inst_cdcg->HFCBCD  = (FIUDIV_VAL << 4);
-	inst_cdcg->HFCBCD1 = (APB1DIV_VAL | (APB2DIV_VAL << 4));
-#if defined(APB4DIV_VAL)
-	inst_cdcg->HFCBCD2 = (APB3DIV_VAL | (APB4DIV_VAL << 4));
-#else
-	inst_cdcg->HFCBCD2 = APB3DIV_VAL;
-#endif
+	inst_cdcg->HFCGP   = VAL_HFCGP;
+	inst_cdcg->HFCBCD  = VAL_HFCBCD;
+	inst_cdcg->HFCBCD1 = VAL_HFCBCD1;
+	inst_cdcg->HFCBCD2 = VAL_HFCBCD2;
 
 	/*
 	 * Power-down (turn off clock) the modules initially for better
 	 * power consumption.
 	 */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL1) = 0xFB; /* No SDP_PD/FIU_PD */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL2) = 0xFF;
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL3) = 0x1F; /* No GDMA_PD */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL4) = 0xFF;
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL5) = 0xFA;
-#if CONFIG_ESPI
-	/* Don't gate the clock of the eSPI module if eSPI interface is required */
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL6) = 0x7F;
-#else
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL6) = 0xFF;
-#endif
-#if defined(CONFIG_SOC_SERIES_NPCX7)
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL7) = 0xE7;
-#elif defined(CONFIG_SOC_SERIES_NPCX9)
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL7) = 0xFF;
-	NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL8) = 0x31;
-#endif
+	for (int i = 0; i < ARRAY_SIZE(pddwn_ctl_val); i++) {
+		NPCX_PWDWN_CTL(pmc_base, i) = pddwn_ctl_val[i];
+	}
+
+	/* Turn off the clock of the eSPI module only if eSPI isn't required */
+	if (!IS_ENABLED(CONFIG_ESPI)) {
+		NPCX_PWDWN_CTL(pmc_base, NPCX_PWDWN_CTL6) |= BIT(7);
+	}
 
 	return 0;
 }
diff --git a/drivers/console/uart_console.c b/drivers/console/uart_console.c
index 0515e31e83..1be0863ab0 100644
--- a/drivers/console/uart_console.c
+++ b/drivers/console/uart_console.c
@@ -490,7 +490,7 @@ static void uart_console_isr(const struct device *unused, void *user_data)
 		}
 
 		/* Handle special control characters */
-		if (!isprint(byte)) {
+		if (isprint(byte) == 0) {
 			switch (byte) {
 			case BS:
 			case DEL:
diff --git a/drivers/crypto/CMakeLists.txt b/drivers/crypto/CMakeLists.txt
index 3887f67599..5bccb12ff8 100644
--- a/drivers/crypto/CMakeLists.txt
+++ b/drivers/crypto/CMakeLists.txt
@@ -7,4 +7,5 @@ zephyr_library_sources_ifdef(CONFIG_CRYPTO_MBEDTLS_SHIM		crypto_mtls_shim.c)
 zephyr_library_sources_ifdef(CONFIG_CRYPTO_STM32			crypto_stm32.c)
 zephyr_library_sources_ifdef(CONFIG_CRYPTO_NRF_ECB		crypto_nrf_ecb.c)
 zephyr_library_sources_ifdef(CONFIG_CRYPTO_INTEL_SHA		crypto_intel_sha.c)
+zephyr_library_sources_ifdef(CONFIG_CRYPTO_NPCX_SHA		crypto_npcx_sha.c)
 zephyr_library_link_libraries_ifdef(CONFIG_MBEDTLS mbedTLS)
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index f257c53231..c9c5a203bd 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -76,5 +76,6 @@ source "drivers/crypto/Kconfig.ataes132a"
 source "drivers/crypto/Kconfig.stm32"
 source "drivers/crypto/Kconfig.nrf_ecb"
 source "drivers/crypto/Kconfig.intel"
+source "drivers/crypto/Kconfig.npcx"
 
 endif # CRYPTO
diff --git a/drivers/crypto/Kconfig.npcx b/drivers/crypto/Kconfig.npcx
new file mode 100644
index 0000000000..80ce1b28f6
--- /dev/null
+++ b/drivers/crypto/Kconfig.npcx
@@ -0,0 +1,11 @@
+# NPCX SHA driver configuration options
+
+# Copyright (c) 2022 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config CRYPTO_NPCX_SHA
+	bool "NPCX SHA driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_SHA_ENABLED
+	help
+	  Enable NPCX SHA driver.
diff --git a/drivers/crypto/crypto_npcx_sha.c b/drivers/crypto/crypto_npcx_sha.c
new file mode 100644
index 0000000000..2640359936
--- /dev/null
+++ b/drivers/crypto/crypto_npcx_sha.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2022 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_sha
+
+#include <errno.h>
+#include <zephyr/kernel.h>
+#include <zephyr/crypto/crypto.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(sha_npcx, CONFIG_CRYPTO_LOG_LEVEL);
+
+#define NPCX_HASH_CAPS_SUPPORT	(CAP_SEPARATE_IO_BUFS | CAP_SYNC_OPS)
+#define NPCX_SHA256_HANDLE_SIZE DT_INST_PROP(0, context_buffer_size)
+#define NPCX_SHA_MAX_SESSION	1
+
+/* The status code returns from Nuvoton Cryptographic Library ROM APIs */
+enum ncl_status {
+	NCL_STATUS_OK = 0xA5A5,
+	NCL_STATUS_FAIL = 0x5A5A,
+	NCL_STATUS_INVALID_PARAM = 0x02,
+	NCL_STATUS_PARAM_NOT_SUPPORTED,
+	NCL_STATUS_SYSTEM_BUSY,
+	NCL_STATUS_AUTHENTICATION_FAIL,
+	NCL_STATUS_NO_RESPONSE,
+	NCL_STATUS_HARDWARE_ERROR,
+};
+enum ncl_sha_type {
+	NCL_SHA_TYPE_2_256 = 0,
+	NCL_SHA_TYPE_2_384 = 1,
+	NCL_SHA_TYPE_2_512 = 2,
+	NCL_SHA_TYPE_NUM
+};
+
+/* The following table holds the function pointer for each SHA API in NPCX ROM. */
+struct npcx_ncl_sha {
+	/* Get the SHA context size required by SHA APIs. */
+	uint32_t (*get_context_size)(void);
+	/* Initial SHA context. */
+	enum ncl_status (*init_context)(void *ctx);
+	/* Finalize SHA context. */
+	enum ncl_status (*finalize_context)(void *ctx);
+	/* Initiate the SHA hardware module and setups needed parameters. */
+	enum ncl_status (*init)(void *ctx);
+	/*
+	 * Prepare the context buffer for a SHA calculation -  by loading the
+	 * initial SHA-256/384/512 parameters.
+	 */
+	enum ncl_status (*start)(void *ctx, enum ncl_sha_type type);
+	/*
+	 * Updates the SHA calculation with the additional data. When the
+	 * function returns, the hardware and memory buffer shall be ready to
+	 * accept new data * buffers for SHA calculation and changes to the data
+	 * in data buffer should no longer effect the SHA calculation.
+	 */
+	enum ncl_status (*update)(void *ctx, const uint8_t *data, uint32_t Len);
+	/* Return the SHA result (digest.) */
+	enum ncl_status (*finish)(void *ctx, uint8_t *hashDigest);
+	/* Perform a complete SHA calculation */
+	enum ncl_status (*calc)(void *ctx, enum ncl_sha_type type, const uint8_t *data,
+				uint32_t Len, uint8_t *hashDigest);
+	/* Power on/off the SHA module. */
+	enum ncl_status (*power)(void *ctx, uint8_t enable);
+	/* Reset the SHA hardware and terminate any in-progress operations. */
+	enum ncl_status (*reset)(void *ctx);
+};
+
+/* The start address of the SHA API table. */
+#define NPCX_NCL_SHA ((const struct npcx_ncl_sha *)DT_INST_REG_ADDR(0))
+
+struct npcx_sha_context {
+	uint8_t handle[NPCX_SHA256_HANDLE_SIZE];
+} __aligned(4);
+
+struct npcx_sha_session {
+	struct npcx_sha_context npcx_sha_ctx;
+	enum hash_algo algo;
+	bool in_use;
+};
+
+struct npcx_sha_session npcx_sessions[NPCX_SHA_MAX_SESSION];
+
+static int npcx_get_unused_session_index(void)
+{
+	int i;
+
+	for (i = 0; i < NPCX_SHA_MAX_SESSION; i++) {
+		if (!npcx_sessions[i].in_use) {
+			npcx_sessions[i].in_use = true;
+			return i;
+		}
+	}
+
+	return -1;
+}
+static int npcx_sha_compute(struct hash_ctx *ctx, struct hash_pkt *pkt, bool finish)
+{
+	enum ncl_status ret;
+	struct npcx_sha_session *npcx_session = ctx->drv_sessn_state;
+	struct npcx_sha_context *npcx_ctx = &npcx_session->npcx_sha_ctx;
+	enum ncl_sha_type sha_type;
+
+	switch (npcx_session->algo) {
+	case CRYPTO_HASH_ALGO_SHA256:
+		sha_type = NCL_SHA_TYPE_2_256;
+		break;
+	case CRYPTO_HASH_ALGO_SHA384:
+		sha_type = NCL_SHA_TYPE_2_384;
+		break;
+	case CRYPTO_HASH_ALGO_SHA512:
+		sha_type = NCL_SHA_TYPE_2_512;
+		break;
+	default:
+		LOG_ERR("Unexpected algo: %d", npcx_session->algo);
+		return -EINVAL;
+	}
+
+	if (!ctx->started) {
+		ret = NPCX_NCL_SHA->start(npcx_ctx->handle, sha_type);
+		if (ret != NCL_STATUS_OK) {
+			LOG_ERR("Could not compute the hash, err:%d", ret);
+			return -EINVAL;
+		}
+		ctx->started = true;
+	}
+
+	if (pkt->in_len != 0) {
+		ret = NPCX_NCL_SHA->update(npcx_ctx->handle, pkt->in_buf, pkt->in_len);
+		if (ret != NCL_STATUS_OK) {
+			LOG_ERR("Could not update the hash, err:%d", ret);
+			ctx->started = false;
+			return -EINVAL;
+		}
+	}
+
+	if (finish) {
+		ctx->started = false;
+		ret = NPCX_NCL_SHA->finish(npcx_ctx->handle, pkt->out_buf);
+		if (ret != NCL_STATUS_OK) {
+			LOG_ERR("Could not compute the hash, err:%d", ret);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int npcx_hash_session_setup(const struct device *dev, struct hash_ctx *ctx,
+				   enum hash_algo algo)
+{
+	int ctx_idx;
+	struct npcx_sha_context *npcx_ctx;
+
+	if (ctx->flags & ~(NPCX_HASH_CAPS_SUPPORT)) {
+		LOG_ERR("Unsupported flag");
+		return -EINVAL;
+	}
+
+	if ((algo != CRYPTO_HASH_ALGO_SHA256) && (algo != CRYPTO_HASH_ALGO_SHA384) &&
+	    (algo != CRYPTO_HASH_ALGO_SHA512)) {
+		LOG_ERR("Unsupported algo: %d", algo);
+		return -EINVAL;
+	}
+
+	ctx_idx = npcx_get_unused_session_index();
+	if (ctx_idx < 0) {
+		LOG_ERR("No free session for now");
+		return -ENOSPC;
+	}
+
+	npcx_sessions[ctx_idx].algo = algo;
+
+	ctx->drv_sessn_state = &npcx_sessions[ctx_idx];
+	ctx->started = false;
+	ctx->hash_hndlr = npcx_sha_compute;
+
+	npcx_ctx = &npcx_sessions[ctx_idx].npcx_sha_ctx;
+	NPCX_NCL_SHA->init_context(npcx_ctx->handle);
+	NPCX_NCL_SHA->power(npcx_ctx->handle, 1);
+	NPCX_NCL_SHA->init(npcx_ctx->handle);
+	NPCX_NCL_SHA->reset(npcx_ctx->handle);
+
+	return 0;
+}
+
+static int npcx_hash_session_free(const struct device *dev, struct hash_ctx *ctx)
+{
+	struct npcx_sha_session *npcx_session = ctx->drv_sessn_state;
+	struct npcx_sha_context *npcx_ctx = &npcx_session->npcx_sha_ctx;
+
+	NPCX_NCL_SHA->reset(npcx_ctx->handle);
+	NPCX_NCL_SHA->power(npcx_ctx->handle, 0);
+	NPCX_NCL_SHA->finalize_context(npcx_ctx->handle);
+	npcx_session->in_use = false;
+
+	return 0;
+}
+
+static int npcx_query_caps(const struct device *dev)
+{
+	return NPCX_HASH_CAPS_SUPPORT;
+}
+
+static struct crypto_driver_api npcx_crypto_api = {
+	.hash_begin_session = npcx_hash_session_setup,
+	.hash_free_session = npcx_hash_session_free,
+	.query_hw_caps = npcx_query_caps,
+};
+
+DEVICE_DT_INST_DEFINE(0, NULL, NULL, NULL, NULL, POST_KERNEL, CONFIG_CRYPTO_INIT_PRIORITY,
+		      &npcx_crypto_api);
+BUILD_ASSERT(DT_NUM_INST_STATUS_OKAY(DT_DRV_COMPAT) == 1,
+	     "only one 'nuvoton,npcx-sha' compatible node can be supported");
diff --git a/drivers/espi/CMakeLists.txt b/drivers/espi/CMakeLists.txt
index 82e257098f..5379d00ea2 100644
--- a/drivers/espi/CMakeLists.txt
+++ b/drivers/espi/CMakeLists.txt
@@ -1,13 +1,17 @@
 # SPDX-License-Identifier: Apache-2.0
 
+zephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/drivers/espi.h)
+
 zephyr_library()
 
 zephyr_library_sources_ifdef(CONFIG_ESPI_XEC		espi_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_NPCX		espi_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_NPCX		host_subs_npcx.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_TAF_NPCX	espi_taf_npcx.c)
 zephyr_library_sources_ifdef(CONFIG_USERSPACE		espi_handlers.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_EMUL		espi_emul.c)
-zephyr_library_sources_ifdef(CONFIG_ESPI_SAF		espi_saf_mchp_xec.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_SAF_XEC	espi_saf_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_XEC_V2		espi_mchp_xec_v2.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_XEC_V2		espi_mchp_xec_host_v2.c)
 zephyr_library_sources_ifdef(CONFIG_ESPI_IT8XXX2	espi_it8xxx2.c)
+zephyr_library_sources_ifdef(CONFIG_ESPI_SAF_XEC_V2	espi_saf_mchp_xec_v2.c)
diff --git a/drivers/espi/Kconfig b/drivers/espi/Kconfig
index 3c4de413c8..f8ee937af5 100644
--- a/drivers/espi/Kconfig
+++ b/drivers/espi/Kconfig
@@ -12,8 +12,6 @@ if ESPI
 
 source "drivers/espi/Kconfig.xec"
 
-source "drivers/espi/Kconfig.xec_v2"
-
 source "drivers/espi/Kconfig.npcx"
 
 source "drivers/espi/Kconfig.espi_emul"
@@ -178,4 +176,19 @@ config ESPI_OOB_CHANNEL_RX_ASYNC
 	  Enables asynchronous handling for host-initiated OOB traffic.
 	  Otherwise OOB traffic is assumed to be always client-initiated.
 
+config ESPI_SAF
+	bool "ESPI SAF driver"
+	depends on ESPI_FLASH_CHANNEL
+	help
+	  Enable Slave Attached Flash eSPI driver. SAF depends upon ESPI driver
+	  and flash channel.
+
+config ESPI_SAF_INIT_PRIORITY
+	int "ESPI SAF driver initialization priority"
+	depends on ESPI_SAF
+	default 4
+	help
+	  Driver initialization priority for eSPI SAF driver. SAF driver must
+	  initialize after the ESPI driver.
+
 endif # ESPI
diff --git a/drivers/espi/Kconfig.npcx b/drivers/espi/Kconfig.npcx
index f19d7ee46b..516adf4397 100644
--- a/drivers/espi/Kconfig.npcx
+++ b/drivers/espi/Kconfig.npcx
@@ -41,6 +41,51 @@ config ESPI_NPCX_BYPASS_CH_ENABLE_FATAL_ERROR
 	  a wrong state and therefore response with FATAL_ERROR on an incoming
 	  transaction.
 
+config ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	bool "Host can write 1/2/4 bytes of Port80 data in a eSPI transaction"
+	depends on SOC_SERIES_NPCX9 && ESPI_PERIPHERAL_DEBUG_PORT_80
+	help
+	  EC can accept 1/2/4 bytes of Port 80 data written from the Host in an
+	  eSPI transaction.
+
+config ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_RING_BUF_SIZE
+	int "Debug Port80 ring buffer size"
+	depends on ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	default 256
+	help
+	  The size of the ring buffer in byte used by the Port80 ISR to store
+	  Postcodes from Host.
+
+config ESPI_TAF_NPCX
+	bool "Nuvoton NPCX embedded controller (EC) ESPI TAF driver"
+	depends on SOC_SERIES_NPCX4 || SOC_SERIES_NPCK3
+	help
+	  This option enables the Intel Enhanced Serial Peripheral Interface
+	  Target Attached Flash (eSPI TAF) for NPCX4 family of processors.
+
+choice ESPI_TAF_ACCESS_MODE_CHOICE
+	prompt "set TX/RX mode for eSPI TAF"
+	default ESPI_TAF_DIRECT_ACCESS
+
+config ESPI_TAF_DIRECT_ACCESS
+	bool "eSPI TAF access buffer directly"
+	help
+	  This is the setting to use direct mode for eSPI TAF.
+
+config ESPI_TAF_INDIRECT_ACCESS
+	bool "eSPI TAF access buffer indirectly"
+	help
+	  This is the setting to use indirect mode for eSPI TAF.
+
+endchoice
+
+config ESPI_TAF_PR_NUM
+	int "Sets of protection region settings"
+	default 16
+	help
+	  This size is display how many group of slave attached flash protection
+	  region.
+
 # The default value 'y' for the existing options if ESPI_NPCX is selected.
 if ESPI_NPCX
 
@@ -65,4 +110,10 @@ config ESPI_PERIPHERAL_ACPI_SHM_REGION
 config ESPI_PERIPHERAL_CUSTOM_OPCODE
 	default y
 
+config ESPI_NPCX_SUPP_VW_GPIO
+	bool "Indicates that the eSPI hardware supports virtual wire GPIOs"
+	default y if SOC_SERIES_NPCX9 || SOC_SERIES_NPCX4
+	help
+	  Selected if NPCX series supports virtual wire GPIOs in eSPI module.
+
 endif #ESPI_NPCX
diff --git a/drivers/espi/Kconfig.xec b/drivers/espi/Kconfig.xec
index b6fde723b7..7c9285dbf3 100644
--- a/drivers/espi/Kconfig.xec
+++ b/drivers/espi/Kconfig.xec
@@ -5,11 +5,17 @@
 
 config ESPI_XEC
 	bool "XEC Microchip ESPI driver"
-	depends on SOC_SERIES_MEC1501X
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_ENABLED
 	help
 	  Enable the Microchip XEC ESPI driver for MEC15xx family.
 
-if ESPI_XEC
+config ESPI_XEC_V2
+	bool "XEC Microchip ESPI V2 driver"
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_V2_ENABLED
+	help
+	  Enable the Microchip XEC ESPI driver for MEC172x series.
+
+if ESPI_XEC || ESPI_XEC_V2
 
 config ESPI_OOB_CHANNEL
 	default y
@@ -55,6 +61,97 @@ config ESPI_FLASH_BUFFER_SIZE
 	  Use maximum RAM buffer size defined by spec but allow applications
 	  to override if eSPI host doesn't support it.
 
+config ESPI_SAF_XEC
+	bool "XEC Microchip ESPI SAF driver"
+	default y
+	depends on SOC_SERIES_MEC1501X
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_ENABLED
+	help
+	  Enable the Microchip XEC SAF ESPI driver for MEC15xx family.
+
+config ESPI_SAF_XEC_V2
+	bool "XEC Microchip ESPI SAF V2 driver"
+	default y
+	depends on SOC_SERIES_MEC172X
+	depends on DT_HAS_MICROCHIP_XEC_ESPI_SAF_V2_ENABLED
+	help
+	  Enable the Microchip XEC SAF ESPI driver for MEC172x series.
+
+endif #ESPI_XEC
+
+if ESPI_XEC_V2
+
+config ESPI_XEC_PERIPHERAL_ACPI_SHD_MEM_SIZE
+	int "Host I/O peripheral port size for shared memory in MEC172X series"
+	depends on ESPI_XEC_V2 || ESPI_PERIPHERAL_ACPI_SHM_REGION
+	default 256
+	help
+	  This is the port size used by the Host and EC to communicate over
+	  the shared memory region to return the ACPI response data.
+
+config ESPI_XEC_PERIPHERAL_HOST_CMD_PARAM_SIZE
+	int "Host I/O peripheral port size for ec host command in MEC172X series"
+	depends on ESPI_XEC_V2 || ESPI_PERIPHERAL_EC_HOST_CMD
+	default 256
+	help
+	  This is the port size used by the Host and EC to communicate over
+	  the shared memory region to return the host command parameter data.
+
+config ESPI_PERIPHERAL_8042_KBC
+	default y
+
+if ESPI_PERIPHERAL_CHANNEL
+
+config ESPI_PERIPHERAL_XEC_MAILBOX
+	bool "SoC Mailbox over eSPI"
+	help
+	  Enable a 32 byte mailbox interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_EC2
+	bool "SoC ACPI EC 2 over eSPI"
+	help
+	  Enable ACPI EC2 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_EC3
+	bool "SoC ACPI EC 3 over eSPI"
+	help
+	  Enable ACPI EC3 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_EC4
+	bool "SoC ACPI EC 4 over eSPI"
+	help
+	  Enable ACPI EC4 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_ACPI_PM1
+	bool "SoC ACPI PM1 over eSPI"
+	help
+	  Enable ACPI PM1 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_EMI0
+	bool "SoC EMI 0 over eSPI"
+	help
+	  Enable EMI 0 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_EMI1
+	bool "SoC EMI 1 over eSPI"
+	help
+	  Enable EMI 1 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+config ESPI_PERIPHERAL_XEC_EMI2
+	bool "SoC EMI 2 over eSPI"
+	help
+	  Enable EMI 2 interface accessible via Host I/O over the
+	  ESPI Peripheral Channel.
+
+endif #ESPI_PERIPHERAL_CHANNEL
+
 config ESPI_SAF
 	bool "XEC Microchip ESPI SAF driver"
 	depends on ESPI_FLASH_CHANNEL
@@ -69,4 +166,26 @@ config ESPI_SAF_INIT_PRIORITY
 	help
 	  Driver initialization priority for eSPI SAF driver.
 
-endif #ESPI_XEC
+config ESPI_PERIPHERAL_ACPI_EC_IBF_EVT_DATA
+	bool "Read ACPI EC Event Data in IBF ISR"
+	depends on ESPI_PERIPHERAL_CHANNEL
+	help
+	  Enable reading event data in ACPI EC IBF ISR. This is used in OS
+	  environment where application expects IBF ISR to read data and pass
+	  to callback.
+
+endif #ESPI_XEC_V2
+
+if ESPI_XEC_V2 && ESPI_PERIPHERAL_8042_KBC
+
+config ESPI_PERIPHERAL_KBC_IBF_EVT_DATA
+	bool "KBC event data format in IBF"
+	help
+	  Enable espi_evt_data_kbc format for encoding event in KBC IBF ISR
+
+config ESPI_PERIPHERAL_KBC_OBE_CBK
+	bool "KBC OBE Callback"
+	help
+	  Enable KBC OBE callback from OBE ISR
+
+endif #ESPI_XEC_V2 && ESPI_PERIPHERAL_8042_KBC
diff --git a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
index f04c910fe1..027c1b1033 100644
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -434,7 +434,26 @@ static int espi_xec_write_lpc_request(const struct device *dev,
 
 	return 0;
 }
+static int espi_xec_send_ltr(const struct device *dev, struct ltr_cfg_pkt *req)
+{
+	if (!(ESPI_PC_REGS->PC_STATUS & MCHP_ESPI_PC_STS_BM_EN)) {
+		return -ENOTSUP;
+	}
 
+	if (req->ltr_req) {
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_VAL |
+				(req->latency << MCHP_ESPI_LTR_MSG_VAL_POS) |
+				(req->ltr_scale << MCHP_ESPI_LTR_MSG_SC_POS);
+	} else {
+		/* set infinite latency tolrated */
+		ESPI_LTR_REGS->LTR_MSG = MCHP_ESPI_LTR_MSG_REQ_INF;
+	}
+
+	/* Send LTR Packet */
+	ESPI_LTR_REGS->LTR_CTRL = MCHP_ESPI_LTR_CTRL_START;
+
+	return 0;
+}
 static int espi_xec_send_vwire(const struct device *dev,
 			       enum espi_vwire_signal signal, uint8_t level)
 {
@@ -965,6 +984,10 @@ static void setup_espi_io_config(const struct device *dev,
 static void espi_pc_isr(const struct device *dev)
 {
 	uint32_t status = ESPI_PC_REGS->PC_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_CHANNEL_READY,
+				  .evt_details = ESPI_CHANNEL_PERIPHERAL,
+				  .evt_data = 0 };
+	struct espi_xec_data *data = (struct espi_xec_data *)(dev->data);
 
 	if (status & MCHP_ESPI_PC_STS_EN_CHG) {
 		if (status & MCHP_ESPI_PC_STS_EN) {
@@ -972,6 +995,13 @@ static void espi_pc_isr(const struct device *dev)
 		}
 
 		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
+	} else if (status & MCHP_ESPI_PC_STS_BM_EN_CHG) {
+		if (status & MCHP_ESPI_PC_STS_BM_EN) {
+			evt.evt_data = ESPI_PC_EVT_BUS_MASTER_ENABLE;
+			espi_send_callbacks(&data->callbacks, dev, evt);
+		}
+
+		ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_BM_EN_CHG;
 	}
 }
 
@@ -1371,6 +1401,7 @@ static void espi_xec_vw_isr(const struct device *dev)
 	uint32_t girq_result;
 
 	girq_result = MCHP_GIRQ_RESULT(config->vw_girq_ids[0]);
+	MCHP_GIRQ_SRC(config->vw_girq_ids[0]) = girq_result;
 
 	for (int i = 0; i < m2s_vwires_isr_cnt; i++) {
 		struct espi_isr entry = m2s_vwires_isr[i];
@@ -1381,8 +1412,6 @@ static void espi_xec_vw_isr(const struct device *dev)
 			}
 		}
 	}
-
-	REG32(MCHP_GIRQ_SRC_ADDR(config->vw_girq_ids[0])) = girq_result;
 }
 
 #if DT_INST_PROP_HAS_IDX(0, vw_girqs, 1)
@@ -1454,6 +1483,7 @@ static const struct espi_driver_api espi_xec_driver_api = {
 	.manage_callback = espi_xec_manage_callback,
 	.read_lpc_request = espi_xec_read_lpc_request,
 	.write_lpc_request = espi_xec_write_lpc_request,
+	.send_ltr = espi_xec_send_ltr,
 };
 
 static struct espi_xec_data espi_xec_data;
@@ -1527,8 +1557,11 @@ static int espi_xec_init(const struct device *dev)
 	/* Clear reset interrupt status and enable interrupts */
 	ESPI_CAP_REGS->ERST_STS = MCHP_ESPI_RST_ISTS;
 	ESPI_CAP_REGS->ERST_IEN |= MCHP_ESPI_RST_IEN;
-	ESPI_PC_REGS->PC_STATUS = MCHP_ESPI_PC_STS_EN_CHG;
-	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG;
+	ESPI_PC_REGS->PC_STATUS |= MCHP_ESPI_PC_STS_EN_CHG |
+				 MCHP_ESPI_PC_STS_BM_EN_CHG;
+	ESPI_PC_REGS->PC_IEN |= MCHP_ESPI_PC_IEN_EN_CHG |
+				MCHP_ESPI_PC_IEN_BM_EN_CHG;
+
 
 	/* Enable VWires interrupts */
 	for (int i = 0; i < sizeof(vw_wires_int_en); i++) {
diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c
index 5085905ba8..173072af52 100644
--- a/drivers/espi/espi_npcx.c
+++ b/drivers/espi/espi_npcx.c
@@ -7,6 +7,7 @@
 #define DT_DRV_COMPAT nuvoton_npcx_espi
 
 #include <assert.h>
+#include <stdlib.h>
 #include <zephyr/drivers/espi.h>
 #include <zephyr/drivers/gpio.h>
 #include <zephyr/drivers/clock_control.h>
@@ -21,6 +22,7 @@
 #include "soc_miwu.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(espi, CONFIG_ESPI_LOG_LEVEL);
 
 struct espi_npcx_config {
@@ -38,7 +40,7 @@ struct espi_npcx_data {
 	uint8_t plt_rst_asserted;
 	uint8_t espi_rst_asserted;
 	uint8_t sx_state;
-#if defined(CONFIG_ESPI_OOB_CHANNEL)
+#if defined(CONFIG_ESPI_OOB_CHANNEL) && !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	struct k_sem oob_rx_lock;
 #endif
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
@@ -73,8 +75,8 @@ struct espi_npcx_data {
 							((hdr & 0xf0000) >> 8))
 
 /* Flash channel maximum payload size */
-#define NPCX_ESPI_FLASH_MAX_RX_PAYLOAD 64
-#define NPCX_ESPI_FLASH_MAX_TX_PAYLOAD 16
+#define NPCX_ESPI_FLASH_MAX_RX_PAYLOAD DT_INST_PROP(0, rx_plsize)
+#define NPCX_ESPI_FLASH_MAX_TX_PAYLOAD DT_INST_PROP(0, tx_plsize)
 
 /* eSPI cycle type field for OOB and FLASH channels */
 #define ESPI_FLASH_READ_CYCLE_TYPE                 0x00
@@ -162,6 +164,8 @@ static const struct npcx_vw_out_config vw_out_tbl[] = {
 
 /*  Virtual wire GPIOs for platform level usage (High at Reset state) */
 static const struct npcx_vw_out_config vw_out_gpio_tbl1[] = {
+/* Only NPCX9 and later series support this feature */
+#if defined(CONFIG_ESPI_NPCX_SUPP_VW_GPIO)
 	/* index 50h (Out) */
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_0, vw_slv_gpio_0),
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_1, vw_slv_gpio_1),
@@ -172,11 +176,12 @@ static const struct npcx_vw_out_config vw_out_gpio_tbl1[] = {
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_5, vw_slv_gpio_5),
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_6, vw_slv_gpio_6),
 	NPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SLV_GPIO_7, vw_slv_gpio_7),
+#endif
 };
 
 /* Callbacks for eSPI bus reset and Virtual Wire signals. */
-static struct miwu_dev_callback espi_rst_callback;
-static struct miwu_dev_callback vw_in_callback[ARRAY_SIZE(vw_in_tbl)];
+static struct miwu_callback espi_rst_callback;
+static struct miwu_callback vw_in_callback[ARRAY_SIZE(vw_in_tbl)];
 
 /* eSPI VW service function forward declarations */
 static int espi_npcx_receive_vwire(const struct device *dev,
@@ -187,7 +192,7 @@ static void espi_vw_send_bootload_done(const struct device *dev);
 
 /* eSPI local initialization functions */
 static void espi_init_wui_callback(const struct device *dev,
-		struct miwu_dev_callback *callback, const struct npcx_wui *wui,
+		struct miwu_callback *callback, const struct npcx_wui *wui,
 		miwu_dev_callback_handler_t handler)
 {
 	/* VW signal which has no wake-up input source */
@@ -196,12 +201,11 @@ static void espi_init_wui_callback(const struct device *dev,
 
 	/* Install callback function */
 	npcx_miwu_init_dev_callback(callback, wui, handler, dev);
-	npcx_miwu_manage_dev_callback(callback, 1);
+	npcx_miwu_manage_callback(callback, 1);
 
 	/* Configure MIWU setting and enable its interrupt */
 	npcx_miwu_interrupt_configure(wui, NPCX_MIWU_MODE_EDGE,
 							NPCX_MIWU_TRIG_BOTH);
-	npcx_miwu_irq_enable(wui);
 }
 
 /* eSPI local bus interrupt service functions */
@@ -278,19 +282,122 @@ static void espi_bus_cfg_update_isr(const struct device *dev)
 static void espi_bus_oob_rx_isr(const struct device *dev)
 {
 	struct espi_npcx_data *const data = dev->data;
+#ifdef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	struct espi_event evt = { .evt_type = ESPI_BUS_EVENT_OOB_RECEIVED,
+				  .evt_details = 0,
+				  .evt_data = 0 };
 
-	LOG_DBG("%s", __func__);
+	/* Notify upper layer the length of OOB received package */
+	evt.evt_details = NPCX_OOB_RX_PACKAGE_LEN(inst->OOBRXBUF[0]);
+	espi_send_callbacks(&data->callbacks, dev, evt);
+#else
 	k_sem_give(&data->oob_rx_lock);
+#endif
 }
 #endif
 
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
+
+void espi_release_flash_np_free(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp = inst->FLASHCTL;
+
+	/* release FLASH_NP_FREE */
+	tmp |= BIT(NPCX_FLASHCTL_FLASH_NP_FREE);
+	inst->FLASHCTL = tmp;
+}
+
+#if defined(CONFIG_ESPI_SAF)
+static struct espi_taf_pckt taf_pckt;
+
+static uint32_t espi_taf_parse(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t taf_hdr, taf_addr;
+	uint8_t i, roundsize;
+
+	/* Get type, length and tag from RX buffer */
+	if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) {
+		taf_hdr = inst->FLASHRXBUF[0];
+	} else {
+		taf_hdr = inst->FLASHRXRDHEAD;
+	}
+
+	taf_hdr = sys_cpu_to_be32(taf_hdr);
+	taf_pckt.type = MSB1(taf_hdr);
+	taf_pckt.len = ((uint16_t)(taf_hdr)) & 0xFFF;
+	taf_pckt.tag = MSN(MSB2(taf_hdr));
+
+	if ((taf_pckt.len == 0) && ((taf_pckt.type & 0xF) == ESPI_FLASH_TAF_REQ_READ)) {
+		taf_pckt.len = _4KB_;
+	}
+
+	/* Get address from RX buffer */
+	if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) {
+		taf_addr = inst->FLASHRXBUF[1];
+	} else {
+		taf_addr = inst->FLASHRXRDHEAD;
+	}
+	taf_pckt.addr = sys_cpu_to_be32(taf_addr);
+
+	/* Get written data if eSPI TAF write */
+	if ((taf_pckt.type & 0xF) == ESPI_FLASH_TAF_REQ_WRITE) {
+		roundsize = DIV_ROUND_UP(taf_pckt.len, sizeof(uint32_t));
+		for (i = 0; i < roundsize; i++) {
+			if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) {
+				taf_pckt.src[i] = inst->FLASHRXBUF[2 + i];
+			} else {
+				taf_pckt.src[i] = inst->FLASHRXRDHEAD;
+			}
+		}
+	}
+
+	return (uint32_t)&taf_pckt;
+}
+#endif /* CONFIG_ESPI_SAF */
+
 static void espi_bus_flash_rx_isr(const struct device *dev)
 {
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
 	struct espi_npcx_data *const data = dev->data;
 
-	LOG_DBG("%s", __func__);
-	k_sem_give(&data->flash_rx_lock);
+	/* Controller Attached Flash Access */
+	if ((inst->ESPICFG & BIT(NPCX_ESPICFG_FLCHANMODE)) == 0) {
+		k_sem_give(&data->flash_rx_lock);
+	} else { /* Target Attached Flash Access */
+#if defined(CONFIG_ESPI_SAF)
+		struct espi_event evt
+			= { .evt_type = ESPI_BUS_SAF_NOTIFICATION,
+			    .evt_details = ESPI_CHANNEL_FLASH,
+			    .evt_data = espi_taf_parse(dev),
+			  };
+		espi_send_callbacks(&data->callbacks, dev, evt);
+#else
+		LOG_DBG("ESPI TAF not supported");
+#endif
+	}
+}
+
+static void espi_bus_completion_sent_isr(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	/* check that ESPISTS.FLNACS is clear. */
+	if (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_FLNACS)) {
+		LOG_ERR("ESPISTS_FLNACS not clear\r\n");
+	}
+
+	/* flash operation is done, Make sure the TAFS transmit buffer is empty */
+	if (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL)) {
+		LOG_ERR("FLASH_TX_AVAIL not clear\r\n");
+	}
+
+	/* In auto mode, release FLASH_NP_FREE here to get next SAF request.*/
+	if (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_SAF_AUTO_READ)) {
+		espi_release_flash_np_free(dev);
+	}
 }
 #endif
 
@@ -304,6 +411,7 @@ const struct espi_bus_isr espi_bus_isr_tbl[] = {
 #endif
 #if defined(CONFIG_ESPI_FLASH_CHANNEL)
 	NPCX_ESPI_BUS_INT_ITEM(FLASHRX, espi_bus_flash_rx_isr),
+	NPCX_ESPI_BUS_INT_ITEM(FLNACS, espi_bus_completion_sent_isr),
 #endif
 };
 
@@ -799,7 +907,7 @@ static int espi_npcx_send_oob(const struct device *dev,
 
 	/*
 	 * Notify host a new OOB packet is ready. Please don't write OOB_FREE
-	 * to 1 at the same tiem in case clear it unexpectedly.
+	 * to 1 at the same time in case clear it unexpectedly.
 	 */
 	oob_data = inst->OOBCTL & ~(BIT(NPCX_OOBCTL_OOB_FREE));
 	oob_data |= BIT(NPCX_OOBCTL_OOB_AVAIL);
@@ -816,10 +924,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 				struct espi_oob_packet *pckt)
 {
 	struct espi_reg *const inst = HAL_INSTANCE(dev);
-	struct espi_npcx_data *const data = dev->data;
 	uint8_t *oob_buf = pckt->buf;
 	uint32_t oob_data;
-	int idx_rx_buf, sz_oob_rx, ret;
+	int idx_rx_buf, sz_oob_rx;
 
 	/* Check eSPI bus status first */
 	if (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_BERR)) {
@@ -827,16 +934,15 @@ static int espi_npcx_receive_oob(const struct device *dev,
 		return -EIO;
 	}
 
-	/* Notify host that OOB received buffer is free now. */
-	inst->OOBCTL |= BIT(NPCX_OOBCTL_OOB_FREE);
+#ifndef CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC
+	struct espi_npcx_data *const data = dev->data;
 
 	/* Wait until get oob package or timeout */
-	ret = k_sem_take(&data->oob_rx_lock, K_MSEC(ESPI_OOB_MAX_TIMEOUT));
-	if (ret == -EAGAIN) {
+	if (k_sem_take(&data->oob_rx_lock, K_MSEC(ESPI_OOB_MAX_TIMEOUT)) == -EAGAIN) {
 		LOG_ERR("%s: Timeout", __func__);
 		return -ETIMEDOUT;
 	}
-
+#endif
 	/*
 	 * PUT_OOB header (first 4 bytes) in npcx 32-bits rx buffer
 	 *
@@ -877,6 +983,9 @@ static int espi_npcx_receive_oob(const struct device *dev,
 		for (i = 0; i < sz_oob_rx % 4; i++)
 			*(oob_buf++) = (oob_data >> (8 * i)) & 0xFF;
 	}
+
+	/* Notify host that OOB received buffer is free now. */
+	inst->OOBCTL |= BIT(NPCX_OOBCTL_OOB_FREE);
 	return 0;
 }
 #endif
@@ -1120,7 +1229,7 @@ static int espi_npcx_flash_erase(const struct device *dev,
 /* Platform specific espi module functions */
 void npcx_espi_enable_interrupts(const struct device *dev)
 {
-	ARG_UNUSED(dev);
+	const struct espi_npcx_config *const config = dev->config;
 
 	/* Enable eSPI bus interrupt */
 	irq_enable(DT_INST_IRQN(0));
@@ -1129,11 +1238,13 @@ void npcx_espi_enable_interrupts(const struct device *dev)
 	for (int idx = 0; idx < ARRAY_SIZE(vw_in_tbl); idx++) {
 		npcx_miwu_irq_enable(&(vw_in_tbl[idx].vw_wui));
 	}
+
+	npcx_miwu_irq_enable(&config->espi_rst_wui);
 }
 
 void npcx_espi_disable_interrupts(const struct device *dev)
 {
-	ARG_UNUSED(dev);
+	const struct espi_npcx_config *const config = dev->config;
 
 	/* Disable eSPI bus interrupt */
 	irq_disable(DT_INST_IRQN(0));
@@ -1142,6 +1253,8 @@ void npcx_espi_disable_interrupts(const struct device *dev)
 	for (int idx = 0; idx < ARRAY_SIZE(vw_in_tbl); idx++) {
 		npcx_miwu_irq_disable(&(vw_in_tbl[idx].vw_wui));
 	}
+
+	npcx_miwu_irq_disable(&config->espi_rst_wui);
 }
 
 /* eSPI driver registration */
@@ -1203,7 +1316,7 @@ static int espi_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on eSPI device clock first */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on eSPI clock fail %d", ret);
@@ -1224,7 +1337,7 @@ static int espi_npcx_init(const struct device *dev)
 		inst->ESPIWE |= BIT(espi_bus_isr_tbl[i].wake_en_bit);
 	}
 
-#if defined(CONFIG_ESPI_OOB_CHANNEL)
+#if defined(CONFIG_ESPI_OOB_CHANNEL) && !defined(CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC)
 	k_sem_init(&data->oob_rx_lock, 0, 1);
 #endif
 
diff --git a/drivers/espi/espi_saf_mchp_xec_v2.c b/drivers/espi/espi_saf_mchp_xec_v2.c
new file mode 100644
index 0000000000..aa7ea69058
--- /dev/null
+++ b/drivers/espi/espi_saf_mchp_xec_v2.c
@@ -0,0 +1,1175 @@
+/*
+ * Copyright (c) 2019 Intel Corporation
+ * Copyright (c) 2022 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT microchip_xec_espi_saf_v2
+
+#include <zephyr/kernel.h>
+#include <soc.h>
+#include <errno.h>
+#include <zephyr/drivers/clock_control/mchp_xec_clock_control.h>
+#include <zephyr/drivers/espi.h>
+#include <zephyr/drivers/espi_saf.h>
+#include <zephyr/drivers/interrupt_controller/intc_mchp_xec_ecia.h>
+#include <zephyr/dt-bindings/interrupt-controller/mchp-xec-ecia.h>
+#include <zephyr/logging/log.h>
+
+#include "espi_mchp_xec_v2.h"
+#include "espi_utils.h"
+LOG_MODULE_REGISTER(espi_saf, CONFIG_ESPI_LOG_LEVEL);
+
+/* common clock control device node for all Microchip XEC chips */
+#define MCHP_XEC_CLOCK_CONTROL_NODE	DT_NODELABEL(pcr)
+
+/* SAF EC Portal read/write flash access limited to 1-64 bytes */
+#define MAX_SAF_ECP_BUFFER_SIZE 64ul
+
+/* 1 second maximum for flash operations */
+#define MAX_SAF_FLASH_TIMEOUT 125000ul /* 1000ul */
+
+#define MAX_SAF_FLASH_TIMEOUT_MS 1000ul
+
+/* 64 bytes @ 24MHz quad is approx. 6 us */
+#define SAF_WAIT_INTERVAL 8
+
+/* After 8 wait intervals yield */
+#define SAF_YIELD_THRESHOLD 64
+
+/* Get QMSPI 0 encoded GIRQ information */
+#define XEC_QMSPI_ENC_GIRQ						\
+	DT_PROP_BY_IDX(DT_INST(0, microchip_xec_qmspi_ldma), girqs, 0)
+
+#define XEC_QMSPI_GIRQ MCHP_XEC_ECIA_GIRQ(XEC_QMSPI_ENC_GIRQ)
+#define XEC_QMSPI_GIRQ_POS MCHP_XEC_ECIA_GIRQ_POS(XEC_QMSPI_ENC_GIRQ)
+
+#define XEC_SAF_DONE_ENC_GIRQ DT_INST_PROP_BY_IDX(0, girqs, 0)
+#define XEC_SAF_ERR_ENC_GIRQ DT_INST_PROP_BY_IDX(0, girqs, 1)
+
+#define XEC_SAF_DONE_GIRQ MCHP_XEC_ECIA_GIRQ(XEC_SAF_DONE_ENC_GIRQ)
+#define XEC_SAF_DONE_GIRQ_POS MCHP_XEC_ECIA_GIRQ_POS(XEC_SAF_ERR_ENC_GIRQ)
+
+/*
+ * SAF configuration from Device Tree
+ * SAF controller register block base address
+ * QMSPI controller register block base address
+ * SAF communications register block base address
+ * Flash STATUS1 poll timeout in 32KHz periods
+ * Flash consecutive read timeout in units of 20 ns
+ * Delay before first Poll-1 command after suspend in 20 ns units
+ * Hold off suspend for this interval if erase or program in 32KHz periods.
+ * Add delay between Poll STATUS1 commands in 20 ns units.
+ */
+struct espi_saf_xec_config {
+	struct mchp_espi_saf * const saf_base;
+	struct qmspi_regs * const qmspi_base;
+	struct mchp_espi_saf_comm * const saf_comm_base;
+	struct espi_iom_regs * const iom_base;
+	void (*irq_config_func)(void);
+	uint32_t poll_timeout;
+	uint32_t consec_rd_timeout;
+	uint32_t sus_chk_delay;
+	uint16_t sus_rsm_interval;
+	uint16_t poll_interval;
+	uint8_t pcr_idx;
+	uint8_t pcr_pos;
+	uint8_t irq_info_size;
+	uint8_t rsvd1;
+	const struct espi_xec_irq_info *irq_info_list;
+};
+
+struct espi_saf_xec_data {
+	struct k_sem ecp_lock;
+	uint32_t hwstatus;
+	sys_slist_t callbacks;
+};
+
+/* EC portal local flash r/w buffer */
+static uint32_t slave_mem[MAX_SAF_ECP_BUFFER_SIZE];
+
+/*
+ * @brief eSPI SAF configuration
+ */
+
+static inline void mchp_saf_cs_descr_wr(struct mchp_espi_saf *regs, uint8_t cs,
+					uint32_t val)
+{
+	regs->SAF_CS_OP[cs].OP_DESCR = val;
+}
+
+static inline void mchp_saf_poll2_mask_wr(struct mchp_espi_saf *regs, uint8_t cs,
+					  uint16_t val)
+{
+	LOG_DBG("%s cs: %d mask %x", __func__, cs, val);
+	if (cs == 0) {
+		regs->SAF_CS0_CFG_P2M = val;
+	} else {
+		regs->SAF_CS1_CFG_P2M = val;
+	}
+}
+
+static inline void mchp_saf_cm_prefix_wr(struct mchp_espi_saf *regs, uint8_t cs,
+					 uint16_t val)
+{
+	if (cs == 0) {
+		regs->SAF_CS0_CM_PRF = val;
+	} else {
+		regs->SAF_CS1_CM_PRF = val;
+	}
+}
+
+/*
+ * Initialize SAF flash protection regions.
+ * SAF HW implements 17 protection regions.
+ * At least one protection region must be configured to allow
+ * EC access to the local flash through the EC Portal.
+ * Each protection region is composed of 4 32-bit registers
+ * Start bits[19:0] = bits[31:12] region start address (4KB boundaries)
+ * Limit bits[19:0] = bits[31:12] region limit address (4KB boundaries)
+ * Write protect b[7:0] = masters[7:0] allow write/erase. 1=allowed
+ * Read protetc b[7:0] = masters[7:0] allow read. 1=allowed
+ *
+ * This routine configures protection region 0 for full flash array
+ * address range and read-write-erase for all masters.
+ * This routine must be called AFTER the flash configuration size/limit and
+ * threshold registers have been programmed.
+ *
+ * POR default values:
+ * Start = 0x7ffff
+ * Limit = 0
+ * Write Prot = 0x01 Master 0 always granted write/erase
+ * Read Prot = 0x01 Master 0 always granted read
+ *
+ * Sample code configures PR[0]
+ * Start = 0
+ * Limit = 0x7ffff
+ * WR = 0xFF
+ * RD = 0xFF
+ */
+static void saf_protection_regions_init(struct mchp_espi_saf *regs)
+{
+	LOG_DBG("%s", __func__);
+
+	for (size_t n = 0; n < MCHP_ESPI_SAF_PR_MAX; n++) {
+		if (n == 0) {
+			regs->SAF_PROT_RG[0].START = 0U;
+			regs->SAF_PROT_RG[0].LIMIT =
+				regs->SAF_FL_CFG_SIZE_LIM >> 12;
+			regs->SAF_PROT_RG[0].WEBM = MCHP_SAF_MSTR_ALL;
+			regs->SAF_PROT_RG[0].RDBM = MCHP_SAF_MSTR_ALL;
+		} else {
+			regs->SAF_PROT_RG[n].START =
+				MCHP_SAF_PROT_RG_START_DFLT;
+			regs->SAF_PROT_RG[n].LIMIT =
+				MCHP_SAF_PROT_RG_LIMIT_DFLT;
+			regs->SAF_PROT_RG[n].WEBM = 0U;
+			regs->SAF_PROT_RG[n].RDBM = 0U;
+		}
+
+		LOG_DBG("PROT[%d] START %x", n, regs->SAF_PROT_RG[n].START);
+		LOG_DBG("PROT[%d] LIMIT %x", n, regs->SAF_PROT_RG[n].LIMIT);
+		LOG_DBG("PROT[%d] WEBM %x", n, regs->SAF_PROT_RG[n].WEBM);
+		LOG_DBG("PROT[%d] RDBM %x", n, regs->SAF_PROT_RG[n].RDBM);
+	}
+}
+
+static int qmspi_freq_div(uint32_t freqhz, uint32_t *fdiv)
+{
+	clock_control_subsys_t clkss =
+		(clock_control_subsys_t)(MCHP_XEC_PCR_CLK_PERIPH_FAST);
+	uint32_t clk = 0u;
+
+	if (!fdiv) {
+		return -EINVAL;
+	}
+
+	if (clock_control_get_rate(DEVICE_DT_GET(MCHP_XEC_CLOCK_CONTROL_NODE),
+				    (clock_control_subsys_t)clkss, &clk)) {
+		return -EIO;
+	}
+
+	*fdiv = 0u; /* maximum divider = 0x10000 */
+	if (freqhz) {
+		*fdiv = clk / freqhz;
+	}
+
+	return 0u;
+}
+
+static int qmspi_freq_div_from_mhz(uint32_t freqmhz, uint32_t *fdiv)
+{
+	uint32_t freqhz = freqmhz * 1000000u;
+
+	return qmspi_freq_div(freqhz, fdiv);
+}
+
+/*
+ * Take over and re-initialize QMSPI for use by SAF HW engine.
+ * When SAF is activated, QMSPI registers are controlled by SAF
+ * HW engine. CPU no longer has access to QMSPI registers.
+ * 1. Save QMSPI driver frequency divider, SPI signalling mode, and
+ *    chip select timing.
+ * 2. Put QMSPI controller in a known state by performing a soft reset.
+ * 3. Clear QMSPI GIRQ status
+ * 4. Configure QMSPI interface control for SAF.
+ * 5. Load flash device independent (generic) descriptors.
+ * 6. Enable transfer done interrupt in QMSPI
+ * 7. Enable QMSPI SAF mode
+ * 8. If user configuration overrides frequency, signalling mode,
+ *    or chip select timing derive user values.
+ * 9. Program QMSPI MODE and CSTIM registers with activate set.
+ */
+static int saf_qmspi_init(const struct espi_saf_xec_config *xcfg,
+			  const struct espi_saf_cfg *cfg)
+{
+	uint32_t qmode, qfdiv, cstim, n;
+	struct qmspi_regs * const qregs = xcfg->qmspi_base;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	qmode = qregs->MODE;
+	if (!(qmode & MCHP_QMSPI_M_ACTIVATE)) {
+		return -EAGAIN;
+	}
+
+	qmode = qregs->MODE & (MCHP_QMSPI_M_FDIV_MASK | MCHP_QMSPI_M_SIG_MASK);
+	cstim = qregs->CSTM;
+	qregs->MODE = MCHP_QMSPI_M_SRST;
+	qregs->STS = MCHP_QMSPI_STS_RW1C_MASK;
+
+	mchp_soc_ecia_girq_src_dis(XEC_QMSPI_GIRQ, XEC_QMSPI_GIRQ_POS);
+	mchp_soc_ecia_girq_src_clr(XEC_QMSPI_GIRQ, XEC_QMSPI_GIRQ_POS);
+
+	qregs->IFCTRL =
+		(MCHP_QMSPI_IFC_WP_OUT_HI | MCHP_QMSPI_IFC_WP_OUT_EN |
+		 MCHP_QMSPI_IFC_HOLD_OUT_HI | MCHP_QMSPI_IFC_HOLD_OUT_EN);
+
+	for (n = 0; n < MCHP_SAF_NUM_GENERIC_DESCR; n++) {
+		qregs->DESCR[MCHP_SAF_CM_EXIT_START_DESCR + n] =
+			hwcfg->generic_descr[n];
+	}
+
+	/* SAF HW uses QMSPI interrupt signal */
+	qregs->IEN = MCHP_QMSPI_IEN_XFR_DONE;
+
+	qmode |= (MCHP_QMSPI_M_SAF_DMA_MODE_EN | MCHP_QMSPI_M_CS0 |
+		  MCHP_QMSPI_M_ACTIVATE);
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_CPHA) {
+		qmode = (qmode & ~(MCHP_QMSPI_M_SIG_MASK)) |
+			((hwcfg->qmspi_cpha << MCHP_QMSPI_M_SIG_POS) &
+			 MCHP_QMSPI_M_SIG_MASK);
+	}
+
+
+	/* Copy QMSPI frequency divider into SAF CS0 and CS1 QMSPI frequency
+	 * dividers. SAF HW uses CS0/CS1 divider register fields to overwrite
+	 * QMSPI frequency divider in QMSPI.Mode register. Later we will update
+	 * SAF CS0/CS1 SPI frequency dividers based on flash configuration.
+	 */
+	qfdiv = (qmode & MCHP_QMSPI_M_FDIV_MASK) >> MCHP_QMSPI_M_FDIV_POS;
+	qfdiv = qfdiv | (qfdiv << 16); /* read and rest clock dividers */
+	regs->SAF_CLKDIV_CS0 = qfdiv;
+	regs->SAF_CLKDIV_CS1 = qfdiv;
+
+	if (hwcfg->flags & MCHP_SAF_HW_CFG_FLAG_CSTM) {
+		cstim = hwcfg->qmspi_cs_timing;
+	}
+
+	/* MEC172x SAF uses TX LDMA channel 0 in non-descriptor mode.
+	 * SAF HW writes QMSPI.Control and TX LDMA channel 0 registers
+	 * to transmit opcode, address, and data. We configure must
+	 * configure TX LDMA channel 0 control register. We believe SAF
+	 * HW will set bit[6] to 1.
+	 */
+	qregs->LDTX[0].CTRL = MCHP_QMSPI_LDC_EN | MCHP_QMSPI_LDC_RS_EN | MCHP_QMSPI_LDC_ASZ_4;
+
+	qmode |= MCHP_QMSPI_M_LDMA_RX_EN | MCHP_QMSPI_M_LDMA_TX_EN;
+
+	qregs->MODE = qmode;
+	qregs->CSTM = cstim;
+
+	return 0;
+}
+
+/*
+ * Registers at offsets:
+ * SAF Poll timeout @ 0x194.  Hard coded to 0x28000. Default value = 0.
+ *	recommended value = 0x28000 32KHz clocks (5 seconds). b[17:0]
+ * SAF Poll interval @ 0x198.  Hard coded to 0
+ *	Default value = 0. Recommended = 0. b[15:0]
+ * SAF Suspend/Resume Interval @ 0x19c.  Hard coded to 0x8
+ *	Default value = 0x01. Min time erase/prog in 32KHz units.
+ * SAF Consecutive Read Timeout @ 0x1a0. Hard coded to 0x2. b[15:0]
+ *	Units of MCLK. Recommend < 20us. b[19:0]
+ * SAF Suspend Check Delay @ 0x1ac. Not touched.
+ *	Default = 0. Recommend = 20us. Units = MCLK. b[19:0]
+ */
+static void saf_flash_timing_init(struct mchp_espi_saf * const regs,
+				  const struct espi_saf_xec_config *cfg)
+{
+	LOG_DBG("%s\n", __func__);
+	regs->SAF_POLL_TMOUT = cfg->poll_timeout;
+	regs->SAF_POLL_INTRVL = cfg->poll_interval;
+	regs->SAF_SUS_RSM_INTRVL = cfg->sus_rsm_interval;
+	regs->SAF_CONSEC_RD_TMOUT = cfg->consec_rd_timeout;
+	regs->SAF_SUS_CHK_DLY = cfg->sus_chk_delay;
+	LOG_DBG("SAF_POLL_TMOUT %x\n", regs->SAF_POLL_TMOUT);
+	LOG_DBG("SAF_POLL_INTRVL %x\n", regs->SAF_POLL_INTRVL);
+	LOG_DBG("SAF_SUS_RSM_INTRVL %x\n", regs->SAF_SUS_RSM_INTRVL);
+	LOG_DBG("SAF_CONSEC_RD_TMOUT %x\n", regs->SAF_CONSEC_RD_TMOUT);
+	LOG_DBG("SAF_SUS_CHK_DLY %x\n", regs->SAF_SUS_CHK_DLY);
+}
+
+/*
+ * Disable DnX bypass feature.
+ */
+static void saf_dnx_bypass_init(struct mchp_espi_saf * const regs)
+{
+	regs->SAF_DNX_PROT_BYP = 0;
+	regs->SAF_DNX_PROT_BYP = 0xffffffff;
+}
+
+/*
+ * Bitmap of flash erase size from 1KB up to 128KB.
+ * eSPI SAF specification requires 4KB erase support.
+ * MCHP SAF supports 4KB, 32KB, and 64KB.
+ * Only report 32KB and 64KB to Host if supported by both
+ * flash devices.
+ */
+static int saf_init_erase_block_size(const struct device *dev, const struct espi_saf_cfg *cfg)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_iom_regs * const espi_iom = xcfg->iom_base;
+	struct espi_saf_flash_cfg *fcfg = cfg->flash_cfgs;
+	uint32_t opb = fcfg->opb;
+	uint8_t erase_bitmap = MCHP_ESPI_SERASE_SZ_4K;
+
+	LOG_DBG("%s\n", __func__);
+
+	if (cfg->nflash_devices > 1) {
+		fcfg++;
+		opb &= fcfg->opb;
+	}
+
+	if ((opb & MCHP_SAF_CS_OPB_ER0_MASK) == 0) {
+		/* One or both do not support 4KB erase! */
+		return -EINVAL;
+	}
+
+	if (opb & MCHP_SAF_CS_OPB_ER1_MASK) {
+		erase_bitmap |= MCHP_ESPI_SERASE_SZ_32K;
+	}
+
+	if (opb & MCHP_SAF_CS_OPB_ER2_MASK) {
+		erase_bitmap |= MCHP_ESPI_SERASE_SZ_64K;
+	}
+
+	espi_iom->SAFEBS = erase_bitmap;
+
+	return 0;
+}
+
+/*
+ * Set the continuous mode prefix and 4-byte address mode bits
+ * based upon the flash configuration information.
+ * Updates:
+ * SAF Flash Config Poll2 Mask @ 0x1A4
+ * SAF Flash Config Special Mode @ 0x1B0
+ * SAF Flash Misc Config @ 0x38
+ */
+static void saf_flash_misc_cfg(struct mchp_espi_saf * const regs, uint8_t cs,
+			       const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t d, v;
+
+	d = regs->SAF_FL_CFG_MISC;
+
+	v = MCHP_SAF_FL_CFG_MISC_CS0_CPE;
+	if (cs) {
+		v = MCHP_SAF_FL_CFG_MISC_CS1_CPE;
+	}
+
+	/* Does this flash device require a prefix for continuous mode? */
+	if (fcfg->cont_prefix != 0) {
+		d |= v;
+	} else {
+		d &= ~v;
+	}
+
+	v = MCHP_SAF_FL_CFG_MISC_CS0_4BM;
+	if (cs) {
+		v = MCHP_SAF_FL_CFG_MISC_CS1_4BM;
+	}
+
+	/* Use 32-bit addressing for this flash device? */
+	if (fcfg->flags & MCHP_FLASH_FLAG_ADDR32) {
+		d |= v;
+	} else {
+		d &= ~v;
+	}
+
+	regs->SAF_FL_CFG_MISC = d;
+	LOG_DBG("%s SAF_FL_CFG_MISC: %x", __func__, d);
+}
+
+static void saf_flash_pd_cfg(struct mchp_espi_saf * const regs, uint8_t cs,
+			     const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t pdval = 0u;
+	uint32_t msk = 0u;
+
+	if (cs == 0) {
+		msk = BIT(SAF_PWRDN_CTRL_CS0_PD_EN_POS) | BIT(SAF_PWRDN_CTRL_CS0_PD_EN_POS);
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS0_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS0_PD_EN_POS);
+		}
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS0_EC_WK_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS0_WPA_EN_POS);
+		}
+	} else {
+		msk = BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS) | BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS);
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS1_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS);
+		}
+		if (fcfg->flags & MCHP_FLASH_FLAG_V2_PD_CS1_EC_WK_EN) {
+			pdval |= BIT(SAF_PWRDN_CTRL_CS1_PD_EN_POS);
+		}
+	}
+
+	regs->SAF_PWRDN_CTRL = (regs->SAF_PWRDN_CTRL & ~msk) | pdval;
+}
+
+/* Configure SAF per chip select QMSPI clock dividers.
+ * SAF HW implements two QMSP clock divider registers per chip select:
+ * Each divider register is composed of two 16-bit fields:
+ *   b[15:0] = QMSPI clock divider for SPI read
+ *   b[31:16] = QMSPI clock divider for all other SPI commands
+ */
+static int saf_flash_freq_cfg(struct mchp_espi_saf * const regs, uint8_t cs,
+			       const struct espi_saf_flash_cfg *fcfg)
+{
+	uint32_t fmhz, fdiv, saf_qclk;
+
+	if (cs == 0) {
+		saf_qclk = regs->SAF_CLKDIV_CS0;
+	} else {
+		saf_qclk = regs->SAF_CLKDIV_CS1;
+	}
+
+	fmhz = fcfg->rd_freq_mhz;
+	if (fmhz) {
+		fdiv = 0u;
+		if (qmspi_freq_div_from_mhz(fmhz, &fdiv)) {
+			LOG_ERR("%s SAF CLKDIV CS0 bad freq MHz %u",
+				__func__, fmhz);
+			return -EIO;
+		}
+		if (fdiv) {
+			saf_qclk = (saf_qclk & ~SAF_CLKDIV_CS_MSK0) |
+				   (fdiv & SAF_CLKDIV_CS_MSK0);
+		}
+	}
+
+	fmhz = fcfg->freq_mhz;
+	if (fmhz) {
+		fdiv = 0u;
+		if (qmspi_freq_div_from_mhz(fmhz, &fdiv)) {
+			LOG_ERR("%s SAF CLKDIV CS1 bad freq MHz %u",
+				__func__, fmhz);
+			return -EIO;
+		}
+		if (fdiv) {
+			saf_qclk &= ~(SAF_CLKDIV_CS_MSK0 << 16);
+			saf_qclk |= (fdiv & SAF_CLKDIV_CS_MSK0) << 16;
+		}
+	}
+
+	if (cs == 0) {
+		regs->SAF_CLKDIV_CS0 = saf_qclk;
+	} else {
+		regs->SAF_CLKDIV_CS1 = saf_qclk;
+	}
+
+	return 0;
+}
+
+/*
+ * Program flash device specific SAF and QMSPI registers.
+ *
+ * CS0 OpA @ 0x4c or CS1 OpA @ 0x5C
+ * CS0 OpB @ 0x50 or CS1 OpB @ 0x60
+ * CS0 OpC @ 0x54 or CS1 OpC @ 0x64
+ * Poll 2 Mask @ 0x1a4
+ * Continuous Prefix @ 0x1b0
+ * CS0: QMSPI descriptors 0-5 or CS1 QMSPI descriptors 6-11
+ * CS0 Descrs @ 0x58 or CS1 Descrs @ 0x68
+ * SAF CS0 QMSPI frequency dividers (read/all other) commands
+ * SAF CS1 QMSPI frequency dividers (read/all other) commands
+ */
+static int saf_flash_cfg(const struct device *dev,
+			 const struct espi_saf_flash_cfg *fcfg, uint8_t cs)
+{
+	uint32_t d, did;
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	struct qmspi_regs * const qregs = xcfg->qmspi_base;
+
+	LOG_DBG("%s cs=%u", __func__, cs);
+
+	regs->SAF_CS_OP[cs].OPA = fcfg->opa;
+	regs->SAF_CS_OP[cs].OPB = fcfg->opb;
+	regs->SAF_CS_OP[cs].OPC = fcfg->opc;
+	regs->SAF_CS_OP[cs].OP_DESCR = (uint32_t)fcfg->cs_cfg_descr_ids;
+
+	did = MCHP_SAF_QMSPI_CS0_START_DESCR;
+	if (cs != 0) {
+		did = MCHP_SAF_QMSPI_CS1_START_DESCR;
+	}
+
+	for (size_t i = 0; i < MCHP_SAF_QMSPI_NUM_FLASH_DESCR; i++) {
+		d = fcfg->descr[i] & ~(MCHP_QMSPI_C_NEXT_DESCR_MASK);
+		d |= (((did + 1) << MCHP_QMSPI_C_NEXT_DESCR_POS) &
+		      MCHP_QMSPI_C_NEXT_DESCR_MASK);
+		qregs->DESCR[did++] = d;
+	}
+
+	mchp_saf_poll2_mask_wr(regs, cs, fcfg->poll2_mask);
+	mchp_saf_cm_prefix_wr(regs, cs, fcfg->cont_prefix);
+	saf_flash_misc_cfg(regs, cs, fcfg);
+	saf_flash_pd_cfg(regs, cs, fcfg);
+
+	return saf_flash_freq_cfg(regs, cs, fcfg);
+}
+
+static const uint32_t tag_map_dflt[MCHP_ESPI_SAF_TAGMAP_MAX] = {
+	MCHP_SAF_TAG_MAP0_DFLT, MCHP_SAF_TAG_MAP1_DFLT, MCHP_SAF_TAG_MAP2_DFLT
+};
+
+static void saf_tagmap_init(struct mchp_espi_saf * const regs,
+			    const struct espi_saf_cfg *cfg)
+{
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	for (int i = 0; i < MCHP_ESPI_SAF_TAGMAP_MAX; i++) {
+		if (hwcfg->tag_map[i] & MCHP_SAF_HW_CFG_TAGMAP_USE) {
+			regs->SAF_TAG_MAP[i] = hwcfg->tag_map[i];
+		} else {
+			regs->SAF_TAG_MAP[i] = tag_map_dflt[i];
+		}
+	}
+
+	LOG_DBG("SAF TAG0 %x", regs->SAF_TAG_MAP[0]);
+	LOG_DBG("SAF TAG1 %x", regs->SAF_TAG_MAP[1]);
+	LOG_DBG("SAF TAG2 %x", regs->SAF_TAG_MAP[2]);
+}
+
+#define SAF_QSPI_LDMA_CTRL						\
+	(MCHP_QMSPI_LDC_EN | MCHP_QMSPI_LDC_RS_EN |			\
+	 MCHP_QMSPI_LDC_ASZ_4)
+
+static void saf_qmspi_ldma_cfg(const struct espi_saf_xec_config * const xcfg)
+{
+	struct qmspi_regs * const qregs = xcfg->qmspi_base;
+	uint32_t qmode = qregs->MODE;
+	uint32_t n, temp, chan;
+
+	qregs->MODE = qmode & ~(MCHP_QMSPI_M_ACTIVATE);
+
+	for (n = 0u; n < MCHP_QMSPI_MAX_DESCR; n++) {
+		temp = qregs->DESCR[n];
+		if (temp & MCHP_QMSPI_C_TX_MASK) {
+			chan = (temp & MCHP_QMSPI_C_TX_DMA_MASK) >> MCHP_QMSPI_C_TX_DMA_POS;
+			if (chan) { /* zero is disabled */
+				chan--; /* register array index starts at 0 */
+				qregs->LDMA_TX_DESCR_BM |= BIT(n);
+				qregs->LDTX[chan].CTRL = SAF_QSPI_LDMA_CTRL;
+			}
+		}
+		if (temp & MCHP_QMSPI_C_RX_EN) {
+			chan = (temp & MCHP_QMSPI_C_RX_DMA_MASK) >> MCHP_QMSPI_C_RX_DMA_POS;
+			if (chan) {
+				chan--;
+				qregs->LDMA_RX_DESCR_BM |= BIT(n);
+				qregs->LDRX[chan].CTRL = SAF_QSPI_LDMA_CTRL;
+			}
+		}
+	}
+
+	qregs->MODE = qmode;
+}
+
+/*
+ * Configure SAF and QMSPI for SAF operation based upon the
+ * number and characteristics of local SPI flash devices.
+ * NOTE: SAF is configured but not activated. SAF should be
+ * activated only when eSPI master sends Flash Channel enable
+ * message with MAF/SAF select flag.
+ */
+static int espi_saf_xec_configuration(const struct device *dev,
+				      const struct espi_saf_cfg *cfg)
+{
+	int ret = 0;
+	uint32_t totalsz = 0;
+	uint32_t u = 0;
+
+	LOG_DBG("%s", __func__);
+
+	if ((dev == NULL) || (cfg == NULL)) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	struct mchp_espi_saf_comm * const comm_regs = xcfg->saf_comm_base;
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+	const struct espi_saf_flash_cfg *fcfg = cfg->flash_cfgs;
+
+	if ((fcfg == NULL) || (cfg->nflash_devices == 0U) ||
+	    (cfg->nflash_devices > MCHP_SAF_MAX_FLASH_DEVICES)) {
+		return -EINVAL;
+	}
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return -EAGAIN;
+	}
+
+	saf_qmspi_init(xcfg, cfg);
+
+	regs->SAF_CS0_CFG_P2M = 0;
+	regs->SAF_CS1_CFG_P2M = 0;
+
+	regs->SAF_FL_CFG_GEN_DESCR = MCHP_SAF_FL_CFG_GEN_DESCR_STD;
+
+	/* global flash power down activity counter and interval time */
+	regs->SAF_AC_RELOAD = hwcfg->flash_pd_timeout;
+	regs->SAF_FL_PWR_TMOUT = hwcfg->flash_pd_min_interval;
+
+	/* flash device connected to CS0 required */
+	totalsz = fcfg->flashsz;
+	regs->SAF_FL_CFG_THRH = totalsz;
+	ret = saf_flash_cfg(dev, fcfg, 0);
+	if (ret) {
+		return ret;
+	}
+
+	/* optional second flash device connected to CS1 */
+	if (cfg->nflash_devices > 1) {
+		fcfg++;
+		totalsz += fcfg->flashsz;
+	}
+	/* Program CS1 configuration (same as CS0 if only one device) */
+	ret = saf_flash_cfg(dev, fcfg, 1);
+	if (ret) {
+		return ret;
+	}
+
+	if (totalsz == 0) {
+		return -EAGAIN;
+	}
+
+	regs->SAF_FL_CFG_SIZE_LIM = totalsz - 1;
+
+	LOG_DBG("SAF_FL_CFG_THRH = %x SAF_FL_CFG_SIZE_LIM = %x",
+		regs->SAF_FL_CFG_THRH, regs->SAF_FL_CFG_SIZE_LIM);
+
+	saf_tagmap_init(regs, cfg);
+
+	saf_protection_regions_init(regs);
+
+	saf_dnx_bypass_init(regs);
+
+	saf_flash_timing_init(regs, xcfg);
+
+	ret = saf_init_erase_block_size(dev, cfg);
+	if (ret != 0) {
+		LOG_ERR("SAF Config bad flash erase config");
+		return ret;
+	}
+
+	/* Default or expedited prefetch? */
+	u = MCHP_SAF_FL_CFG_MISC_PFOE_DFLT;
+	if (cfg->hwcfg.flags & MCHP_SAF_HW_CFG_FLAG_PFEXP) {
+		u = MCHP_SAF_FL_CFG_MISC_PFOE_EXP;
+	}
+
+	regs->SAF_FL_CFG_MISC =
+		(regs->SAF_FL_CFG_MISC & ~(MCHP_SAF_FL_CFG_MISC_PFOE_MASK)) | u;
+
+	/* enable prefetch ? */
+	if (cfg->hwcfg.flags & MCHP_SAF_HW_CFG_FLAG_PFEN) {
+		comm_regs->SAF_COMM_MODE |= MCHP_SAF_COMM_MODE_PF_EN;
+	} else {
+		comm_regs->SAF_COMM_MODE &= ~(MCHP_SAF_COMM_MODE_PF_EN);
+	}
+
+	LOG_DBG("%s SAF_FL_CFG_MISC: %x", __func__, regs->SAF_FL_CFG_MISC);
+	LOG_DBG("%s Aft MCHP_SAF_COMM_MODE_REG: %x", __func__,
+		comm_regs->SAF_COMM_MODE);
+
+	saf_qmspi_ldma_cfg(xcfg);
+
+	return 0;
+}
+
+static int espi_saf_xec_set_pr(const struct device *dev,
+			       const struct espi_saf_protection *pr)
+{
+	if ((dev == NULL) || (pr == NULL)) {
+		return -EINVAL;
+	}
+
+	if (pr->nregions >= MCHP_ESPI_SAF_PR_MAX) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return -EAGAIN;
+	}
+
+	const struct espi_saf_pr *preg = pr->pregions;
+	size_t n = pr->nregions;
+
+	while (n--) {
+		uint8_t regnum = preg->pr_num;
+
+		if (regnum >= MCHP_ESPI_SAF_PR_MAX) {
+			return -EINVAL;
+		}
+
+		/* NOTE: If previously locked writes have no effect */
+		if (preg->flags & MCHP_SAF_PR_FLAG_ENABLE) {
+			regs->SAF_PROT_RG[regnum].START = preg->start >> 12U;
+			regs->SAF_PROT_RG[regnum].LIMIT =
+				(preg->start + preg->size - 1U) >> 12U;
+			regs->SAF_PROT_RG[regnum].WEBM = preg->master_bm_we;
+			regs->SAF_PROT_RG[regnum].RDBM = preg->master_bm_rd;
+		} else {
+			regs->SAF_PROT_RG[regnum].START = 0x7FFFFU;
+			regs->SAF_PROT_RG[regnum].LIMIT = 0U;
+			regs->SAF_PROT_RG[regnum].WEBM = 0U;
+			regs->SAF_PROT_RG[regnum].RDBM = 0U;
+		}
+
+		if (preg->flags & MCHP_SAF_PR_FLAG_LOCK) {
+			regs->SAF_PROT_LOCK |= (1UL << regnum);
+		}
+
+		preg++;
+	}
+
+	return 0;
+}
+
+static bool espi_saf_xec_channel_ready(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+
+	if (regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN) {
+		return true;
+	}
+
+	return false;
+}
+
+/*
+ * MCHP SAF hardware supports a range of flash block erase
+ * sizes from 1KB to 128KB. The eSPI Host specification requires
+ * 4KB must be supported. The MCHP SAF QMSPI HW interface only
+ * supported three erase sizes. Most SPI flash devices chosen for
+ * SAF support 4KB, 32KB, and 64KB.
+ * Get flash erase sizes driver has configured from eSPI capabilities
+ * registers. We assume driver flash tables have opcodes to match
+ * capabilities configuration.
+ * Check requested erase size is supported.
+ */
+struct erase_size_encoding {
+	uint8_t hwbitpos;
+	uint8_t encoding;
+};
+
+static const struct erase_size_encoding ersz_enc[] = {
+	{ MCHP_ESPI_SERASE_SZ_4K_BITPOS, 0 },
+	{ MCHP_ESPI_SERASE_SZ_32K_BITPOS, 1 },
+	{ MCHP_ESPI_SERASE_SZ_64K_BITPOS, 2 }
+};
+
+#define SAF_ERASE_ENCODING_MAX_ENTRY                                           \
+	(sizeof(ersz_enc) / sizeof(struct erase_size_encoding))
+
+static uint32_t get_erase_size_encoding(const struct device *dev, uint32_t erase_size)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_iom_regs * const espi_iom = xcfg->iom_base;
+	uint8_t supsz = espi_iom->SAFEBS;
+
+	LOG_DBG("%s\n", __func__);
+	for (int i = 0; i < SAF_ERASE_ENCODING_MAX_ENTRY; i++) {
+		uint32_t sz = MCHP_ESPI_SERASE_SZ(ersz_enc[i].hwbitpos);
+
+		if ((sz == erase_size) &&
+		    (supsz & (1 << ersz_enc[i].hwbitpos))) {
+			return ersz_enc[i].encoding;
+		}
+	}
+
+	return 0xffffffffU;
+}
+
+static int check_ecp_access_size(uint32_t reqlen)
+{
+	if ((reqlen < MCHP_SAF_ECP_CMD_RW_LEN_MIN) ||
+	    (reqlen > MCHP_SAF_ECP_CMD_RW_LEN_MAX)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+/*
+ * EC access to SAF atttached flash array
+ * Allowed commands:
+ * MCHP_SAF_ECP_CMD_READ(0x0), MCHP_SAF_ECP_CMD_WRITE(0x01),
+ * MCHP_SAF_ECP_CMD_ERASE(0x02), MCHP_SAF_ECP_CMD_RPMC_OP1_CS0(0x03),
+ * MCHP_SAF_ECP_CMD_RPMC_OP2_CS0(0x04), MCHP_SAF_ECP_CMD_RPMC_OP1_CS1(0x83),
+ * MCHP_SAF_ECP_CMD_RPMC_OP2_CS1(0x84)
+ */
+static int saf_ecp_access(const struct device *dev,
+			  struct espi_saf_packet *pckt, uint8_t cmd)
+{
+	uint32_t scmd, err_mask, n;
+	int rc, counter;
+	struct espi_saf_xec_data *xdat = dev->data;
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[0];
+
+	counter = 0;
+	err_mask = MCHP_SAF_ECP_STS_ERR_MASK;
+
+	LOG_DBG("%s", __func__);
+
+	if (!(regs->SAF_FL_CFG_MISC & MCHP_SAF_FL_CFG_MISC_SAF_EN)) {
+		LOG_ERR("SAF is disabled");
+		return -EIO;
+	}
+
+	n = regs->SAF_ECP_BUSY;
+	if (n & (MCHP_SAF_ECP_EC0_BUSY | MCHP_SAF_ECP_EC1_BUSY)) {
+		LOG_ERR("SAF EC Portal is busy: 0x%08x", n);
+		return -EBUSY;
+	}
+
+	switch (cmd) {
+	case MCHP_SAF_ECP_CMD_READ:
+	case MCHP_SAF_ECP_CMD_WRITE:
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal size out of bounds");
+			return rc;
+		}
+
+		if (cmd == MCHP_SAF_ECP_CMD_WRITE) {
+			memcpy(slave_mem, pckt->buf, pckt->len);
+		}
+
+		n = pckt->len;
+		break;
+	case MCHP_SAF_ECP_CMD_ERASE:
+		n = get_erase_size_encoding(dev, pckt->len);
+		if (n == UINT32_MAX) {
+			LOG_ERR("SAF EC Portal unsupported erase size");
+			return -EAGAIN;
+		}
+		break;
+	case MCHP_SAF_ECP_CMD_RPMC_OP1_CS0:
+	case MCHP_SAF_ECP_CMD_RPMC_OP2_CS0:
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal RPMC size out of bounds");
+			return rc;
+		}
+		if (!(regs->SAF_CFG_CS0_OPD & SAF_CFG_CS_OPC_RPMC_OP2_MSK)) {
+			LOG_ERR("SAF CS0 RPMC opcode not configured");
+			return -EIO;
+		}
+		n = pckt->len;
+		break;
+	case MCHP_SAF_ECP_CMD_RPMC_OP1_CS1:
+	case MCHP_SAF_ECP_CMD_RPMC_OP2_CS1:
+		rc = check_ecp_access_size(pckt->len);
+		if (rc) {
+			LOG_ERR("SAF EC Portal RPMC size out of bounds");
+			return rc;
+		}
+		if (!(regs->SAF_CFG_CS1_OPD & SAF_CFG_CS_OPC_RPMC_OP2_MSK)) {
+			LOG_ERR("SAF CS1 RPMC opcode not configured");
+			return -EIO;
+		}
+		n = pckt->len;
+		break;
+	default:
+		LOG_ERR("SAF EC Portal bad cmd");
+		return -EAGAIN;
+	}
+
+	LOG_DBG("%s params val done", __func__);
+
+	regs->SAF_ECP_INTEN = 0;
+	regs->SAF_ECP_STATUS = MCHP_SAF_ECP_STS_MASK;
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	regs->SAF_ECP_INTEN = BIT(MCHP_SAF_ECP_INTEN_DONE_POS);
+
+	regs->SAF_ECP_FLAR = pckt->flash_addr;
+	regs->SAF_ECP_BFAR = (uint32_t)&slave_mem[0];
+
+	scmd = MCHP_SAF_ECP_CMD_PUT_FLASH_NP |
+		((uint32_t)cmd << MCHP_SAF_ECP_CMD_CTYPE_POS) |
+		((n << MCHP_SAF_ECP_CMD_LEN_POS) & MCHP_SAF_ECP_CMD_LEN_MASK);
+
+	LOG_DBG("%s ECP_FLAR=0x%x", __func__, regs->SAF_ECP_FLAR);
+	LOG_DBG("%s ECP_BFAR=0x%x", __func__, regs->SAF_ECP_BFAR);
+	LOG_DBG("%s ECP_CMD=0x%x", __func__, scmd);
+
+	regs->SAF_ECP_CMD = scmd;
+	regs->SAF_ECP_START = MCHP_SAF_ECP_START;
+
+	rc = k_sem_take(&xdat->ecp_lock, K_MSEC(MAX_SAF_FLASH_TIMEOUT_MS));
+	if (rc == -EAGAIN) {
+		LOG_ERR("%s timeout", __func__);
+		return -ETIMEDOUT;
+	}
+
+	LOG_DBG("%s wake on semaphore", __func__);
+
+	n = regs->SAF_ECP_STATUS;
+	/* clear hardware status and check for errors */
+	if (n & err_mask) {
+		regs->SAF_ECP_STATUS = n;
+		LOG_ERR("%s error %x", __func__, n);
+		return -EIO;
+	}
+
+	if (cmd == MCHP_SAF_ECP_CMD_READ) {
+		memcpy(pckt->buf, slave_mem, pckt->len);
+	}
+
+	return rc;
+}
+
+/* Flash read using SAF EC Portal */
+static int saf_xec_flash_read(const struct device *dev,
+			      struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_READ);
+}
+
+/* Flash write using SAF EC Portal */
+static int saf_xec_flash_write(const struct device *dev,
+			       struct espi_saf_packet *pckt)
+{
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_WRITE);
+}
+
+/* Flash erase using SAF EC Portal */
+static int saf_xec_flash_erase(const struct device *dev,
+			       struct espi_saf_packet *pckt)
+{
+	return saf_ecp_access(dev, pckt, MCHP_SAF_ECP_CMD_ERASE);
+}
+
+static int espi_saf_xec_manage_callback(const struct device *dev,
+					struct espi_callback *callback,
+					bool set)
+{
+	struct espi_saf_xec_data *data = dev->data;
+
+	return espi_manage_callback(&data->callbacks, callback, set);
+}
+
+static int espi_saf_xec_activate(const struct device *dev)
+{
+	if (dev == NULL) {
+		return -EINVAL;
+	}
+
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[1];
+
+	regs->SAF_ESPI_MON_STATUS = MCHP_SAF_ESPI_MON_STS_IEN_MSK;
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	regs->SAF_FL_CFG_MISC |= MCHP_SAF_FL_CFG_MISC_SAF_EN;
+	regs->SAF_ESPI_MON_INTEN = (BIT(MCHP_SAF_ESPI_MON_STS_IEN_TMOUT_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_OOR_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_AV_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_BND_4K_POS) |
+				    BIT(MCHP_SAF_ESPI_MON_STS_IEN_ERSZ_POS));
+
+	k_busy_wait(1000); /* TODO FIXME get estimate of time interval */
+
+	return 0;
+}
+
+static void espi_saf_done_isr(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_saf_xec_data *data = dev->data;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[0];
+	uint32_t ecp_status = regs->SAF_ECP_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_SAF_NOTIFICATION,
+				  .evt_details = BIT(0),
+				  .evt_data = ecp_status };
+
+	regs->SAF_ECP_INTEN = 0u;
+	regs->SAF_ECP_STATUS = BIT(MCHP_SAF_ECP_STS_DONE_POS);
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	data->hwstatus = ecp_status;
+
+	LOG_DBG("SAF Done ISR: status=0x%x", ecp_status);
+
+	espi_send_callbacks(&data->callbacks, dev, evt);
+
+	k_sem_give(&data->ecp_lock);
+}
+
+static void espi_saf_err_isr(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_saf_xec_data *data = dev->data;
+	struct mchp_espi_saf * const regs = xcfg->saf_base;
+	const struct espi_xec_irq_info *safirq = &xcfg->irq_info_list[1];
+	uint32_t mon_status = regs->SAF_ESPI_MON_STATUS;
+	struct espi_event evt = { .evt_type = ESPI_BUS_PERIPHERAL_NOTIFICATION,
+				  .evt_details = BIT(7),
+				  .evt_data = mon_status };
+
+	regs->SAF_ESPI_MON_STATUS = mon_status;
+	mchp_xec_ecia_girq_src_clr(safirq->gid, safirq->gpos);
+
+	data->hwstatus = mon_status;
+	espi_send_callbacks(&data->callbacks, dev, evt);
+}
+
+static const struct espi_saf_driver_api espi_saf_xec_driver_api = {
+	.config = espi_saf_xec_configuration,
+	.set_protection_regions = espi_saf_xec_set_pr,
+	.activate = espi_saf_xec_activate,
+	.get_channel_status = espi_saf_xec_channel_ready,
+	.flash_read = saf_xec_flash_read,
+	.flash_write = saf_xec_flash_write,
+	.flash_erase = saf_xec_flash_erase,
+	.manage_callback = espi_saf_xec_manage_callback,
+};
+
+static int espi_saf_xec_init(const struct device *dev)
+{
+	const struct espi_saf_xec_config * const xcfg = dev->config;
+	struct espi_saf_xec_data * const data = dev->data;
+	struct espi_iom_regs * const espi_iom = xcfg->iom_base;
+
+	/* ungate SAF clocks by disabling PCR sleep enable */
+	z_mchp_xec_pcr_periph_sleep(xcfg->pcr_idx, xcfg->pcr_pos, 0);
+
+	/* Configure the channels and its capabilities based on build config */
+	espi_iom->CAP0 |= MCHP_ESPI_GBL_CAP0_FC_SUPP;
+	espi_iom->CAPFC &= ~(MCHP_ESPI_FC_CAP_SHARE_MASK);
+	espi_iom->CAPFC |= MCHP_ESPI_FC_CAP_SHARE_MAF_SAF;
+
+	xcfg->irq_config_func();
+
+	k_sem_init(&data->ecp_lock, 0, 1);
+
+	return 0;
+}
+
+
+/* n = node-id, p = property, i = index */
+#define XEC_SAF_IRQ_INFO(n, p, i)					    \
+	{								    \
+		.gid = MCHP_XEC_ECIA_GIRQ(DT_PROP_BY_IDX(n, p, i)),	    \
+		.gpos = MCHP_XEC_ECIA_GIRQ_POS(DT_PROP_BY_IDX(n, p, i)),    \
+		.anid = MCHP_XEC_ECIA_NVIC_AGGR(DT_PROP_BY_IDX(n, p, i)),   \
+		.dnid = MCHP_XEC_ECIA_NVIC_DIRECT(DT_PROP_BY_IDX(n, p, i)), \
+	},
+
+#define ESPI_SAF_XEC_DEVICE(n)								\
+											\
+	static struct espi_saf_xec_data espisaf_xec_data_##n;				\
+											\
+	static void espi_saf_xec_connect_irqs_##n(void);				\
+											\
+	static const struct espi_xec_irq_info espi_saf_xec_irq_info_##n[] = {		\
+		DT_INST_FOREACH_PROP_ELEM(n, girqs, XEC_SAF_IRQ_INFO)			\
+	};										\
+											\
+	static const struct espi_saf_xec_config espisaf_xec_config_##n = {		\
+		.saf_base = (struct mchp_espi_saf * const)(				\
+					DT_INST_REG_ADDR_BY_IDX(n, 0)),			\
+		.qmspi_base = (struct qmspi_regs * const)(				\
+						DT_INST_REG_ADDR_BY_IDX(n, 1)),		\
+		.saf_comm_base = (struct mchp_espi_saf_comm * const)(			\
+							DT_INST_REG_ADDR_BY_IDX(n, 2)),	\
+		.iom_base = (struct espi_iom_regs * const)(				\
+					DT_REG_ADDR_BY_NAME(DT_INST_PARENT(n), io)),	\
+		.poll_timeout = DT_INST_PROP_OR(n, poll_timeout,			\
+						MCHP_SAF_FLASH_POLL_TIMEOUT),		\
+		.consec_rd_timeout = DT_INST_PROP_OR(					\
+			n, consec_rd_timeout, MCHP_SAF_FLASH_CONSEC_READ_TIMEOUT),	\
+		.sus_chk_delay = DT_INST_PROP_OR(n, sus_chk_delay,			\
+						 MCHP_SAF_FLASH_SUS_CHK_DELAY),		\
+		.sus_rsm_interval = DT_INST_PROP_OR(n, sus_rsm_interval,		\
+						    MCHP_SAF_FLASH_SUS_RSM_INTERVAL),	\
+		.poll_interval = DT_INST_PROP_OR(n, poll_interval,			\
+						 MCHP_SAF_FLASH_POLL_INTERVAL),		\
+		.pcr_idx = DT_INST_PROP_BY_IDX(n, pcrs, 0),				\
+		.pcr_pos = DT_INST_PROP_BY_IDX(n, pcrs, 1),				\
+		.irq_config_func = espi_saf_xec_connect_irqs_##n,			\
+		.irq_info_size = ARRAY_SIZE(espi_saf_xec_irq_info_##n),			\
+		.irq_info_list = espi_saf_xec_irq_info_##n,				\
+	};										\
+	DEVICE_DT_INST_DEFINE(0, &espi_saf_xec_init, NULL,				\
+				  &espisaf_xec_data_##n,				\
+				  &espisaf_xec_config_##n, POST_KERNEL,			\
+				  CONFIG_ESPI_SAF_INIT_PRIORITY,			\
+				  &espi_saf_xec_driver_api);				\
+											\
+	static void espi_saf_xec_connect_irqs_##n(void)					\
+	{										\
+		uint8_t girq, gpos;							\
+											\
+		/* SAF Done */								\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),				\
+				DT_INST_IRQ_BY_IDX(n, 0, priority),			\
+				espi_saf_done_isr,					\
+				DEVICE_DT_INST_GET(n), 0);				\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));				\
+											\
+		girq = MCHP_XEC_ECIA_GIRQ(DT_INST_PROP_BY_IDX(n, girqs, 0));		\
+		gpos = MCHP_XEC_ECIA_GIRQ_POS(DT_INST_PROP_BY_IDX(n, girqs, 0));	\
+		mchp_xec_ecia_girq_src_en(girq, gpos);					\
+											\
+		/* SAF Error */								\
+		IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 1, irq),				\
+				DT_INST_IRQ_BY_IDX(n, 1, priority),			\
+				espi_saf_err_isr,					\
+				DEVICE_DT_INST_GET(n), 0);				\
+		irq_enable(DT_INST_IRQ_BY_IDX(n, 1, irq));				\
+											\
+		girq = MCHP_XEC_ECIA_GIRQ(DT_INST_PROP_BY_IDX(n, girqs, 1));		\
+		gpos = MCHP_XEC_ECIA_GIRQ_POS(DT_INST_PROP_BY_IDX(n, girqs, 1));	\
+		mchp_xec_ecia_girq_src_en(girq, gpos);					\
+	}
+
+DT_INST_FOREACH_STATUS_OKAY(ESPI_SAF_XEC_DEVICE)
diff --git a/drivers/espi/espi_taf_npcx.c b/drivers/espi/espi_taf_npcx.c
new file mode 100644
index 0000000000..01c7ce97d8
--- /dev/null
+++ b/drivers/espi/espi_taf_npcx.c
@@ -0,0 +1,491 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_espi_taf
+
+#include <soc.h>
+#include <zephyr/drivers/espi.h>
+#include <zephyr/drivers/espi_saf.h>
+#include <zephyr/drivers/flash.h>
+#include <zephyr/kernel.h>
+#include <zephyr/logging/log.h>
+
+LOG_MODULE_REGISTER(espi_taf, CONFIG_ESPI_LOG_LEVEL);
+
+static const struct device *const spi_dev = DEVICE_DT_GET(DT_ALIAS(taf_flash));
+
+struct espi_taf_npcx_config {
+	uintptr_t base;
+	uintptr_t mapped_addr;
+	enum ESPI_FLASH_TAF_ERASE_BLOCK_SIZE erase_sz;
+	enum ESPI_FLASH_TAF_MAX_READ_REQ max_rd_sz;
+};
+
+struct espi_taf_npcx_data {
+	sys_slist_t callbacks;
+};
+
+#define HAL_INSTANCE(dev)						\
+	((struct espi_reg *)((const struct espi_taf_npcx_config *)	\
+	(dev)->config)->base)
+
+#define DT_INST_ERASE_SZ_PROP_OR(inst)					\
+	COND_CODE_1(DT_INST_NODE_HAS_PROP(inst, erase_sz),		\
+		    (_CONCAT(ESPI_FLASH_TAF_ERASE_BLOCK_,		\
+		     DT_INST_STRING_TOKEN(inst, erase_sz))),		\
+		    ((ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_4KB)))
+
+#define DT_INST_MAX_READ_SZ_PROP_OR(inst)				\
+	COND_CODE_1(DT_INST_NODE_HAS_PROP(inst, max_read_sz),		\
+		    (_CONCAT(ESPI_FLASH_TAF_MAX_READ_REQ_,		\
+		     DT_INST_STRING_TOKEN(inst, max_read_sz))),		\
+		    ((ESPI_FLASH_TAF_MAX_READ_REQ_64B)))
+
+/* Check access region of read request is protected or not */
+bool espi_taf_check_read_protect(const struct device *dev, uint32_t addr, uint32_t len,
+				 uint8_t tag)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint8_t i = 0;
+	uint16_t override_rd;
+	uint32_t flash_addr = addr;
+	uint32_t base, high;
+	bool rdpr;
+
+	flash_addr +=
+		GET_FIELD(inst->FLASHBASE, NPCX_FLASHBASE_FLBASE_ADDR)
+		<< GET_POS(NPCX_FLASHBASE_FLBASE_ADDR);
+
+	for (i = 0; i < CONFIG_ESPI_TAF_PR_NUM; i++) {
+		base = GET_FIELD(inst->FLASH_PRTR_BADDR[i],
+				 NPCX_FLASH_PRTR_BADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_BADDR);
+		high = GET_FIELD(inst->FLASH_PRTR_HADDR[i],
+				 NPCX_FLASH_PRTR_HADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_HADDR);
+		high |= 0xFFF;
+
+		rdpr = IS_BIT_SET(inst->FLASH_PRTR_BADDR[i], NPCX_FRGN_RPR) ? true : false;
+		override_rd = GET_FIELD(inst->FLASH_RGN_TAG_OVR[i], NPCX_FLASH_TAG_OVR_RPR);
+
+		if (rdpr && !IS_BIT_SET(override_rd, tag) &&
+		    (base <= flash_addr + len - 1 && flash_addr <= high)) {
+			return true;
+		}
+	}
+
+	return false;
+}
+
+/* Check access region of write request is protected or not */
+bool espi_taf_check_write_protect(const struct device *dev, uint32_t addr,
+				  uint32_t len, uint8_t tag)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint8_t i = 0;
+	uint16_t override_wr;
+	uint32_t base, high;
+	uint32_t flash_addr = addr;
+	bool wrpr;
+
+	flash_addr +=
+		GET_FIELD(inst->FLASHBASE, NPCX_FLASHBASE_FLBASE_ADDR)
+		<< GET_POS(NPCX_FLASHBASE_FLBASE_ADDR);
+
+	for (i = 0; i < CONFIG_ESPI_TAF_PR_NUM; i++) {
+		base = GET_FIELD(inst->FLASH_PRTR_BADDR[i], NPCX_FLASH_PRTR_BADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_BADDR);
+		high = GET_FIELD(inst->FLASH_PRTR_HADDR[i], NPCX_FLASH_PRTR_HADDR)
+				 << GET_POS(NPCX_FLASH_PRTR_HADDR);
+		high |= 0xFFF;
+
+		wrpr = IS_BIT_SET(inst->FLASH_PRTR_BADDR[i], NPCX_FRGN_WPR) ? true : false;
+		override_wr = GET_FIELD(inst->FLASH_RGN_TAG_OVR[i], NPCX_FLASH_TAG_OVR_WPR);
+
+		if (wrpr && !IS_BIT_SET(override_wr, tag) &&
+		    (base <= flash_addr + len - 1 && flash_addr <= high)) {
+			return true;
+		}
+	}
+
+	return false;
+}
+
+int espi_taf_npcx_configuration(const struct device *dev, const struct espi_saf_cfg *cfg)
+{
+	LOG_INF("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	const struct espi_saf_hw_cfg *hwcfg = &cfg->hwcfg;
+
+	if (hwcfg->mode == ESPI_TAF_STANDARD_MODE) {
+		inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_SAF_AUTO_READ);
+	} else {
+		inst->FLASHCTL |= BIT(NPCX_FLASHCTL_SAF_AUTO_READ);
+	}
+
+	return 0;
+}
+
+int espi_taf_npcx_set_pr(const struct device *dev, const struct espi_saf_protection *pr)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	const struct espi_saf_pr *preg = pr->pregions;
+	size_t n = pr->nregions;
+	uint8_t regnum;
+	uint32_t rw_pr, override_rw;
+
+	if ((dev == NULL) || (pr == NULL)) {
+		return -EINVAL;
+	}
+
+	if (pr->nregions >= CONFIG_ESPI_TAF_PR_NUM) {
+		return -EINVAL;
+	}
+
+	while (n--) {
+		regnum = preg->pr_num;
+
+		if (regnum >= CONFIG_ESPI_TAF_PR_NUM) {
+			return -EINVAL;
+		}
+
+		rw_pr = preg->master_bm_we << NPCX_FRGN_WPR;
+		rw_pr = rw_pr | (preg->master_bm_rd << NPCX_FRGN_RPR);
+
+		if (preg->flags) {
+			inst->FLASH_PRTR_BADDR[regnum] = (preg->start << 12U) | rw_pr;
+			inst->FLASH_PRTR_HADDR[regnum] = preg->end << 12U;
+		}
+
+		override_rw = (preg->override_r << 16) | preg->override_w;
+		inst->FLASH_RGN_TAG_OVR[regnum] = override_rw;
+		preg++;
+	}
+
+	return 0;
+}
+
+static int espi_taf_npcx_activate(const struct device *dev)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_AUTO_RD_DIS_CTL);
+	inst->FLASHCTL &= ~BIT(NPCX_FLASHCTL_BLK_FLASH_NP_FREE);
+
+	return 0;
+}
+
+bool espi_taf_npcx_channel_ready(const struct device *dev)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	if (!IS_BIT_SET(inst->ESPICFG, NPCX_ESPICFG_FLCHANMODE)) {
+		return false;
+	}
+	return true;
+}
+
+/* This routine set FLASH_C_AVAIL for standard request */
+void taf_set_flash_c_avail(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp = inst->FLASHCTL;
+
+	/*
+	 * Clear FLASHCTL_FLASH_NP_FREE to avoid host puts a flash
+	 * standard request command at here.
+	 */
+	tmp &= FLASHCTL_ACCESS_MASK;
+
+	/* set FLASHCTL_FLASH_TX_AVAIL */
+	tmp |= BIT(NPCX_FLASHCTL_FLASH_TX_AVAIL);
+	inst->FLASHCTL = tmp;
+}
+
+/* This routine release FLASH_NP_FREE for standard request */
+void taf_release_flash_np_free(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp = inst->FLASHCTL;
+
+	/*
+	 * Clear FLASHCTL_FLASH_TX_AVAIL to avoid host puts a
+	 * GET_FLASH_C command at here.
+	 */
+	tmp &= FLASHCTL_ACCESS_MASK;
+
+	/* release FLASH_NP_FREE */
+	tmp |= BIT(NPCX_FLASHCTL_FLASH_NP_FREE);
+	inst->FLASHCTL = tmp;
+}
+
+/* This routine resets eSPI flash channel indirect buffer head */
+void reset_indirect_buffer_head(const struct device *dev)
+{
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	uint32_t tmp;
+
+	tmp = inst->FLASHCTL;
+
+	/*
+	 * Clear FLASHCTL_FLASH_NP_FREE and FLASHCTL_FLASH_TX_AVAIL
+	 * to avoid host puts a flash standard request or a GET_FLASH_C
+	 * command at here.
+	 */
+	tmp &= FLASHCTL_ACCESS_MASK;
+
+	/* release FLASHCTL_RSTBUFHEADS */
+	tmp |= BIT(NPCX_FLASHCTL_RSTBUFHEADS);
+	inst->FLASHCTL = tmp;
+}
+
+void taf_npcx_completion_handler(const struct device *dev, uint32_t *buffer)
+{
+	LOG_DBG("%s", __func__);
+	uint8_t i;
+	uint16_t size = DIV_ROUND_UP((uint8_t)(buffer[0]) + 1, sizeof(uint32_t));
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Check the Flash Access TX Queue is empty by polling
+	 * FLASH_TX_AVAIL.
+	 */
+	while (IS_BIT_SET(inst->FLASHCTL, NPCX_FLASHCTL_FLASH_TX_AVAIL)) {
+		;
+	}
+
+	/* check ESPISTS.FLNACS is clear (no slave completion is detected) */
+	while (IS_BIT_SET(inst->ESPISTS, NPCX_ESPISTS_FLNACS)) {
+		;
+	}
+
+	/* Write packet to FLASHTXBUF */
+	if (IS_ENABLED(CONFIG_ESPI_TAF_DIRECT_ACCESS)) { /* direct mode */
+		for (i = 0; i < size; i++) {
+			inst->FLASHTXBUF[i] = buffer[i];
+		}
+	} else { /* indirect mode */
+		reset_indirect_buffer_head(dev);
+		for (i = 0; i < size; i++) {
+			inst->FLASHTXWRHEAD = buffer[i];
+		}
+	}
+
+	/* Set the FLASHCTL.FLASH_TX_AVAIL bit to 1 to enqueue the packet */
+	taf_set_flash_c_avail(dev);
+
+	/* release FLASH_NP_FREE here to ready get next TAF request*/
+	if ((MSB2(buffer[0]) != CYC_SCS_CMP_WITH_DATA_FIRST) &&
+	    (MSB2(buffer[0]) != CYC_SCS_CMP_WITH_DATA_MIDDLE)) {
+		taf_release_flash_np_free(dev);
+	}
+}
+
+int espi_taf_npcx_flash_read(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
+	uint8_t cycle_type = CYC_SCS_CMP_WITH_DATA_ONLY;
+	uint32_t total_len = pckt->len;
+	uint32_t len = total_len;
+	uint32_t addr = pckt->flash_addr;
+	uint8_t flashreqsize = GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLASHREQSIZE);
+	uint8_t targetmaxsize = GET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLREQSUP);
+	uint16_t max_read_req = 32 << flashreqsize;
+	int rc;
+
+	if (flashreqsize > targetmaxsize) {
+		LOG_DBG("Exceeded the maximum supported length");
+		if (targetmaxsize == 0) {
+			targetmaxsize = 1;
+		}
+		max_read_req = 32 << targetmaxsize;
+	}
+
+	if (total_len > max_read_req) {
+		LOG_ERR("Exceeded the limitation of read length");
+		return -EINVAL;
+	}
+
+	if (espi_taf_check_read_protect(dev, addr, len, taf_data_ptr->tag)) {
+		LOG_ERR("Access protect region");
+		return -EINVAL;
+	}
+
+	if (total_len <= MAX_FLASH_REQUEST) {
+		cycle_type = CYC_SCS_CMP_WITH_DATA_ONLY;
+		len = total_len;
+	} else {
+		cycle_type = CYC_SCS_CMP_WITH_DATA_FIRST;
+		len = MAX_FLASH_REQUEST;
+	}
+
+	do {
+		data_ptr = (uint8_t *)taf_data_ptr->data;
+		*data_ptr++ = len + 3;
+		*data_ptr++ = cycle_type;
+		*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+		*data_ptr++ = MSB3(len);
+
+		rc = flash_read(spi_dev, addr, data_ptr, len);
+		if (rc) {
+			LOG_ERR("flash read fail 0x%x", rc);
+			return -EIO;
+		}
+
+		taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+
+		total_len -= len;
+		addr += len;
+
+		if (total_len <= MAX_FLASH_REQUEST) {
+			cycle_type = CYC_SCS_CMP_WITH_DATA_LAST;
+			len = total_len;
+		} else {
+			cycle_type = CYC_SCS_CMP_WITH_DATA_MIDDLE;
+		}
+	} while (total_len);
+
+	return 0;
+}
+
+int espi_taf_npcx_flash_write(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)(taf_data_ptr->data);
+	uint16_t len;
+	int rc;
+
+	if (espi_taf_check_write_protect(dev, pckt->flash_addr,
+					 pckt->len, taf_data_ptr->tag)) {
+		LOG_ERR("Access protection region");
+		return -EINVAL;
+	}
+
+	rc = flash_write(spi_dev, pckt->flash_addr, data_ptr, pckt->len);
+	if (rc) {
+		LOG_ERR("flash write fail 0x%x", rc);
+		return -EIO;
+	}
+
+	/* Completion without Data the length field must be driven to zeros */
+	len = 0;
+
+	*data_ptr++ = len + 3;
+	*data_ptr++ = CYC_SCS_CMP_WITHOUT_DATA;
+	*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+	*data_ptr++ = MSB3(len);
+
+	taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	return 0;
+}
+
+int espi_taf_npcx_flash_erase(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_taf_npcx_pckt *taf_data_ptr = (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
+	uint32_t addr = pckt->flash_addr;
+	uint32_t len = pckt->len;
+	int rc;
+
+	if (espi_taf_check_write_protect(dev, addr, len, taf_data_ptr->tag)) {
+		LOG_ERR("Access protect region");
+		return -EINVAL;
+	}
+
+	rc = flash_erase(spi_dev, addr, len);
+	if (rc) {
+		LOG_ERR("flash erase fail");
+		return -EIO;
+	}
+
+	/* Completion without Data the length field must be driven to zeros */
+	len = 0;
+
+	*data_ptr++ = len + 3;
+	*data_ptr++ = CYC_SCS_CMP_WITHOUT_DATA;
+	*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+	*data_ptr++ = MSB3(len);
+
+	taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	return 0;
+}
+
+int espi_taf_npcx_flash_unsuccess(const struct device *dev, struct espi_saf_packet *pckt)
+{
+	LOG_DBG("%s", __func__);
+	uint16_t len;
+	struct espi_taf_npcx_pckt *taf_data_ptr
+			= (struct espi_taf_npcx_pckt *)pckt->buf;
+	uint8_t *data_ptr = (uint8_t *)taf_data_ptr->data;
+
+	/* Completion without Data the length field must be driven to zeros */
+	len = 0;
+
+	*data_ptr++ = len + 3;
+	*data_ptr++ = CYC_UNSCS_CMP_WITHOUT_DATA_ONLY;
+	*data_ptr++ = MAKE8(LSN(MSB2(len)), taf_data_ptr->tag);
+	*data_ptr++ = MSB3(len);
+
+	taf_npcx_completion_handler(dev, (uint32_t *)taf_data_ptr->data);
+	return 0;
+}
+
+static int espi_taf_npcx_manage_callback(const struct device *dev, struct espi_callback *callback,
+					 bool set)
+{
+	LOG_DBG("%s", __func__);
+	return 0;
+}
+
+int espi_taf_npcx_init(const struct device *dev)
+{
+	LOG_DBG("%s", __func__);
+	struct espi_reg *const inst = HAL_INSTANCE(dev);
+	const struct espi_taf_npcx_config *config = dev->config;
+
+	SET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLCAPA,
+		  ESPI_FLASH_SHARING_CAP_SUPP_TAF_AND_CAF);
+	SET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_TRGFLEBLKSIZE,
+		  BIT(config->erase_sz));
+	SET_FIELD(inst->FLASHCFG, NPCX_FLASHCFG_FLREQSUP,
+		  config->max_rd_sz);
+	inst->FLASHBASE = config->mapped_addr;
+
+	return 0;
+}
+
+static const struct espi_saf_driver_api espi_taf_npcx_driver_api = {
+	.config = espi_taf_npcx_configuration,
+	.set_protection_regions = espi_taf_npcx_set_pr,
+	.activate = espi_taf_npcx_activate,
+	.get_channel_status = espi_taf_npcx_channel_ready,
+	.flash_read = espi_taf_npcx_flash_read,
+	.flash_write = espi_taf_npcx_flash_write,
+	.flash_erase = espi_taf_npcx_flash_erase,
+	.flash_unsuccess = espi_taf_npcx_flash_unsuccess,
+	.manage_callback = espi_taf_npcx_manage_callback,
+};
+
+static struct espi_taf_npcx_data espi_taf_npcx_data;
+
+static const struct espi_taf_npcx_config espi_taf_npcx_config = {
+	.base = DT_INST_REG_ADDR(0),
+	.mapped_addr = DT_INST_PROP(0, mapped_addr),
+	.erase_sz = DT_INST_ERASE_SZ_PROP_OR(0),
+	.max_rd_sz = DT_INST_MAX_READ_SZ_PROP_OR(0),
+};
+
+DEVICE_DT_INST_DEFINE(0, &espi_taf_npcx_init, NULL,
+			&espi_taf_npcx_data, &espi_taf_npcx_config,
+			PRE_KERNEL_2, CONFIG_ESPI_INIT_PRIORITY,
+			&espi_taf_npcx_driver_api);
diff --git a/drivers/espi/host_subs_npcx.c b/drivers/espi/host_subs_npcx.c
index 6b179e0a38..b9187f4ecd 100644
--- a/drivers/espi/host_subs_npcx.c
+++ b/drivers/espi/host_subs_npcx.c
@@ -118,6 +118,7 @@
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/pinctrl.h>
 #include <zephyr/kernel.h>
+#include <zephyr/sys/ring_buffer.h>
 #include <soc.h>
 #include "espi_utils.h"
 #include "soc_host.h"
@@ -125,6 +126,7 @@
 #include "soc_miwu.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(host_sub_npcx, LOG_LEVEL_ERR);
 
 struct host_sub_npcx_config {
@@ -147,6 +149,18 @@ struct host_sub_npcx_data {
 	uint8_t plt_rst_asserted; /* current PLT_RST# status */
 	uint8_t espi_rst_asserted; /* current ESPI_RST# status */
 	const struct device *host_bus_dev; /* device for eSPI/LPC bus */
+#ifdef CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	struct ring_buf port80_ring_buf;
+	uint8_t port80_data[CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_RING_BUF_SIZE];
+	struct k_work work;
+#endif
+};
+
+struct npcx_dp80_buf {
+	union {
+		uint16_t offset_code_16;
+		uint8_t offset_code[2];
+	};
 };
 
 static const struct npcx_clk_cfg host_dev_clk_cfg[] =
@@ -192,15 +206,16 @@ struct host_sub_npcx_data host_sub_data;
 #define EC_CFG_IDX_DATA_IO_ADDR_L  0x63
 
 /* Index of Special Logical Device Configuration (Shared Memory Module) */
-#define EC_CFG_IDX_SHM_CFG         0xF1
-#define EC_CFG_IDX_SHM_WND1_ADDR_0 0xF4
-#define EC_CFG_IDX_SHM_WND1_ADDR_1 0xF5
-#define EC_CFG_IDX_SHM_WND1_ADDR_2 0xF6
-#define EC_CFG_IDX_SHM_WND1_ADDR_3 0xF7
-#define EC_CFG_IDX_SHM_WND2_ADDR_0 0xF8
-#define EC_CFG_IDX_SHM_WND2_ADDR_1 0xF9
-#define EC_CFG_IDX_SHM_WND2_ADDR_2 0xFA
-#define EC_CFG_IDX_SHM_WND2_ADDR_3 0xFB
+#define EC_CFG_IDX_SHM_CFG             0xF1
+#define EC_CFG_IDX_SHM_WND1_ADDR_0     0xF4
+#define EC_CFG_IDX_SHM_WND1_ADDR_1     0xF5
+#define EC_CFG_IDX_SHM_WND1_ADDR_2     0xF6
+#define EC_CFG_IDX_SHM_WND1_ADDR_3     0xF7
+#define EC_CFG_IDX_SHM_WND2_ADDR_0     0xF8
+#define EC_CFG_IDX_SHM_WND2_ADDR_1     0xF9
+#define EC_CFG_IDX_SHM_WND2_ADDR_2     0xFA
+#define EC_CFG_IDX_SHM_WND2_ADDR_3     0xFB
+#define EC_CFG_IDX_SHM_DP80_ADDR_RANGE 0xFD
 
 /* Host sub-device local inline functions */
 static inline uint8_t host_shd_mem_wnd_size_sl(uint32_t size)
@@ -472,34 +487,90 @@ static void host_pmch_ibf_isr(const void *arg)
 
 /* Host port80 sub-device local functions */
 #if defined(CONFIG_ESPI_PERIPHERAL_DEBUG_PORT_80)
+#if defined(CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE)
+static void host_port80_work_handler(struct k_work *item)
+{
+	uint32_t code = 0;
+	struct host_sub_npcx_data *data = CONTAINER_OF(item, struct host_sub_npcx_data, work);
+	struct ring_buf *rbuf = &data->port80_ring_buf;
+	struct espi_event evt = {ESPI_BUS_PERIPHERAL_NOTIFICATION,
+				 (ESPI_PERIPHERAL_INDEX_0 << 16) | ESPI_PERIPHERAL_DEBUG_PORT80,
+				 ESPI_PERIPHERAL_NODATA};
+
+	while (!ring_buf_is_empty(rbuf)) {
+		struct npcx_dp80_buf dp80_buf;
+		uint8_t offset;
+
+		ring_buf_get(rbuf, &dp80_buf.offset_code[0], sizeof(dp80_buf.offset_code));
+		offset = dp80_buf.offset_code[1];
+		code |= dp80_buf.offset_code[0] << (8 * offset);
+		if (ring_buf_is_empty(rbuf)) {
+			evt.evt_data = code;
+			espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev,
+					    evt);
+			break;
+		}
+		/* peek the offset of the next byte */
+		ring_buf_peek(rbuf, &dp80_buf.offset_code[0], sizeof(dp80_buf.offset_code));
+		offset = dp80_buf.offset_code[1];
+		/*
+		 * If the peeked next byte's offset is 0, it is the start of the new code.
+		 * Pass the current code to the application layer to handle the Port80 code.
+		 */
+		if (offset == 0) {
+			evt.evt_data = code;
+			espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev,
+					    evt);
+			code = 0;
+		}
+	}
+}
+#endif
+
 static void host_port80_isr(const void *arg)
 {
 	ARG_UNUSED(arg);
 	struct shm_reg *const inst_shm = host_sub_cfg.inst_shm;
-	struct espi_event evt = { ESPI_BUS_PERIPHERAL_NOTIFICATION,
-		(ESPI_PERIPHERAL_INDEX_0 << 16) | ESPI_PERIPHERAL_DEBUG_PORT80,
-		ESPI_PERIPHERAL_NODATA
-	};
 	uint8_t status = inst_shm->DP80STS;
 
-	LOG_DBG("%s: p80 status 0x%02X", __func__, status);
+#ifdef CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE
+	struct ring_buf *rbuf = &host_sub_data.port80_ring_buf;
+
+	while (IS_BIT_SET(inst_shm->DP80STS, NPCX_DP80STS_FNE)) {
+		struct npcx_dp80_buf dp80_buf;
+
+		dp80_buf.offset_code_16 = inst_shm->DP80BUF;
+		ring_buf_put(rbuf, &dp80_buf.offset_code[0], sizeof(dp80_buf.offset_code));
+	}
+	k_work_submit(&host_sub_data.work);
+#else
+	struct espi_event evt = {ESPI_BUS_PERIPHERAL_NOTIFICATION,
+				 (ESPI_PERIPHERAL_INDEX_0 << 16) | ESPI_PERIPHERAL_DEBUG_PORT80,
+				 ESPI_PERIPHERAL_NODATA};
 
 	/* Read out port80 data continuously if FIFO is not empty */
 	while (IS_BIT_SET(inst_shm->DP80STS, NPCX_DP80STS_FNE)) {
 		LOG_DBG("p80: %04x", inst_shm->DP80BUF);
 		evt.evt_data = inst_shm->DP80BUF;
-		espi_send_callbacks(host_sub_data.callbacks,
-				host_sub_data.host_bus_dev, evt);
+		espi_send_callbacks(host_sub_data.callbacks, host_sub_data.host_bus_dev, evt);
 	}
+#endif
+	LOG_DBG("%s: p80 status 0x%02X", __func__, status);
 
 	/* If FIFO is overflow, show error msg */
 	if (IS_BIT_SET(status, NPCX_DP80STS_FOR)) {
 		inst_shm->DP80STS |= BIT(NPCX_DP80STS_FOR);
-		LOG_ERR("Port80 FIFO Overflow!");
+		LOG_DBG("Port80 FIFO Overflow!");
 	}
 
-	/* Clear all pending bit indicates that FIFO was written by host */
-	inst_shm->DP80STS |= BIT(NPCX_DP80STS_FWR);
+	/* If there are pending post codes remains in FIFO after processing and sending previous
+	 * post codes, do not clear the FNE bit. This allows this handler to be called again
+	 * immediately after it exists.
+	 */
+	if (!IS_BIT_SET(inst_shm->DP80STS, NPCX_DP80STS_FNE)) {
+		/* Clear all pending bit indicates that FIFO was written by host */
+		inst_shm->DP80STS |= BIT(NPCX_DP80STS_FWR);
+	}
 }
 
 static void host_port80_init(void)
@@ -785,6 +856,9 @@ int npcx_host_periph_read_request(enum lpc_peripheral_opcode op,
 		case ECUSTOM_HOST_CMD_GET_PARAM_MEMORY:
 			*data = (uint32_t)shm_host_cmd;
 			break;
+		case ECUSTOM_HOST_CMD_GET_PARAM_MEMORY_SIZE:
+			*data = CONFIG_ESPI_NPCX_PERIPHERAL_HOST_CMD_PARAM_SIZE;
+			break;
 		default:
 			return -EINVAL;
 		}
@@ -975,6 +1049,9 @@ void npcx_host_init_subs_host_domain(void)
 		host_c2h_write_io_cfg_reg(EC_CFG_IDX_SHM_WND2_ADDR_0,
 		CONFIG_ESPI_PERIPHERAL_ACPI_SHM_REGION_PORT_NUM & 0xff);
 #endif
+		if (IS_ENABLED(CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE)) {
+			host_c2h_write_io_cfg_reg(EC_CFG_IDX_SHM_DP80_ADDR_RANGE, 0x0f);
+		}
 	/* Enable SHM direct memory access */
 	host_c2h_write_io_cfg_reg(EC_CFG_IDX_CTRL, 0x01);
 	}
@@ -1013,7 +1090,7 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 			return -ENODEV;
 		}
 
-		ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+		ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 				&host_sub_cfg.clks_list[i]);
 		if (ret < 0) {
 			return ret;
@@ -1050,6 +1127,11 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 #endif
 #if defined(CONFIG_ESPI_PERIPHERAL_DEBUG_PORT_80)
 	host_port80_init();
+#if defined(CONFIG_ESPI_NPCX_PERIPHERAL_DEBUG_PORT_80_MULTI_BYTE)
+	ring_buf_init(&host_sub_data.port80_ring_buf, sizeof(host_sub_data.port80_data),
+		      host_sub_data.port80_data);
+	k_work_init(&host_sub_data.work, host_port80_work_handler);
+#endif
 #endif
 #if defined(CONFIG_ESPI_PERIPHERAL_UART)
 	host_uart_init();
@@ -1061,13 +1143,11 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 		    DT_INST_IRQ_BY_NAME(0, kbc_ibf, priority),
 		    host_kbc_ibf_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, kbc_ibf, irq));
 
 	IRQ_CONNECT(DT_INST_IRQ_BY_NAME(0, kbc_obe, irq),
 		    DT_INST_IRQ_BY_NAME(0, kbc_obe, priority),
 		    host_kbc_obe_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, kbc_obe, irq));
 #endif
 
 	/* Host PM channel (Host IO) sub-device interrupt installation */
@@ -1077,7 +1157,6 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 		    DT_INST_IRQ_BY_NAME(0, pmch_ibf, priority),
 		    host_pmch_ibf_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, pmch_ibf, irq));
 #endif
 
 	/* Host Port80 sub-device interrupt installation */
@@ -1086,7 +1165,6 @@ int npcx_host_init_subs_core_domain(const struct device *host_bus_dev,
 		    DT_INST_IRQ_BY_NAME(0, p80_fifo, priority),
 		    host_port80_isr,
 		    NULL, 0);
-	irq_enable(DT_INST_IRQ_BY_NAME(0, p80_fifo, irq));
 #endif
 
 	if (IS_ENABLED(CONFIG_PM)) {
diff --git a/drivers/flash/CMakeLists.txt b/drivers/flash/CMakeLists.txt
index 2e685f7a6e..6e1e9e777b 100644
--- a/drivers/flash/CMakeLists.txt
+++ b/drivers/flash/CMakeLists.txt
@@ -1,7 +1,8 @@
 # SPDX-License-Identifier: Apache-2.0
 
 zephyr_library()
-
+zephyr_library_sources_ifdef(CONFIG_FLASH_NPCX_FIU_QSPI flash_npcx_fiu_qspi.c)
+zephyr_library_sources_ifdef(CONFIG_FLASH_NPCX_FIU_NOR flash_npcx_fiu_nor.c)
 zephyr_library_sources_ifdef(CONFIG_SOC_FLASH_CC13XX_CC26XX soc_flash_cc13xx_cc26xx.c)
 zephyr_library_sources_ifdef(CONFIG_SOC_FLASH_TELINK_B91 soc_flash_b91.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_NOR spi_nor.c)
diff --git a/drivers/flash/Kconfig b/drivers/flash/Kconfig
index 64081737b0..b1d471bf8e 100644
--- a/drivers/flash/Kconfig
+++ b/drivers/flash/Kconfig
@@ -110,4 +110,6 @@ source "drivers/flash/Kconfig.cadence_qspi_nor"
 
 source "drivers/flash/Kconfig.gd32"
 
+source "drivers/flash/Kconfig.npcx_fiu"
+
 endif # FLASH
diff --git a/drivers/flash/Kconfig.npcx_fiu b/drivers/flash/Kconfig.npcx_fiu
new file mode 100644
index 0000000000..6eff013fd7
--- /dev/null
+++ b/drivers/flash/Kconfig.npcx_fiu
@@ -0,0 +1,73 @@
+# NPCX Flash driver configuration options
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config FLASH_NPCX_FIU_QSPI
+	bool "Nuvoton NPCX QSPI Bus Flash driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_FIU_QSPI_ENABLED
+	help
+	  This option enables the QSPI Bus Flash driver for NPCX family of
+	  processors.
+
+config FLASH_NPCX_FIU_NOR
+	bool "Nuvoton NPCX embedded controller (EC) QSPI NOR Flash driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_FIU_NOR_ENABLED
+	depends on FLASH_NPCX_FIU_QSPI
+	select FLASH_HAS_DRIVER_ENABLED
+	select FLASH_HAS_PAGE_LAYOUT
+	select FLASH_JESD216
+	select FLASH_HAS_EX_OP
+	help
+	  This option enables the QSPI NOR Flash driver for NPCX family of
+	  processors.
+
+if FLASH_NPCX_FIU_QSPI
+
+config FLASH_NPCX_FIU_NOR_INIT
+	bool "QSPI NOR flash feature during driver initialization"
+	default y
+	depends on FLASH_NPCX_FIU_NOR
+	help
+	  This option enables the QSPI NOR Flash features such as Quad-Enable,
+	  4-byte address support and so on during driver initialization. Disable
+	  it if QSPI NOR devices are not ready during driver initialization.
+
+config FLASH_NPCX_FIU_DRA_V1
+	bool "Direct Read Access version 1 support"
+	default y if SOC_SERIES_NPCX9
+	help
+	  This option enables DRA V1 support.
+
+config FLASH_NPCX_FIU_DRA_EX_V1
+	bool "Direct Read Access version EX_1 support"
+	default y if SOC_SERIES_NPCK3
+	help
+	  This option enables DRA EX_V1 support.
+
+config FLASH_NPCX_FIU_DRA_V2
+	bool "Direct Read Access version 2 support"
+	default y if SOC_SERIES_NPCX4
+	help
+	  This option enables DRA V1 support.
+
+config FLASH_NPCX_FIU_SUPP_DRA_4B_ADDR
+	bool "4 byte address support in Direct Read Access mode"
+	default y if FLASH_NPCX_FIU_DRA_V1    || \
+		     FLASH_NPCX_FIU_DRA_V2    || \
+		     FLASH_NPCX_FIU_DRA_EX_V1
+	help
+	  Selected if NPCX series supports 4 byte address mode in Direct Read
+	  Access mode.
+
+config FLASH_NPCX_FIU_SUPP_DRA_2_DEV
+	bool "4 byte address support in Direct Read Access mode"
+	default y if FLASH_NPCX_FIU_DRA_V1 || \
+		     FLASH_NPCX_FIU_DRA_V2
+	help
+	  Selected if NPCX series supports two external SPI devices in Direct
+	  Read Access (DRA) on QSPI bus.
+
+endif #FLASH_NPCX_FIU_QSPI
diff --git a/drivers/flash/flash_npcx_fiu_nor.c b/drivers/flash/flash_npcx_fiu_nor.c
new file mode 100644
index 0000000000..e42aa82f89
--- /dev/null
+++ b/drivers/flash/flash_npcx_fiu_nor.c
@@ -0,0 +1,623 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_fiu_nor
+
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/flash.h>
+#include <zephyr/drivers/flash/npcx_flash_api_ex.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h>
+#include <soc.h>
+#ifdef CONFIG_USERSPACE
+#include <zephyr/syscall.h>
+#include <zephyr/internal/syscall_handler.h>
+#endif
+
+#include "flash_npcx_fiu_qspi.h"
+#include "spi_nor.h"
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(flash_npcx_fiu_nor, CONFIG_FLASH_LOG_LEVEL);
+
+#define BLOCK_64K_SIZE KB(64)
+#define BLOCK_4K_SIZE  KB(4)
+
+/* Device config */
+struct flash_npcx_nor_config {
+	/* QSPI bus device for mutex control and bus configuration */
+	const struct device *qspi_bus;
+	/* Mapped address for flash read via direct access */
+	uintptr_t mapped_addr;
+	/* Size of nor device in bytes, from size property */
+	uint32_t flash_size;
+	/* Maximum chip erase time-out in ms */
+	uint32_t max_timeout;
+	/* SPI Nor device configuration on QSPI bus */
+	struct npcx_qspi_cfg qspi_cfg;
+#if defined(CONFIG_FLASH_PAGE_LAYOUT)
+	struct flash_pages_layout layout;
+#endif
+};
+
+/* Device data */
+struct flash_npcx_nor_data {
+	/* Specific control operation for Quad-SPI Nor Flash */
+	uint32_t operation;
+};
+
+static const struct flash_parameters flash_npcx_parameters = {
+	.write_block_size = 1,
+	.erase_value = 0xff,
+};
+
+#define DT_INST_QUAD_EN_PROP_OR(inst)						\
+	COND_CODE_1(DT_INST_NODE_HAS_PROP(inst, quad_enable_requirements),	\
+		    (_CONCAT(JESD216_DW15_QER_VAL_,				\
+		     DT_INST_STRING_TOKEN(inst, quad_enable_requirements))),	\
+		    ((JESD216_DW15_QER_VAL_NONE)))
+
+static inline bool is_within_region(off_t addr, size_t size, off_t region_start,
+				    size_t region_size)
+{
+	return (addr >= region_start &&
+		(addr < (region_start + region_size)) &&
+		((addr + size) <= (region_start + region_size)));
+}
+
+static int flash_npcx_uma_transceive(const struct device *dev, struct npcx_uma_cfg *cfg,
+				     uint32_t flags)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	struct flash_npcx_nor_data *data = dev->data;
+	int ret;
+
+	/* Lock SPI bus and configure it if needed */
+	qspi_npcx_fiu_mutex_lock_configure(config->qspi_bus, &config->qspi_cfg,
+					   data->operation);
+
+	/* Execute UMA transaction */
+	ret = qspi_npcx_fiu_uma_transceive(config->qspi_bus, cfg, flags);
+
+	/* Unlock SPI bus */
+	qspi_npcx_fiu_mutex_unlock(config->qspi_bus);
+
+	return ret;
+}
+
+/* NPCX UMA functions for SPI NOR flash */
+static int flash_npcx_uma_cmd_only(const struct device *dev, uint8_t opcode)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode};
+
+	return flash_npcx_uma_transceive(dev, &cfg, 0); /* opcode only */
+}
+
+static int flash_npcx_uma_cmd_by_addr(const struct device *dev, uint8_t opcode,
+					     uint32_t addr)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode};
+
+	cfg.addr.u32 = sys_cpu_to_be32(addr);
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_ADDR);
+}
+
+static int flash_npcx_uma_read(const struct device *dev, uint8_t opcode,
+			       uint8_t *dst, const size_t size)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode,
+				    .rx_buf = dst,
+				    .rx_count = size};
+
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_READ);
+}
+
+static int flash_npcx_uma_write(const struct device *dev, uint8_t opcode,
+				       uint8_t *src, const size_t size)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode,
+				    .tx_buf = src,
+				    .tx_count = size};
+
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_WRITE);
+}
+
+static int flash_npcx_uma_write_by_addr(const struct device *dev, uint8_t opcode,
+					       uint8_t *src, const size_t size, uint32_t addr)
+{
+	struct npcx_uma_cfg cfg = { .opcode = opcode,
+					.tx_buf = src,
+					.tx_count = size};
+
+	cfg.addr.u32 = sys_cpu_to_be32(addr);
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_WRITE |
+					 NPCX_UMA_ACCESS_ADDR);
+}
+
+/* Local SPI NOR flash functions */
+static int flash_npcx_nor_wait_until_ready(const struct device *dev)
+{
+	int ret;
+	uint8_t reg;
+	const struct flash_npcx_nor_config *config = dev->config;
+	int64_t st = k_uptime_get();
+
+	do {
+		ret = flash_npcx_uma_read(dev, SPI_NOR_CMD_RDSR, &reg, sizeof(reg));
+		if (ret != 0) {
+			return ret;
+		} else if ((reg & SPI_NOR_WIP_BIT) == 0) {
+			return 0;
+		}
+
+	} while ((k_uptime_get() - st) < config->max_timeout);
+
+	return -EBUSY;
+}
+
+static int flash_npcx_nor_read_status_regs(const struct device *dev, uint8_t *sts_reg)
+{
+	int ret = flash_npcx_uma_read(dev, SPI_NOR_CMD_RDSR, sts_reg, 1);
+
+	if (ret != 0) {
+		return ret;
+	}
+	return flash_npcx_uma_read(dev, SPI_NOR_CMD_RDSR2, sts_reg + 1, 1);
+}
+
+static int flash_npcx_nor_write_status_regs(const struct device *dev, uint8_t *sts_reg)
+{
+	int ret;
+
+	ret = flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = flash_npcx_uma_write(dev, SPI_NOR_CMD_WRSR, sts_reg, 2);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return flash_npcx_nor_wait_until_ready(dev);
+}
+
+/* Flash API functions */
+#if defined(CONFIG_FLASH_JESD216_API)
+static int flash_npcx_nor_read_jedec_id(const struct device *dev, uint8_t *id)
+{
+	if (id == NULL) {
+		return -EINVAL;
+	}
+
+	return flash_npcx_uma_read(dev, SPI_NOR_CMD_RDID, id, SPI_NOR_MAX_ID_LEN);
+}
+
+static int flash_npcx_nor_read_sfdp(const struct device *dev, off_t addr,
+				    void *data, size_t size)
+{
+	uint8_t sfdp_addr[4];
+	struct npcx_uma_cfg cfg = { .opcode = JESD216_CMD_READ_SFDP,
+					.tx_buf = sfdp_addr,
+					.tx_count = 4,
+					.rx_buf = data,
+					.rx_count = size};
+
+	if (data == NULL) {
+		return -EINVAL;
+	}
+
+	/* CMD_READ_SFDP needs a 24-bit address followed by a dummy byte */
+	sfdp_addr[0] = (addr >> 16) & 0xff;
+	sfdp_addr[1] = (addr >> 8) & 0xff;
+	sfdp_addr[2] = addr & 0xff;
+	return flash_npcx_uma_transceive(dev, &cfg, NPCX_UMA_ACCESS_WRITE |
+					 NPCX_UMA_ACCESS_READ);
+}
+#endif /* CONFIG_FLASH_JESD216_API */
+
+#if defined(CONFIG_FLASH_PAGE_LAYOUT)
+static void flash_npcx_nor_pages_layout(const struct device *dev,
+					const struct flash_pages_layout **layout,
+					size_t *layout_size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+
+	*layout = &config->layout;
+	*layout_size = 1;
+}
+#endif /* CONFIG_FLASH_PAGE_LAYOUT */
+
+static int flash_npcx_nor_read(const struct device *dev, off_t addr,
+				 void *data, size_t size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	struct flash_npcx_nor_data *dev_data = dev->data;
+
+	/* Out of the region of nor flash device? */
+	if (!is_within_region(addr, size, 0, config->flash_size)) {
+		return -EINVAL;
+	}
+
+	/* Lock/Unlock SPI bus also for DRA mode */
+	qspi_npcx_fiu_mutex_lock_configure(config->qspi_bus, &config->qspi_cfg,
+					   dev_data->operation);
+
+	/* Trigger Direct Read Access (DRA) via reading memory mapped-address */
+	memcpy(data, (void *)(config->mapped_addr + addr), size);
+
+	qspi_npcx_fiu_mutex_unlock(config->qspi_bus);
+
+	return 0;
+}
+
+static int flash_npcx_nor_erase(const struct device *dev, off_t addr, size_t size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	int ret = 0;
+
+	/* Out of the region of nor flash device? */
+	if (!is_within_region(addr, size, 0, config->flash_size)) {
+		LOG_ERR("Addr %ld, size %d are out of range", addr, size);
+		return -EINVAL;
+	}
+
+	/* address must be sector-aligned */
+	if (!SPI_NOR_IS_SECTOR_ALIGNED(addr)) {
+		LOG_ERR("Addr %ld is not sector-aligned", addr);
+		return -EINVAL;
+	}
+
+	/* size must be a multiple of sectors */
+	if ((size % BLOCK_4K_SIZE) != 0) {
+		LOG_ERR("Size %d is not a multiple of sectors", size);
+		return -EINVAL;
+	}
+
+	/* Select erase opcode by size */
+	if (size == config->flash_size) {
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+		/* Send chip erase command */
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_CE);
+		return flash_npcx_nor_wait_until_ready(dev);
+	}
+
+	while (size > 0) {
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+		/* Send page/block erase command with addr */
+		if ((size >= BLOCK_64K_SIZE) && SPI_NOR_IS_64K_ALIGNED(addr)) {
+			flash_npcx_uma_cmd_by_addr(dev, SPI_NOR_CMD_BE, addr);
+			addr += BLOCK_64K_SIZE;
+			size -= BLOCK_64K_SIZE;
+		} else {
+			flash_npcx_uma_cmd_by_addr(dev, SPI_NOR_CMD_SE, addr);
+			addr += BLOCK_4K_SIZE;
+			size -= BLOCK_4K_SIZE;
+		}
+		ret = flash_npcx_nor_wait_until_ready(dev);
+		if (ret != 0) {
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int flash_npcx_nor_write(const struct device *dev, off_t addr,
+				  const void *data, size_t size)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	uint8_t *tx_buf = (uint8_t *)data;
+	int ret = 0;
+	size_t sz_write;
+
+	/* Out of the region of nor flash device? */
+	if (!is_within_region(addr, size, 0, config->flash_size)) {
+		return -EINVAL;
+	}
+
+	/* Don't write more than a page. */
+	if (size > SPI_NOR_PAGE_SIZE) {
+		sz_write = SPI_NOR_PAGE_SIZE;
+	} else {
+		sz_write = size;
+	}
+
+	/*
+	 * Correct the size of first write to not go through page boundary and
+	 * make the address of next write to align to page boundary.
+	 */
+	if (((addr + sz_write - 1U) / SPI_NOR_PAGE_SIZE) != (addr / SPI_NOR_PAGE_SIZE)) {
+		sz_write -= (addr + sz_write) & (SPI_NOR_PAGE_SIZE - 1);
+	}
+
+	while (size > 0) {
+		/* Start to write */
+		flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+		ret = flash_npcx_uma_write_by_addr(dev, SPI_NOR_CMD_PP, tx_buf,
+						   sz_write, addr);
+		if (ret != 0) {
+			break;
+		}
+
+		/* Wait for writing completed */
+		ret = flash_npcx_nor_wait_until_ready(dev);
+		if (ret != 0) {
+			break;
+		}
+
+		size -= sz_write;
+		tx_buf += sz_write;
+		addr += sz_write;
+
+		if (size > SPI_NOR_PAGE_SIZE) {
+			sz_write = SPI_NOR_PAGE_SIZE;
+		} else {
+			sz_write = size;
+		}
+	}
+
+	return ret;
+}
+
+static const struct flash_parameters *
+flash_npcx_nor_get_parameters(const struct device *dev)
+{
+	ARG_UNUSED(dev);
+
+	return &flash_npcx_parameters;
+};
+
+#ifdef CONFIG_FLASH_EX_OP_ENABLED
+static int flash_npcx_nor_ex_exec_uma(const struct device *dev,
+				      const struct npcx_ex_ops_uma_in *op_in,
+				      const struct npcx_ex_ops_uma_out *op_out)
+{
+	int flag = 0;
+	struct npcx_uma_cfg cfg;
+
+	if (op_in == NULL) {
+		return -EINVAL;
+	}
+
+	/* Organize a UMA transaction */
+	cfg.opcode = op_in->opcode;
+	if (op_in->tx_count != 0) {
+		cfg.tx_buf = op_in->tx_buf;
+		cfg.tx_count = op_in->tx_count;
+		flag |= NPCX_UMA_ACCESS_WRITE;
+	}
+
+	if (op_in->addr_count != 0) {
+		cfg.addr.u32 = sys_cpu_to_be32(op_in->addr);
+		flag |= NPCX_UMA_ACCESS_ADDR;
+	}
+
+	if (op_out != NULL && op_in->rx_count != 0) {
+		cfg.rx_buf = op_out->rx_buf;
+		cfg.rx_count = op_in->rx_count;
+		flag |= NPCX_UMA_ACCESS_READ;
+	}
+
+	return flash_npcx_uma_transceive(dev, &cfg, flag);
+}
+
+static int flash_npcx_nor_ex_set_spi_spec(const struct device *dev,
+					  const struct npcx_ex_ops_qspi_oper_in *op_in)
+{
+	struct flash_npcx_nor_data *data = dev->data;
+
+	/* Cannot disable write protection of internal flash */
+	if ((data->operation & NPCX_EX_OP_INT_FLASH_WP) != 0) {
+		if ((op_in->mask & NPCX_EX_OP_INT_FLASH_WP) != 0 && !op_in->enable) {
+			return -EINVAL;
+		}
+	}
+
+	if (op_in->enable) {
+		data->operation |= op_in->mask;
+	} else {
+		data->operation &= ~op_in->mask;
+	}
+
+	return 0;
+}
+
+static int flash_npcx_nor_ex_get_spi_spec(const struct device *dev,
+					  struct npcx_ex_ops_qspi_oper_out *op_out)
+{
+	struct flash_npcx_nor_data *data = dev->data;
+
+	op_out->oper = data->operation;
+	return 0;
+}
+
+static int flash_npcx_nor_ex_op(const struct device *dev, uint16_t code,
+				const uintptr_t in, void *out)
+{
+#ifdef CONFIG_USERSPACE
+	bool syscall_trap = z_syscall_trap();
+#endif
+	int ret;
+
+	switch (code) {
+	case FLASH_NPCX_EX_OP_EXEC_UMA:
+	{
+		struct npcx_ex_ops_uma_in *op_in = (struct npcx_ex_ops_uma_in *)in;
+		struct npcx_ex_ops_uma_out *op_out = (struct npcx_ex_ops_uma_out *)out;
+#ifdef CONFIG_USERSPACE
+		struct npcx_ex_ops_uma_in in_copy;
+		struct npcx_ex_ops_uma_out out_copy;
+
+		if (syscall_trap) {
+			K_OOPS(k_usermode_from_copy(&in_copy, op_in, sizeof(in_copy)));
+			op_in = &in_copy;
+			op_out = &out_copy;
+		}
+#endif
+
+		ret = flash_npcx_nor_ex_exec_uma(dev, op_in, op_out);
+#ifdef CONFIG_USERSPACE
+		if (ret == 0 && syscall_trap) {
+			K_OOPS(k_usermode_to_copy(out, op_out, sizeof(out_copy)));
+		}
+#endif
+		break;
+	}
+	case FLASH_NPCX_EX_OP_SET_QSPI_OPER:
+	{
+		struct npcx_ex_ops_qspi_oper_in *op_in = (struct npcx_ex_ops_qspi_oper_in *)in;
+#ifdef CONFIG_USERSPACE
+		struct npcx_ex_ops_qspi_oper_in in_copy;
+
+		if (syscall_trap) {
+			K_OOPS(k_usermode_from_copy(&in_copy, op_in, sizeof(in_copy)));
+			op_in = &in_copy;
+		}
+#endif
+		ret = flash_npcx_nor_ex_set_spi_spec(dev, op_in);
+		break;
+	}
+	case FLASH_NPCX_EX_OP_GET_QSPI_OPER:
+	{
+		struct npcx_ex_ops_qspi_oper_out *op_out =
+		(struct npcx_ex_ops_qspi_oper_out *)out;
+#ifdef CONFIG_USERSPACE
+		struct npcx_ex_ops_qspi_oper_out out_copy;
+
+		if (syscall_trap) {
+			op_out = &out_copy;
+		}
+#endif
+		ret = flash_npcx_nor_ex_get_spi_spec(dev, op_out);
+#ifdef CONFIG_USERSPACE
+		if (ret == 0 && syscall_trap) {
+			K_OOPS(k_usermode_to_copy(out, op_out, sizeof(out_copy)));
+		}
+#endif
+		break;
+	}
+	default:
+		ret = -ENOTSUP;
+		break;
+	}
+
+	return ret;
+}
+#endif
+
+static const struct flash_driver_api flash_npcx_nor_driver_api = {
+	.read = flash_npcx_nor_read,
+	.write = flash_npcx_nor_write,
+	.erase = flash_npcx_nor_erase,
+	.get_parameters = flash_npcx_nor_get_parameters,
+#if defined(CONFIG_FLASH_PAGE_LAYOUT)
+	.page_layout = flash_npcx_nor_pages_layout,
+#endif
+#if defined(CONFIG_FLASH_JESD216_API)
+	.sfdp_read = flash_npcx_nor_read_sfdp,
+	.read_jedec_id = flash_npcx_nor_read_jedec_id,
+#endif
+#ifdef CONFIG_FLASH_EX_OP_ENABLED
+	.ex_op = flash_npcx_nor_ex_op,
+#endif
+};
+
+static int flash_npcx_nor_init(const struct device *dev)
+{
+	const struct flash_npcx_nor_config *config = dev->config;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_FLASH_NPCX_FIU_NOR_INIT)) {
+		return 0;
+	}
+
+	/* Enable quad access of spi NOR flash */
+	if (config->qspi_cfg.qer_type != JESD216_DW15_QER_NONE) {
+		uint8_t qe_idx, qe_bit, sts_reg[2];
+		/* Read status registers first */
+		ret = flash_npcx_nor_read_status_regs(dev, sts_reg);
+		if (ret != 0) {
+			LOG_ERR("Enable quad access: read reg failed %d!", ret);
+			return ret;
+		}
+		switch (config->qspi_cfg.qer_type) {
+		case JESD216_DW15_QER_S1B6:
+			qe_idx = 1;
+			qe_bit = 6;
+			break;
+		case JESD216_DW15_QER_S2B1v1:
+			__fallthrough;
+		case JESD216_DW15_QER_S2B1v4:
+			__fallthrough;
+		case JESD216_DW15_QER_S2B1v5:
+			qe_idx = 2;
+			qe_bit = 1;
+			break;
+		default:
+			return -ENOTSUP;
+		}
+		/* Set QE bit in status register */
+		sts_reg[qe_idx - 1] |= BIT(qe_bit);
+		ret = flash_npcx_nor_write_status_regs(dev, sts_reg);
+		if (ret != 0) {
+			LOG_ERR("Enable quad access: write reg failed %d!", ret);
+			return ret;
+		}
+	}
+
+	/* Enable 4-byte address of spi NOR flash */
+	if (config->qspi_cfg.enter_4ba != 0) {
+		bool wr_en = (config->qspi_cfg.enter_4ba & 0x02) != 0;
+
+		if (wr_en) {
+			ret = flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_WREN);
+			if (ret != 0) {
+				LOG_ERR("Enable 4byte addr: WREN failed %d!", ret);
+				return ret;
+			}
+		}
+		ret = flash_npcx_uma_cmd_only(dev, SPI_NOR_CMD_4BA);
+		if (ret != 0) {
+			LOG_ERR("Enable 4byte addr: 4BA failed %d!", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+#define NPCX_FLASH_NOR_INIT(n)							\
+BUILD_ASSERT(DT_INST_QUAD_EN_PROP_OR(n) == JESD216_DW15_QER_NONE ||		\
+	     DT_INST_STRING_TOKEN(n, rd_mode) == NPCX_RD_MODE_FAST_DUAL,	\
+	     "Fast Dual IO read must be selected in Quad mode");		\
+PINCTRL_DT_INST_DEFINE(n);							\
+static const struct flash_npcx_nor_config flash_npcx_nor_config_##n = {		\
+	.qspi_bus = DEVICE_DT_GET(DT_PARENT(DT_DRV_INST(n))),			\
+	.mapped_addr = DT_INST_PROP(n, mapped_addr),				\
+	.flash_size = DT_INST_PROP(n, size) / 8,				\
+	.max_timeout = DT_INST_PROP(n, max_timeout),				\
+	.qspi_cfg = {								\
+		.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),			\
+		.flags = DT_INST_PROP(n, qspi_flags),				\
+		.enter_4ba = DT_INST_PROP_OR(n, enter_4byte_addr, 0),		\
+		.qer_type = DT_INST_QUAD_EN_PROP_OR(n),				\
+		.rd_mode = DT_INST_STRING_TOKEN(n, rd_mode),			\
+	},									\
+	IF_ENABLED(CONFIG_FLASH_PAGE_LAYOUT, (					\
+		.layout = {							\
+			.pages_count = DT_INST_PROP(n, size) /			\
+				      (8 * SPI_NOR_PAGE_SIZE),			\
+			.pages_size  = SPI_NOR_PAGE_SIZE,			\
+		},))								\
+};										\
+static struct flash_npcx_nor_data flash_npcx_nor_data_##n;			\
+DEVICE_DT_INST_DEFINE(n, flash_npcx_nor_init, NULL,				\
+		      &flash_npcx_nor_data_##n, &flash_npcx_nor_config_##n,	\
+		      POST_KERNEL, CONFIG_FLASH_INIT_PRIORITY,			\
+		      &flash_npcx_nor_driver_api);
+
+DT_INST_FOREACH_STATUS_OKAY(NPCX_FLASH_NOR_INIT)
diff --git a/drivers/flash/flash_npcx_fiu_qspi.c b/drivers/flash/flash_npcx_fiu_qspi.c
new file mode 100644
index 0000000000..f1057889d6
--- /dev/null
+++ b/drivers/flash/flash_npcx_fiu_qspi.c
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT nuvoton_npcx_fiu_qspi
+
+#include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/flash/npcx_flash_api_ex.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/drivers/spi.h>
+#include <zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h>
+#include <soc.h>
+
+#include "flash_npcx_fiu_qspi.h"
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(npcx_fiu_qspi, LOG_LEVEL_ERR);
+
+/* Driver convenience defines */
+#define HAL_INSTANCE(dev) \
+	((struct fiu_reg *)((const struct npcx_qspi_fiu_config *)(dev)->config)->base)
+
+/* Device config */
+struct npcx_qspi_fiu_config {
+	/* Flash interface unit base address */
+	uintptr_t base;
+	/* Clock configuration */
+	struct npcx_clk_cfg clk_cfg;
+	/* Enable 2 external SPI devices for direct read on QSPI bus */
+	bool en_direct_access_2dev;
+};
+
+/* Device data */
+struct npcx_qspi_fiu_data {
+	/* mutex of qspi bus controller */
+	struct k_sem lock_sem;
+	/* Current device configuration on QSPI bus */
+	const struct npcx_qspi_cfg *cur_cfg;
+	/* Current Software controlled Chip-Select number */
+	int sw_cs;
+	/* Current QSPI bus operation */
+	uint32_t operation;
+};
+
+/* NPCX SPI User Mode Access (UMA) functions */
+static inline void qspi_npcx_uma_cs_level(const struct device *dev, uint8_t sw_cs, bool level)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Automatic block access support during a UMA trasaction in NPCK series */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if (level == 0) {
+		inst->FIU_MSR_IE_CFG |= BIT(NPCX_MSR_IE_CFG_UMA_BLOCK);
+	}
+#endif
+
+	/* Set chip select to high/low level */
+	if (level) {
+		inst->UMA_ECTS |= BIT(sw_cs);
+	} else {
+		inst->UMA_ECTS &= ~BIT(sw_cs);
+	}
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if (level == 1) {
+		inst->FIU_MSR_IE_CFG &= ~BIT(NPCX_MSR_IE_CFG_UMA_BLOCK);
+	}
+#endif
+}
+
+static inline void npcx_uma_start(const struct device *dev, uint8_t code)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	code &= ~BIT(NPCX_UMA_CTS_DEV_NUM);
+	inst->UMA_CTS = (inst->UMA_CTS & BIT(NPCX_UMA_CTS_DEV_NUM)) | code;
+#else
+	inst->UMA_CTS = code;
+#endif
+}
+
+static inline void qspi_npcx_uma_write_byte(const struct device *dev, uint8_t data)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Set data to UMA_CODE and trigger UMA */
+	inst->UMA_CODE = data;
+	npcx_uma_start(dev, UMA_CODE_CMD_WR_ONLY);
+	/* EXEC_DONE will be zero automatically if a UMA transaction is completed. */
+	while (IS_BIT_SET(inst->UMA_CTS, NPCX_UMA_CTS_EXEC_DONE)) {
+		continue;
+	}
+}
+
+static inline void qspi_npcx_uma_read_byte(const struct device *dev, uint8_t *data)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Trigger UMA and Get data from DB0 later */
+	npcx_uma_start(dev, UMA_CODE_RD_BYTE(1));
+	while (IS_BIT_SET(inst->UMA_CTS, NPCX_UMA_CTS_EXEC_DONE)) {
+		continue;
+	}
+
+	*data = inst->UMA_DB0;
+}
+
+/* NPCX SPI Direct Read Access (DRA)/User Mode Access (UMA) configuration functions */
+static inline void qspi_npcx_config_uma_mode(const struct device *dev,
+					     const struct npcx_qspi_cfg *qspi_cfg)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if ((qspi_cfg->flags & NPCX_QSPI_SHD_FLASH_SL) != 0) {
+		inst->UMA_CTS |= BIT(NPCX_UMA_CTS_DEV_NUM);
+		inst->UMA_ECTS &= ~BIT(NPCX_UMA_ECTS_UMA_DEV_BKP);
+	} else if ((qspi_cfg->flags & NPCX_QSPI_PVT_FLASH_SL) != 0) {
+		inst->UMA_CTS &= ~BIT(NPCX_UMA_CTS_DEV_NUM);
+		inst->UMA_ECTS &= ~BIT(NPCX_UMA_ECTS_UMA_DEV_BKP);
+	} else if ((qspi_cfg->flags & NPCX_QSPI_BKP_FLASH_SL) != 0) {
+		inst->UMA_ECTS |= BIT(NPCX_UMA_ECTS_UMA_DEV_BKP);
+	}
+#else
+	if ((qspi_cfg->flags & NPCX_QSPI_SEC_FLASH_SL) != 0) {
+		inst->UMA_ECTS |= BIT(NPCX_UMA_ECTS_SEC_CS);
+	} else {
+		inst->UMA_ECTS &= ~BIT(NPCX_UMA_ECTS_SEC_CS);
+	}
+#endif /* CONFIG_SOC_SERIES_NPCK3 */
+}
+
+static inline void qspi_npcx_config_dra_4byte_mode(const struct device *dev,
+						   const struct npcx_qspi_cfg *qspi_cfg)
+{
+#if defined(CONFIG_FLASH_NPCX_FIU_SUPP_DRA_4B_ADDR)
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+#if defined(CONFIG_FLASH_NPCX_FIU_DRA_V1)
+	if (qspi_cfg->enter_4ba != 0) {
+		if ((qspi_cfg->flags & NPCX_QSPI_SEC_FLASH_SL) != 0) {
+			inst->SPI1_DEV |= BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS11);
+		} else {
+			inst->SPI1_DEV |= BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS10);
+		}
+	} else {
+		inst->SPI1_DEV &= ~(BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS11) |
+				    BIT(NPCX_SPI1_DEV_FOUR_BADDR_CS10));
+	}
+#elif defined(CONFIG_FLASH_NPCX_FIU_DRA_V2)
+	if (qspi_cfg->enter_4ba != 0) {
+		SET_FIELD(inst->SPI_DEV, NPCX_SPI_DEV_NADDRB, NPCX_DEV_NUM_ADDR_4BYTE);
+	}
+#elif defined(CONFIG_FLASH_NPCX_FIU_DRA_EX_V1)
+	if (qspi_cfg->enter_4ba != 0) {
+		if ((qspi_cfg->flags & NPCX_QSPI_SHD_FLASH_SL) != 0) {
+			inst->FIU_4B_EN |= BIT(NPCX_MSR_FIU_4B_EN_SHD_4B);
+		} else if ((qspi_cfg->flags & NPCX_QSPI_PVT_FLASH_SL) != 0) {
+			inst->FIU_4B_EN |= BIT(NPCX_MSR_FIU_4B_EN_PVT_4B);
+		} else if ((qspi_cfg->flags & NPCX_QSPI_BKP_FLASH_SL) != 0) {
+			inst->FIU_4B_EN |= BIT(NPCX_MSR_FIU_4B_EN_BKP_4B);
+		}
+	}
+#endif
+#endif /* CONFIG_FLASH_NPCX_FIU_SUPP_DRA_4B_ADDR */
+}
+
+static inline void qspi_npcx_config_dra_mode(const struct device *dev,
+					     const struct npcx_qspi_cfg *qspi_cfg)
+{
+	struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+	/* Select SPI device number for DRA mode in npcx4 series */
+	if (IS_ENABLED(CONFIG_FLASH_NPCX_FIU_DRA_V2)) {
+		int spi_dev_num = (qspi_cfg->flags & NPCX_QSPI_SEC_FLASH_SL) != 0 ? 1 : 0;
+
+		SET_FIELD(inst->BURST_CFG, NPCX_BURST_CFG_SPI_DEV_SEL, spi_dev_num);
+	}
+
+	/* Enable quad mode of Direct Read Mode if needed */
+	if (qspi_cfg->qer_type != JESD216_DW15_QER_NONE) {
+		inst->RESP_CFG |= BIT(NPCX_RESP_CFG_QUAD_EN);
+	} else {
+		inst->RESP_CFG &= ~BIT(NPCX_RESP_CFG_QUAD_EN);
+	}
+
+	/* Selects the SPI read access type of Direct Read Access mode */
+	SET_FIELD(inst->SPI_FL_CFG, NPCX_SPI_FL_CFG_RD_MODE, qspi_cfg->rd_mode);
+
+	/* Enable/Disable 4 byte address mode for Direct Read Access (DRA) */
+	qspi_npcx_config_dra_4byte_mode(dev, qspi_cfg);
+}
+
+static inline void qspi_npcx_fiu_set_operation(const struct device *dev, uint32_t operation)
+{
+	if ((operation & NPCX_EX_OP_INT_FLASH_WP) != 0) {
+		npcx_pinctrl_flash_write_protect_set();
+	}
+}
+
+/* NPCX specific QSPI-FIU controller functions */
+int qspi_npcx_fiu_uma_transceive(const struct device *dev, struct npcx_uma_cfg *cfg,
+				     uint32_t flags)
+{
+	struct npcx_qspi_fiu_data *const data = dev->data;
+
+	/* UMA transaction is permitted? */
+	if ((data->operation & NPCX_EX_OP_LOCK_UMA) != 0) {
+		return -EPERM;
+	}
+
+	/* Assert chip select */
+	qspi_npcx_uma_cs_level(dev, data->sw_cs, false);
+
+	/* Transmit op-code first */
+	qspi_npcx_uma_write_byte(dev, cfg->opcode);
+
+	if ((flags & NPCX_UMA_ACCESS_ADDR) != 0) {
+		/* 3-byte or 4-byte address? */
+		const int addr_start = (data->cur_cfg->enter_4ba != 0) ? 0 : 1;
+
+		for (size_t i = addr_start; i < 4; i++) {
+			LOG_DBG("addr %d, %02x", i, cfg->addr.u8[i]);
+			qspi_npcx_uma_write_byte(dev, cfg->addr.u8[i]);
+		}
+	}
+
+	if ((flags & NPCX_UMA_ACCESS_WRITE) != 0) {
+		if (cfg->tx_buf == NULL) {
+			return -EINVAL;
+		}
+		for (size_t i = 0; i < cfg->tx_count; i++) {
+			qspi_npcx_uma_write_byte(dev, cfg->tx_buf[i]);
+		}
+	}
+
+	if ((flags & NPCX_UMA_ACCESS_READ) != 0) {
+		if (cfg->rx_buf == NULL) {
+			return -EINVAL;
+		}
+		for (size_t i = 0; i < cfg->rx_count; i++) {
+			qspi_npcx_uma_read_byte(dev, cfg->rx_buf + i);
+		}
+	}
+
+	/* De-assert chip select */
+	qspi_npcx_uma_cs_level(dev, data->sw_cs, true);
+
+	return 0;
+}
+
+void qspi_npcx_fiu_mutex_lock_configure(const struct device *dev,
+					const struct npcx_qspi_cfg *cfg,
+					const uint32_t operation)
+{
+	struct npcx_qspi_fiu_data *const data = dev->data;
+
+	k_sem_take(&data->lock_sem, K_FOREVER);
+
+	/* If the current device is different from previous one, configure it */
+	if (data->cur_cfg != cfg) {
+		data->cur_cfg = cfg;
+
+		/* Apply pin-muxing and tri-state */
+		pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
+
+		/* Configure User Mode Access (UMA) settings */
+		qspi_npcx_config_uma_mode(dev, cfg);
+
+		/* Configure for Direct Read Access (DRA) settings */
+		qspi_npcx_config_dra_mode(dev, cfg);
+
+		/* Save SW CS bit used in UMA mode */
+		data->sw_cs = find_lsb_set(cfg->flags & NPCX_QSPI_SW_CS_MASK) - 1;
+	}
+
+	/* Set QSPI bus operation */
+	if (data->operation != operation) {
+		qspi_npcx_fiu_set_operation(dev, operation);
+		data->operation = operation;
+	}
+}
+
+void qspi_npcx_fiu_mutex_unlock(const struct device *dev)
+{
+	struct npcx_qspi_fiu_data *const data = dev->data;
+
+	k_sem_give(&data->lock_sem);
+}
+
+static int qspi_npcx_fiu_init(const struct device *dev)
+{
+	const struct npcx_qspi_fiu_config *const config = dev->config;
+	struct npcx_qspi_fiu_data *const data = dev->data;
+	const struct device *const clk_dev = DEVICE_DT_GET(NPCX_CLK_CTRL_NODE);
+	int ret;
+
+	if (!device_is_ready(clk_dev)) {
+		LOG_ERR("%s device not ready", clk_dev->name);
+		return -ENODEV;
+	}
+
+	/* Turn on device clock first and get source clock freq. */
+	ret = clock_control_on(clk_dev,
+			       (clock_control_subsys_t)&config->clk_cfg);
+	if (ret < 0) {
+		LOG_ERR("Turn on FIU clock fail %d", ret);
+		return ret;
+	}
+
+	/* initialize mutex for qspi controller */
+	k_sem_init(&data->lock_sem, 1, 1);
+
+	/* Enable direct access for 2 external SPI devices */
+	if (config->en_direct_access_2dev) {
+#if defined(CONFIG_FLASH_NPCX_FIU_SUPP_DRA_2_DEV)
+		struct fiu_reg *const inst = HAL_INSTANCE(dev);
+
+		inst->FIU_EXT_CFG |= BIT(NPCX_FIU_EXT_CFG_SPI1_2DEV);
+#endif
+	}
+
+	return 0;
+}
+
+#define NPCX_SPI_FIU_INIT(n)							\
+static const struct npcx_qspi_fiu_config npcx_qspi_fiu_config_##n = {		\
+	.base = DT_INST_REG_ADDR(n),						\
+	.clk_cfg = NPCX_DT_CLK_CFG_ITEM(n),					\
+	.en_direct_access_2dev = DT_INST_PROP(n, en_direct_access_2dev),	\
+};										\
+static struct npcx_qspi_fiu_data npcx_qspi_fiu_data_##n;			\
+DEVICE_DT_INST_DEFINE(n, qspi_npcx_fiu_init, NULL,				\
+		      &npcx_qspi_fiu_data_##n, &npcx_qspi_fiu_config_##n,	\
+		      PRE_KERNEL_1, CONFIG_FLASH_INIT_PRIORITY, NULL);
+
+DT_INST_FOREACH_STATUS_OKAY(NPCX_SPI_FIU_INIT)
diff --git a/drivers/flash/flash_npcx_fiu_qspi.h b/drivers/flash/flash_npcx_fiu_qspi.h
new file mode 100644
index 0000000000..1136684d45
--- /dev/null
+++ b/drivers/flash/flash_npcx_fiu_qspi.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_DRIVERS_FLASH_NPCX_FIU_QSPI_H_
+#define ZEPHYR_DRIVERS_FLASH_NPCX_FIU_QSPI_H_
+
+#include <zephyr/device.h>
+#include "jesd216.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* UMA operation flags */
+#define NPCX_UMA_ACCESS_WRITE BIT(0)
+#define NPCX_UMA_ACCESS_READ  BIT(1)
+#define NPCX_UMA_ACCESS_ADDR  BIT(2)
+
+/* Valid value of Dn_NADDRB that sets the number of address bytes in a transaction */
+#define NPCX_DEV_NUM_ADDR_1BYTE 1
+#define NPCX_DEV_NUM_ADDR_2BYTE 2
+#define NPCX_DEV_NUM_ADDR_3BYTE 3
+#define NPCX_DEV_NUM_ADDR_4BYTE 4
+
+/* UMA operation configuration for a SPI device */
+struct npcx_uma_cfg {
+	uint8_t opcode;
+	uint8_t *tx_buf;
+	size_t  tx_count;
+	uint8_t *rx_buf;
+	size_t rx_count;
+	union {
+		uint32_t u32;
+		uint8_t u8[4];
+	} addr;
+};
+
+/* QSPI bus configuration for a SPI device */
+struct npcx_qspi_cfg {
+	/* Type of Quad Enable bit in status register */
+	enum jesd216_dw15_qer_type qer_type;
+	/* Pinctrl for QSPI bus */
+	const struct pinctrl_dev_config *pcfg;
+	/* Enter four bytes address mode value */
+	uint8_t enter_4ba;
+	/* SPI read access type of Direct Read Access mode */
+	uint8_t rd_mode;
+	/* Configurations for the Quad-SPI peripherals */
+	int flags;
+};
+
+/**
+ * @brief Execute UMA transactions on qspi bus
+ *
+ * @param dev Pointer to the device structure for qspi bus controller instance.
+ * @param cfg Pointer to the configuration of UMA transactions.
+ * @param flags Flags to be used during transactions.
+ * @retval 0 on success, -EPERM if an UMA transaction is not permitted.
+ */
+int qspi_npcx_fiu_uma_transceive(const struct device *dev, struct npcx_uma_cfg *cfg,
+				 uint32_t flags);
+
+/**
+ * @brief Lock the mutex of npcx qspi bus controller and apply its configuration
+ *
+ * @param dev Pointer to the device structure for qspi bus controller instance.
+ * @param cfg Pointer to the configuration for the device on qspi bus.
+ * @param operation Qspi bus operation for the device.
+ */
+void qspi_npcx_fiu_mutex_lock_configure(const struct device *dev,
+					const struct npcx_qspi_cfg *cfg,
+					const uint32_t operation);
+
+/**
+ * @brief Unlock the mutex of npcx qspi bus controller.
+ *
+ * @param dev Pointer to the device structure for qspi bus controller instance.
+ */
+void qspi_npcx_fiu_mutex_unlock(const struct device *dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZEPHYR_DRIVERS_FLASH_NPCX_FIU_QSPI_H_ */
diff --git a/drivers/gpio/gpio_npcx.c b/drivers/gpio/gpio_npcx.c
index 201c44b289..dc09753f34 100644
--- a/drivers/gpio/gpio_npcx.c
+++ b/drivers/gpio/gpio_npcx.c
@@ -9,6 +9,7 @@
 #include <zephyr/kernel.h>
 #include <zephyr/device.h>
 #include <zephyr/drivers/gpio.h>
+#include <zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h>
 #include <soc.h>
 
 #include "gpio_utils.h"
@@ -127,11 +128,13 @@ static int gpio_npcx_config(const struct device *dev,
 
 	/* Does this IO pad support low-voltage input (1.8V) detection? */
 	if (lvol->ctrl != NPCX_DT_LVOL_CTRL_NONE) {
+		gpio_flags_t volt = flags & NPCX_GPIO_VOLTAGE_MASK;
+
 		/*
 		 * If this IO pad is configured for low-voltage input detection,
 		 * the related drive type must select to open-drain also.
 		 */
-		if ((flags & GPIO_VOLTAGE_1P8) != 0) {
+		if (volt == NPCX_GPIO_VOLTAGE_1P8) {
 			flags |= GPIO_OPEN_DRAIN;
 			npcx_lvol_set_detect_level(lvol->ctrl, lvol->bit, true);
 		} else {
@@ -215,7 +218,7 @@ static int gpio_npcx_pin_get_config(const struct device *port, gpio_pin_t pin,
 	/* Enable low-voltage detection? */
 	if (lvol->ctrl != NPCX_DT_LVOL_CTRL_NONE &&
 		npcx_lvol_get_detect_level(lvol->ctrl, lvol->bit)) {
-		flags |= GPIO_VOLTAGE_1P8;
+		flags |= NPCX_GPIO_VOLTAGE_1P8;
 	};
 
 	*out_flags = flags;
@@ -296,6 +299,15 @@ static int gpio_npcx_pin_interrupt_configure(const struct device *dev,
 			config->port, pin, config->wui_maps[pin].table,
 			config->wui_maps[pin].group,
 			config->wui_maps[pin].bit);
+#ifdef CONFIG_GPIO_ENABLE_DISABLE_INTERRUPT
+	if (mode == GPIO_INT_MODE_DISABLE_ONLY) {
+		npcx_miwu_irq_disable(&config->wui_maps[pin]);
+		return 0;
+	} else if (mode == GPIO_INT_MODE_ENABLE_ONLY) {
+		npcx_miwu_irq_enable(&config->wui_maps[pin]);
+		return 0;
+	}
+#endif /* CONFIG_GPIO_ENABLE_DISABLE_INTERRUPT */
 
 	/* Disable irq of wake-up input io-pads before configuring them */
 	npcx_miwu_irq_disable(&config->wui_maps[pin]);
@@ -344,7 +356,7 @@ static int gpio_npcx_manage_callback(const struct device *dev,
 				      struct gpio_callback *callback, bool set)
 {
 	const struct gpio_npcx_config *const config = dev->config;
-	struct miwu_io_callback *miwu_cb = (struct miwu_io_callback *)callback;
+	struct miwu_callback *miwu_cb = (struct miwu_callback *)callback;
 	int pin = find_lsb_set(callback->pin_mask) - 1;
 
 	/* pin_mask should not be zero */
@@ -364,7 +376,7 @@ static int gpio_npcx_manage_callback(const struct device *dev,
 			config->port);
 
 	/* Insert or remove a IO callback which being called in MIWU ISRs */
-	return npcx_miwu_manage_gpio_callback(miwu_cb, set);
+	return npcx_miwu_manage_callback(miwu_cb, set);
 }
 
 /* GPIO driver registration */
diff --git a/drivers/i2c/CMakeLists.txt b/drivers/i2c/CMakeLists.txt
index d6910e7c06..c81b150bfc 100644
--- a/drivers/i2c/CMakeLists.txt
+++ b/drivers/i2c/CMakeLists.txt
@@ -31,7 +31,7 @@ zephyr_library_sources_ifdef(CONFIG_I2C_GECKO		i2c_gecko.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_RV32M1_LPI2C	i2c_rv32m1_lpi2c.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_SAM0		i2c_sam0.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_LITEX		i2c_litex.c)
-zephyr_library_sources_ifdef(CONFIG_I2C_NPCX		i2c_npcx_controller.c)
+zephyr_library_sources_ifdef(CONFIG_I2C_NPCX_CTRL	i2c_npcx_controller.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_NPCX		i2c_npcx_port.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_DW		i2c_dw.c)
 zephyr_library_sources_ifdef(CONFIG_I2C_RCAR		i2c_rcar.c)
diff --git a/drivers/i2c/Kconfig.npcx b/drivers/i2c/Kconfig.npcx
index 2422b24c5b..332871f54c 100644
--- a/drivers/i2c/Kconfig.npcx
+++ b/drivers/i2c/Kconfig.npcx
@@ -3,7 +3,7 @@
 # Copyright (c) 2020 Nuvoton Technology Corporation.
 # SPDX-License-Identifier: Apache-2.0
 
-config I2C_NPCX
+menuconfig I2C_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) I2C driver"
 	default y
 	depends on DT_HAS_NUVOTON_NPCX_I2C_PORT_ENABLED
@@ -11,3 +11,30 @@ config I2C_NPCX
 	  This option enables the I2C driver for NPCX family of
 	  processors.
 	  Say y if you wish to use I2C modules on NPCX MCU.
+
+config I2C_NPCX_PORT_INIT_PRIORITY
+	int "NPCX I2C port init priority"
+	default 51
+	depends on I2C_NPCX
+	help
+	  Initialization priority for the I2C port on an NPCX device, must be
+	  set to a lower priority than the controller one (I2C_INIT_PRIORITY).
+
+config I2C_NPCX_CTRL
+	bool "Nuvoton NPCX embedded controller (EC) I2C controller driver"
+	default y
+	depends on DT_HAS_NUVOTON_NPCX_I2C_PORT_ENABLED
+	help
+	  This option enables the I2C controller driver for NPCX family of
+	  processors.
+	  Say y if you wish to use I2C modules on NPCX MCU.
+
+if I2C_NPCX_CTRL
+config I2C_NPCX_DMA_DRIVEN
+	bool "Nuvoton NPCX embedded controller (EC) I2C controller driver with DMA support"
+	default y if SOC_SERIES_NPCK3
+	help
+	  This option enables the I2C controller driver which support DMA for NPCX family of
+	  processors.
+	  Say y if you wish to use I2C modules on NPCX MCU.
+endif #I2C_NPCX_DMA_DRIVEN
\ No newline at end of file
diff --git a/drivers/i2c/i2c_npcx_controller.c b/drivers/i2c/i2c_npcx_controller.c
index 748bb7a92f..07b6987d90 100644
--- a/drivers/i2c/i2c_npcx_controller.c
+++ b/drivers/i2c/i2c_npcx_controller.c
@@ -21,7 +21,7 @@
  *                              +<----------------+<----------------------+
  *                              |       No        |                       | Yes
  *    +------+   +------------+ |  +------- ----+ |    +------- -------+  |
- * +->| IDLE |-->| WAIT_START |--->| WRITE_FIFO |-+--->| WRITE_SUSPEND |--+
+ * +->| IDLE |-->| WAIT_START |--->| WRITE_DATA |-+--->| WRITE_SUSPEND |--+
  * |  +------+   +------------+    +------------+  Yes +---------------+  |
  * |      Issue START    START completed                                  | No
  * |                                            +-----------+             |
@@ -35,7 +35,7 @@
  *                              +<-----------------+<---------------------+
  *                              |       No         |                      | Yes
  *    +------+   +------------+ |  +------- ---+   |    +------- ------+  |
- * +->| IDLE |-->| WAIT_START |--->| READ_FIFO |---+--->| READ_SUSPEND |--+
+ * +->| IDLE |-->| WAIT_START |--->| READ_DATA |---+--->| READ_SUSPEND |--+
  * |  +------+   +------------+    +------------+   Yes +--------------+  |
  * |     Issue START     START completed                                  | No
  * |                                          +-----------+               |
@@ -49,7 +49,7 @@
  *                              +<----------------+<----------------------+
  *                              |       No        |                       | Yes
  *    +------+   +------------+ |  +------- ----+ |    +------- -------+  |
- * +->| IDLE |-->| WAIT_START |--->| WRITE_FIFO |-+--->| WRITE_SUSPEND |--+
+ * +->| IDLE |-->| WAIT_START |--->| WRITE_DATA |-+--->| WRITE_SUSPEND |--+
  * |  +------+   +------------+    +------------+  Yes +---------------+  |
  * |     Issue START     START completed                                  | No
  * |      +---------------------------------------------------------------+
@@ -58,7 +58,7 @@
  * |      |                   +<-----------------+<-----------------------+
  * |      |                   |       No         |                        | Yes
  * |      |  +--------------+ |  +------- ---+   |    +------- ------+    |
- * |      +--| WAIT_RESTART |--->| READ_FIFO |---+--->| READ_SUSPEND |----+
+ * |      +--| WAIT_RESTART |--->| READ_DATA |---+--->| READ_SUSPEND |----+
  * |         +--------------+    +-----------+    Yes +--------------+    |
  * |  Issue RESTART      RESTART completed                                | No
  * |                                           +-----------+              |
@@ -70,9 +70,12 @@
 #include <assert.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/i2c.h>
+#include <zephyr/kernel.h>
+#include <zephyr/sys/atomic.h>
 #include <soc.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(i2c_npcx, LOG_LEVEL_ERR);
 
 /* I2C controller mode */
@@ -88,11 +91,11 @@ LOG_MODULE_REGISTER(i2c_npcx, LOG_LEVEL_ERR);
 /* Default maximum time we allow for an I2C transfer (unit:ms) */
 #define I2C_TRANS_TIMEOUT K_MSEC(100)
 
-/*
- * NPCX I2C module that supports FIFO mode has 32 bytes Tx FIFO and
- * 32 bytes Rx FIFO.
- */
-#define NPCX_I2C_FIFO_MAX_SIZE 32
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+#define NPCX_I2C_DMA_MAX_SIZE 65535 /* Support 65535 bytes during DMA transaction */
+#else
+#define NPCX_I2C_FIFO_MAX_SIZE 32 /* 32 bytes Tx FIFO and 32 bytes Rx FIFO. */
+#endif
 
 /* Valid bit fields in SMBST register */
 #define NPCX_VALID_SMBST_MASK ~(BIT(NPCX_SMBST_XMIT) | BIT(NPCX_SMBST_MASTER))
@@ -109,6 +112,11 @@ enum npcx_i2c_freq {
 	NPCX_I2C_BUS_SPEED_1MHZ,
 };
 
+enum npcx_i2c_flag {
+	NPCX_I2C_FLAG_TARGET,
+	NPCX_I2C_FLAG_COUNT,
+};
+
 /*
  * Internal SMBus Interface driver states values, which reflect events
  * which occurred on the bus
@@ -117,9 +125,9 @@ enum npcx_i2c_oper_state {
 	NPCX_I2C_IDLE,
 	NPCX_I2C_WAIT_START,
 	NPCX_I2C_WAIT_RESTART,
-	NPCX_I2C_WRITE_FIFO,
+	NPCX_I2C_WRITE_DATA,
 	NPCX_I2C_WRITE_SUSPEND,
-	NPCX_I2C_READ_FIFO,
+	NPCX_I2C_READ_DATA,
 	NPCX_I2C_READ_SUSPEND,
 	NPCX_I2C_WAIT_STOP,
 	NPCX_I2C_ERROR_RECOVERY,
@@ -153,15 +161,16 @@ struct i2c_ctrl_data {
 	uint8_t port; /* current port used the controller */
 	bool is_configured; /* is port configured? */
 	const struct npcx_i2c_timing_cfg *ptr_speed_confs;
+#ifdef CONFIG_I2C_TARGET
+	struct i2c_target_config *target_cfg;
+	atomic_t flags;
+#endif
 };
 
 /* Driver convenience defines */
 #define HAL_I2C_INSTANCE(dev)                                                                      \
 	((struct smb_reg *)((const struct i2c_ctrl_config *)(dev)->config)->base)
 
-#define HAL_I2C_FIFO_INSTANCE(dev)                                                                 \
-	((struct smb_fifo_reg *)((const struct i2c_ctrl_config *)(dev)->config)->base)
-
 /* Recommended I2C timing values are based on 15 MHz */
 static const struct npcx_i2c_timing_cfg npcx_15m_speed_confs[] = {
 	[NPCX_I2C_BUS_SPEED_100KHZ] = {.HLDT = 15, .k1 = 76, .k2 = 0},
@@ -175,177 +184,70 @@ static const struct npcx_i2c_timing_cfg npcx_20m_speed_confs[] = {
 	[NPCX_I2C_BUS_SPEED_1MHZ] = {.HLDT  = 7, .k1 = 16, .k2 = 10},
 };
 
+/* Forward declarations */
+void i2c_ctrl_fifo_hold_bus(const struct device *dev, int stall);
+
 /* I2C controller inline functions access shared registers */
 static inline void i2c_ctrl_start(const struct device *dev)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	inst_fifo->SMBCTL1 |= BIT(NPCX_SMBCTL1_START);
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_START);
 }
 
 static inline void i2c_ctrl_stop(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	inst_fifo->SMBCTL1 |= BIT(NPCX_SMBCTL1_STOP);
-}
-
-static inline int i2c_ctrl_bus_busy(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return IS_BIT_SET(inst_fifo->SMBCST, NPCX_SMBCST_BB);
-}
-
-static inline void i2c_ctrl_bank_sel(const struct device *dev, int bank)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	if (bank) {
-		inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_BNK_SEL);
-	} else {
-		inst->SMBCTL3 &= ~BIT(NPCX_SMBCTL3_BNK_SEL);
-	}
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_STOP);
 }
 
-static inline void i2c_ctrl_irq_enable(const struct device *dev, int enable)
-{
-	const struct i2c_ctrl_config *const config = dev->config;
-
-	if (enable) {
-		irq_enable(config->irq);
-	} else {
-		irq_disable(config->irq);
-	}
-}
-
-/* I2C controller inline functions access registers in 'Normal' bank */
-static inline void i2c_ctrl_norm_stall_scl(const struct device *dev)
+static inline int i2c_ctrl_bus_busy(const struct device *dev)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/* Force SCL bus to low and keep SDA floating */
-	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SCL_LVL))
-						| BIT(NPCX_SMBCTL3_SDA_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+	return IS_BIT_SET(inst->SMBCST, NPCX_SMBCST_BB);
 }
 
-static inline void i2c_ctrl_norm_free_scl(const struct device *dev)
+static inline void i2c_ctrl_data_write(const struct device *dev, uint8_t data)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/*
-	 * Release SCL bus. Then it might be still driven by module itself or
-	 * slave device.
-	 */
-	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SCL_LVL) | BIT(NPCX_SMBCTL3_SDA_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+	inst->SMBSDA = data;
 }
 
-/* I2C controller inline functions access registers in 'Normal' bank */
-static inline void i2c_ctrl_norm_stall_sda(const struct device *dev)
+static inline uint8_t i2c_ctrl_data_read(const struct device *dev)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/* Force SDA bus to low and keep SCL floating */
-	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SDA_LVL))
-						| BIT(NPCX_SMBCTL3_SCL_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+	return inst->SMBSDA;
 }
 
-static inline void i2c_ctrl_norm_free_sda(const struct device *dev)
+static inline void i2c_ctrl_bank_sel(const struct device *dev, int bank)
 {
 	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
-	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
-	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
-	/*
-	 * Release SDA bus. Then it might be still driven by module itself or
-	 * slave device.
-	 */
-	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SDA_LVL) | BIT(NPCX_SMBCTL3_SCL_LVL);
-	/* Disable writing to them */
-	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
-}
-
-/* I2C controller inline functions access registers in 'FIFO' bank */
-static inline void i2c_ctrl_fifo_write(const struct device *dev, uint8_t data)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	inst_fifo->SMBSDA = data;
-}
-
-static inline uint8_t i2c_ctrl_fifo_read(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return inst_fifo->SMBSDA;
-}
-
-static inline int i2c_ctrl_fifo_tx_avail(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return NPCX_I2C_FIFO_MAX_SIZE - (inst_fifo->SMBTXF_STS & 0x3f);
-}
-
-static inline int i2c_ctrl_fifo_rx_occupied(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-
-	return inst_fifo->SMBRXF_STS & 0x3f;
-}
-
-static inline void i2c_ctrl_fifo_rx_setup_threshold_nack(
-		const struct device *dev, int threshold, int last)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
-	uint8_t value = MIN(threshold, NPCX_I2C_FIFO_MAX_SIZE);
-
-	SET_FIELD(inst_fifo->SMBRXF_CTL, NPCX_SMBRXF_CTL_RX_THR, value);
-
-	/*
-	 * Is it last received transaction? If so, set LAST bit. Then the
-	 * hardware will generate NACK automatically when receiving last byte.
-	 */
-	if (last && (value == threshold)) {
-		inst_fifo->SMBRXF_CTL |= BIT(NPCX_SMBRXF_CTL_LAST);
+	/* All DMA registers locate at bank 0 */
+	if (IS_ENABLED(CONFIG_I2C_NPCX_DMA_DRIVEN)) {
+		return;
 	}
-}
-
-static inline void i2c_ctrl_fifo_clear_status(const struct device *dev)
-{
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
 
-	inst_fifo->SMBFIF_CTS |= BIT(NPCX_SMBFIF_CTS_CLR_FIFO);
+	if (bank) {
+		inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_BNK_SEL);
+	} else {
+		inst->SMBCTL3 &= ~BIT(NPCX_SMBCTL3_BNK_SEL);
+	}
 }
 
-/*
- * I2C local functions which touch the registers in 'Normal' bank. These
- * utilities will change bank back to FIFO mode when leaving themselves in case
- * the other utilities access the registers in 'FIFO' bank.
- */
-static void i2c_ctrl_hold_bus(const struct device *dev, int stall)
+static inline void i2c_ctrl_irq_enable(const struct device *dev, int enable)
 {
-	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_NORMAL);
+	const struct i2c_ctrl_config *const config = dev->config;
 
-	if (stall) {
-		i2c_ctrl_norm_stall_scl(dev);
+	if (enable) {
+		irq_enable(config->irq);
 	} else {
-		i2c_ctrl_norm_free_scl(dev);
+		irq_disable(config->irq);
 	}
-
-	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_FIFO);
 }
 
 static void i2c_ctrl_init_module(const struct device *dev)
@@ -354,9 +256,10 @@ static void i2c_ctrl_init_module(const struct device *dev)
 
 	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_NORMAL);
 
-	/* Enable FIFO mode first */
-	inst->SMBFIF_CTL |= BIT(NPCX_SMBFIF_CTL_FIFO_EN);
-
+	/* Enable FIFO mode first if selected */
+	if (!IS_ENABLED(CONFIG_I2C_NPCX_DMA_DRIVEN)) {
+		inst->SMBFIF_CTL |= BIT(NPCX_SMBFIF_CTL_FIFO_EN);
+	}
 	/* Enable module - before configuring CTL1 */
 	inst->SMBCTL2  |= BIT(NPCX_SMBCTL2_ENABLE);
 
@@ -405,7 +308,7 @@ static void i2c_ctrl_config_bus_freq(const struct device *dev,
 /* I2C controller local functions */
 static int i2c_ctrl_wait_stop_completed(const struct device *dev, int timeout)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 
 	if (timeout <= 0) {
 		return -EINVAL;
@@ -416,7 +319,7 @@ static int i2c_ctrl_wait_stop_completed(const struct device *dev, int timeout)
 		 * Wait till i2c bus is idle. This bit is cleared to 0
 		 * automatically after the STOP condition is generated.
 		 */
-		if (!IS_BIT_SET(inst_fifo->SMBCTL1, NPCX_SMBCTL1_STOP))
+		if (!IS_BIT_SET(inst->SMBCTL1, NPCX_SMBCTL1_STOP))
 			break;
 		k_msleep(1);
 	} while (--timeout);
@@ -463,7 +366,7 @@ static int i2c_ctrl_wait_idle_completed(const struct device *dev, int timeout)
 
 static int i2c_ctrl_recovery(const struct device *dev)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 	struct i2c_ctrl_data *const data = dev->data;
 	int ret;
 
@@ -471,8 +374,10 @@ static int i2c_ctrl_recovery(const struct device *dev)
 		data->oper_state = NPCX_I2C_ERROR_RECOVERY;
 	}
 
-	/* Step 1: Make sure the bus is not stalled before exit. */
-	i2c_ctrl_hold_bus(dev, 0);
+	/* Step 1: Make sure the bus is not stalled before exit in FIFO mode. */
+	if (!IS_ENABLED(CONFIG_I2C_NPCX_DMA_DRIVEN)) {
+		i2c_ctrl_fifo_hold_bus(dev, 0);
+	}
 
 	/*
 	 * Step 2: Abort data, wait for STOP condition completed.
@@ -480,9 +385,9 @@ static int i2c_ctrl_recovery(const struct device *dev)
 	 * - Wait for STOP condition completed
 	 * - Then clear BB (BUS BUSY) bit
 	 */
-	inst_fifo->SMBST = BIT(NPCX_SMBST_BER) | BIT(NPCX_SMBST_NEGACK);
+	inst->SMBST = BIT(NPCX_SMBST_BER) | BIT(NPCX_SMBST_NEGACK);
 	ret = i2c_ctrl_wait_stop_completed(dev, I2C_MAX_TIMEOUT);
-	inst_fifo->SMBCST |= BIT(NPCX_SMBCST_BB);
+	inst->SMBCST |= BIT(NPCX_SMBCST_BB);
 	if (ret != 0) {
 		LOG_ERR("Abort i2c port%02x fail! Bus might be stalled.",
 								data->port);
@@ -494,7 +399,7 @@ static int i2c_ctrl_recovery(const struct device *dev)
 	 * - Wait both SCL/SDA line are high
 	 * - Enable i2c module again
 	 */
-	inst_fifo->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+	inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
 	ret = i2c_ctrl_wait_idle_completed(dev, I2C_MAX_TIMEOUT);
 	if (ret != 0) {
 		LOG_ERR("Reset i2c port%02x fail! Bus might be stalled.",
@@ -537,6 +442,401 @@ size_t i2c_ctrl_calculate_msg_remains(const struct device *dev)
 	return (buf_end > data->ptr_msg) ? (buf_end - data->ptr_msg) : 0;
 }
 
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+/* I2C controller inline functions for 'DMA' mode */
+static inline uint16_t i2c_ctrl_dma_transferred_bytes(const struct device *dev)
+{
+	uint16_t lens;
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* return number of bytes of DMA transmitted or received transactions */
+	lens = (inst->DATA_CNT1 << 8) + inst->DATA_CNT2;
+
+	return lens;
+}
+
+static inline void i2c_ctrl_dma_nack(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	inst->DMA_CTRL |= BIT(NPCX_DMA_CTL_LAST_PEC);
+}
+
+static size_t i2c_ctrl_calc_dma_lens(const struct device *dev)
+{
+	size_t remains = i2c_ctrl_calculate_msg_remains(dev);
+
+	return MIN(remains, NPCX_I2C_DMA_MAX_SIZE);
+}
+
+static bool i2c_ctrl_dma_is_last_pkg(const struct device *dev, size_t remains)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	return data->ptr_msg + remains == data->msg->buf + data->msg->len;
+}
+
+static inline void i2c_ctrl_dma_clear_status(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Clear DMA interrupt bit */
+	inst->DMA_CTRL |= BIT(NPCX_DMA_CTL_INTCLR);
+}
+
+static inline void i2c_ctrl_dma_start(const struct device *dev, uint8_t *addr,
+	uint16_t lens)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+	uint32_t dma_addr = (uint32_t)addr;
+
+	if (lens == 0) {
+		return;
+	}
+
+	/* Configure the address of DMA transmitted or received transactions */
+	inst->DMA_ADDR1 = (uint8_t)(dma_addr & 0xff);
+	inst->DMA_ADDR2 = (uint8_t)((dma_addr >> 8) & 0xff);
+	inst->DMA_ADDR3 = (uint8_t)((dma_addr >> 16) & 0xff);
+	inst->DMA_ADDR4 = (uint8_t)((dma_addr >> 24) & 0xff);
+
+	/* Configure the length of DMA transmitted or received transactions */
+	inst->DATA_LEN1 = (uint8_t)(lens & 0xff);
+	inst->DATA_LEN2 = (uint8_t)((lens >> 8) & 0xff);
+
+	/* Clear DMA status bit and release bus */
+	if (IS_BIT_SET(inst->DMA_CTRL, NPCX_DMA_CTL_IRQSTS)) {
+		i2c_ctrl_dma_clear_status(dev);
+	}
+	/* Start the DMA transaction */
+	inst->DMA_CTRL |= BIT(NPCX_DMA_CTL_ENABLE);
+}
+
+static size_t i2c_ctrl_dma_proceed_write(const struct device *dev)
+{
+	/* Calculate how many remaining bytes need to transmit */
+	size_t dma_lens = i2c_ctrl_calc_dma_lens(dev);
+	struct i2c_ctrl_data *const data = dev->data;
+
+	LOG_DBG("W: dma lens %d, last %d", dma_lens,
+						i2c_ctrl_dma_transferred_bytes(dev));
+
+	/* No DMA transactions */
+	if (dma_lens == 0) {
+		return 0;
+	}
+
+	/* Start DMA transmitted transaction again */
+	i2c_ctrl_dma_start(dev, data->ptr_msg, dma_lens);
+
+	return dma_lens;
+}
+
+static size_t i2c_ctrl_dma_proceed_read(const struct device *dev)
+{
+	/* Calculate how many remaining bytes need to receive */
+	size_t dma_lens = i2c_ctrl_calc_dma_lens(dev);
+	struct i2c_ctrl_data *const data = dev->data;
+
+	LOG_DBG("R: dma lens %d, last %d",
+				dma_lens, i2c_ctrl_dma_transferred_bytes(dev));
+
+	if (dma_lens == 0) {
+		return 0;
+	}
+
+	/* Last byte for NACK in received transaction */
+	if (i2c_ctrl_dma_is_last_pkg(dev, dma_lens) &&
+				(data->msg->flags & I2C_MSG_STOP) != 0) {
+		/* Issue NACK in the end of DMA transation */
+		i2c_ctrl_dma_nack(dev);
+	}
+
+	/* Start DMA if bus is idle */
+	i2c_ctrl_dma_start(dev, data->ptr_msg, dma_lens);
+
+	return dma_lens;
+}
+
+/* I2C controller recover function in `DMA` mode */
+static inline bool i2c_ctrl_toggle_scls(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/*
+	 * Toggle SCL to generate 9 clocks. If the I2C target releases the SDA, we can stop
+	 * toggle the SCL and issue a STOP.
+	 */
+	for (int j = 0; j < 9; j++) {
+		if (IS_BIT_SET(inst->SMBCTL3, NPCX_SMBCTL3_SDA_LVL)) {
+			break;
+		}
+
+		/* Toggle SCL line for one cycle. */
+		inst->SMBCST |= BIT(NPCX_SMBCST_TGSCL);
+		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	}
+	/* Generate a STOP condition */
+	i2c_ctrl_stop(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	if (i2c_ctrl_is_scl_sda_both_high(dev)) {
+		return true;
+	}
+
+	return false;
+}
+
+/* I2C controller `DMA` interrupt functions */
+static void i2c_ctrl_handle_write_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* START condition is issued */
+	if (data->oper_state == NPCX_I2C_WAIT_START) {
+		/* Write slave address with W bit */
+		i2c_ctrl_data_write(dev, ((data->addr << 1)  & ~BIT(0)));
+
+		/* Start first DMA transmitted transaction */
+		i2c_ctrl_dma_proceed_write(dev);
+
+		/* Start to proceed write process */
+		data->oper_state = NPCX_I2C_WRITE_DATA;
+	}
+	/* Skip the other SDAST events */
+}
+
+static void i2c_ctrl_handle_read_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* START or RESTART condition is issued */
+	if (data->oper_state == NPCX_I2C_WAIT_START ||
+			data->oper_state == NPCX_I2C_WAIT_RESTART) {
+		/* Configure first DMA received transaction before sending address */
+		i2c_ctrl_dma_proceed_read(dev);
+
+		/* Write slave address with R bit */
+		i2c_ctrl_data_write(dev, ((data->addr << 1) | BIT(0)));
+
+		/* Start to proceed read process */
+		data->oper_state = NPCX_I2C_READ_DATA;
+	}
+	/* Skip the other SDAST events */
+}
+
+static void i2c_ctrl_handle_write_dma_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* Write message data bytes to FIFO */
+	if (data->oper_state == NPCX_I2C_WRITE_DATA) {
+		/* Record how many bytes transmitted via DMA */
+		data->ptr_msg += i2c_ctrl_dma_transferred_bytes(dev);
+
+		/* If next DMA transmitted transaction proceeds, return immediately */
+		if (i2c_ctrl_dma_proceed_write(dev) != 0) {
+			return;
+		}
+
+		/* No more remaining bytes */
+		if (data->msg->flags & I2C_MSG_STOP) {
+			/* Generate a STOP condition immediately */
+			i2c_ctrl_stop(dev);
+			/* Clear DMA status bit and release bus */
+			i2c_ctrl_dma_clear_status(dev);
+			/* Wait for STOP completed */
+			data->oper_state = NPCX_I2C_WAIT_STOP;
+		} else {
+			/* Disable interrupt and hold bus until handling next message */
+			i2c_ctrl_irq_enable(dev, 0);
+			/* Wait for the other messages */
+			data->oper_state = NPCX_I2C_WRITE_SUSPEND;
+		}
+
+		return i2c_ctrl_notify(dev, 0);
+	}
+}
+
+static void i2c_ctrl_handle_read_dma_int_event(const struct device *dev)
+{
+	struct i2c_ctrl_data *const data = dev->data;
+
+	/* Read message data bytes from FIFO */
+	if (data->oper_state == NPCX_I2C_READ_DATA) {
+		/* Record how many bytes received via DMA */
+		data->ptr_msg += i2c_ctrl_dma_transferred_bytes(dev);
+
+		/* If next DMA received transaction proceeds, return immediately */
+		if (i2c_ctrl_dma_proceed_read(dev) != 0) {
+			return;
+		}
+
+		/* Is the STOP condition issued? */
+		if ((data->msg->flags & I2C_MSG_STOP) != 0) {
+			/* Generate a STOP condition immediately */
+			i2c_ctrl_stop(dev);
+
+			/* Clear DMA status bit and release bus */
+			i2c_ctrl_dma_clear_status(dev);
+
+			/* Wait for STOP completed */
+			data->oper_state = NPCX_I2C_WAIT_STOP;
+		} else {
+			/* Disable i2c interrupt first */
+			i2c_ctrl_irq_enable(dev, 0);
+			data->oper_state = NPCX_I2C_READ_SUSPEND;
+		}
+
+		return i2c_ctrl_notify(dev, 0);
+	}
+}
+#else
+/* I2C controller inline functions for 'FIFO' mode */
+static inline void i2c_ctrl_fifo_stall_scl(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/* Force SCL bus to low and keep SDA floating */
+	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SCL_LVL))
+						| BIT(NPCX_SMBCTL3_SDA_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+
+static inline void i2c_ctrl_fifo_free_scl(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/*
+	 * Release SCL bus. Then it might be still driven by module itself or
+	 * slave device.
+	 */
+	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SCL_LVL) | BIT(NPCX_SMBCTL3_SDA_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+
+static inline void i2c_ctrl_fifo_stall_sda(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/* Force SDA bus to low and keep SCL floating */
+	inst->SMBCTL3 = (inst->SMBCTL3 & ~BIT(NPCX_SMBCTL3_SDA_LVL))
+						| BIT(NPCX_SMBCTL3_SCL_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+
+static inline void i2c_ctrl_norm_free_sda(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Enable writing to SCL_LVL/SDA_LVL bit in SMBnCTL3 */
+	inst->SMBCTL4 |= BIT(NPCX_SMBCTL4_LVL_WE);
+	/*
+	 * Release SDA bus. Then it might be still driven by module itself or
+	 * slave device.
+	 */
+	inst->SMBCTL3 |= BIT(NPCX_SMBCTL3_SDA_LVL) | BIT(NPCX_SMBCTL3_SCL_LVL);
+	/* Disable writing to them */
+	inst->SMBCTL4 &= ~BIT(NPCX_SMBCTL4_LVL_WE);
+}
+/*
+ * I2C local functions which touch the registers in 'Normal' bank. These
+ * utilities will change bank back to FIFO mode when leaving themselves in case
+ * the other utilities access the registers in 'FIFO' bank.
+ */
+void i2c_ctrl_fifo_hold_bus(const struct device *dev, int stall)
+{
+	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_NORMAL);
+
+	if (stall) {
+		i2c_ctrl_fifo_stall_scl(dev);
+	} else {
+		i2c_ctrl_fifo_free_scl(dev);
+	}
+
+	i2c_ctrl_bank_sel(dev, NPCX_I2C_BANK_FIFO);
+}
+
+static inline int i2c_ctrl_fifo_tx_avail(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	return NPCX_I2C_FIFO_MAX_SIZE - (inst->SMBTXF_STS & 0x3f);
+}
+
+static inline int i2c_ctrl_fifo_rx_occupied(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	return inst->SMBRXF_STS & 0x3f;
+}
+
+static inline void i2c_ctrl_fifo_rx_setup_threshold_nack(
+		const struct device *dev, int threshold, int last)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+	uint8_t value = MIN(threshold, NPCX_I2C_FIFO_MAX_SIZE);
+
+	SET_FIELD(inst->SMBRXF_CTL, NPCX_SMBRXF_CTL_RX_THR, value);
+
+	/*
+	 * Is it last received transaction? If so, set LAST bit. Then the
+	 * hardware will generate NACK automatically when receiving last byte.
+	 */
+	if (last && (value == threshold)) {
+		inst->SMBRXF_CTL |= BIT(NPCX_SMBRXF_CTL_LAST);
+	}
+}
+
+static inline void i2c_ctrl_fifo_clear_status(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	inst->SMBFIF_CTS |= BIT(NPCX_SMBFIF_CTS_CLR_FIFO);
+}
+
+/* I2C controller recover function in `FIFO` mode */
+static inline bool i2c_ctrl_toggle_scls(const struct device *dev)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+
+	/* Drive the clock high. */
+	i2c_ctrl_fifo_free_scl(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	/*
+	 * Toggle SCL to generate 9 clocks. If the I2C target releases the SDA, we can stop
+	 * toggle the SCL and issue a STOP.
+	 */
+	for (int j = 0; j < 9; j++) {
+		if (IS_BIT_SET(inst->SMBCTL3, NPCX_SMBCTL3_SDA_LVL)) {
+			break;
+		}
+		i2c_ctrl_fifo_stall_scl(dev);
+		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+		i2c_ctrl_fifo_free_scl(dev);
+		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	}
+	/* Drive the SDA line to issue STOP. */
+	i2c_ctrl_fifo_stall_sda(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	i2c_ctrl_norm_free_sda(dev);
+	k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
+	if (i2c_ctrl_is_scl_sda_both_high(dev)) {
+		return true;
+	}
+
+	return false;
+}
+
+/* I2C controller `FIFO` interrupt functions */
 static void i2c_ctrl_handle_write_int_event(const struct device *dev)
 {
 	struct i2c_ctrl_data *const data = dev->data;
@@ -544,21 +844,21 @@ static void i2c_ctrl_handle_write_int_event(const struct device *dev)
 	/* START condition is issued */
 	if (data->oper_state == NPCX_I2C_WAIT_START) {
 		/* Write slave address with W bit */
-		i2c_ctrl_fifo_write(dev, ((data->addr << 1)  & ~BIT(0)));
+		i2c_ctrl_data_write(dev, ((data->addr << 1)  & ~BIT(0)));
 		/* Start to proceed write process */
-		data->oper_state = NPCX_I2C_WRITE_FIFO;
+		data->oper_state = NPCX_I2C_WRITE_DATA;
 		return;
 	}
 
 	/* Write message data bytes to FIFO */
-	if (data->oper_state == NPCX_I2C_WRITE_FIFO) {
+	if (data->oper_state == NPCX_I2C_WRITE_DATA) {
 		/* Calculate how many remaining bytes need to transmit */
 		size_t tx_remain = i2c_ctrl_calculate_msg_remains(dev);
 		size_t tx_avail = MIN(tx_remain, i2c_ctrl_fifo_tx_avail(dev));
 
 		LOG_DBG("tx remains %d, avail %d", tx_remain, tx_avail);
 		for (int i = 0U; i < tx_avail; i++) {
-			i2c_ctrl_fifo_write(dev, *(data->ptr_msg++));
+			i2c_ctrl_data_write(dev, *(data->ptr_msg++));
 		}
 
 		/* Is there any remaining bytes? */
@@ -597,14 +897,14 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 		i2c_ctrl_fifo_rx_setup_threshold_nack(dev, data->msg->len,
 					(data->msg->flags & I2C_MSG_STOP) != 0);
 		/* Write slave address with R bit */
-		i2c_ctrl_fifo_write(dev, ((data->addr << 1) | BIT(0)));
+		i2c_ctrl_data_write(dev, ((data->addr << 1) | BIT(0)));
 		/* Start to proceed read process */
-		data->oper_state = NPCX_I2C_READ_FIFO;
+		data->oper_state = NPCX_I2C_READ_DATA;
 		return;
 	}
 
 	/* Read message data bytes from FIFO */
-	if (data->oper_state == NPCX_I2C_READ_FIFO) {
+	if (data->oper_state == NPCX_I2C_READ_DATA) {
 		/* Calculate how many remaining bytes need to receive */
 		size_t rx_remain = i2c_ctrl_calculate_msg_remains(dev);
 		size_t rx_occupied = i2c_ctrl_fifo_rx_occupied(dev);
@@ -625,12 +925,12 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 			 * immediately after the driver start to read data from
 			 * FIFO. Then we might lose incoming data from device.
 			 */
-			i2c_ctrl_hold_bus(dev, 1);
+			i2c_ctrl_fifo_hold_bus(dev, 1);
 		}
 
 		/* Read data bytes from FIFO */
 		for (int i = 0; i < rx_occupied; i++) {
-			*(data->ptr_msg++) = i2c_ctrl_fifo_read(dev);
+			*(data->ptr_msg++) = i2c_ctrl_data_read(dev);
 		}
 		rx_remain = i2c_ctrl_calculate_msg_remains(dev);
 
@@ -639,7 +939,7 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 			i2c_ctrl_fifo_rx_setup_threshold_nack(dev, rx_remain,
 					(data->msg->flags & I2C_MSG_STOP) != 0);
 			/* Release bus */
-			i2c_ctrl_hold_bus(dev, 0);
+			i2c_ctrl_fifo_hold_bus(dev, 0);
 			return;
 		}
 	}
@@ -659,6 +959,7 @@ static void i2c_ctrl_handle_read_int_event(const struct device *dev)
 
 	return i2c_ctrl_notify(dev, 0);
 }
+#endif /* CONFIG_I2C_NPCX_DMA_DRIVEN */
 
 static int i2c_ctrl_proc_write_msg(const struct device *dev,
 							struct i2c_msg *msg)
@@ -671,16 +972,20 @@ static int i2c_ctrl_proc_write_msg(const struct device *dev,
 
 	if (data->oper_state == NPCX_I2C_IDLE) {
 		data->oper_state = NPCX_I2C_WAIT_START;
-
+#if !defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
 		/* Clear FIFO status before starting a new transaction */
 		i2c_ctrl_fifo_clear_status(dev);
-
+#endif
 		/* Issue a START, wait for transaction completed */
 		i2c_ctrl_start(dev);
 
 		return i2c_ctrl_wait_completion(dev);
 	} else if (data->oper_state == NPCX_I2C_WRITE_SUSPEND) {
-		data->oper_state = NPCX_I2C_WRITE_FIFO;
+		data->oper_state = NPCX_I2C_WRITE_DATA;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Start the following DMA transmitted transaction */
+		i2c_ctrl_dma_proceed_write(dev);
+#endif
 		i2c_ctrl_irq_enable(dev, 1);
 
 		return i2c_ctrl_wait_completion(dev);
@@ -702,10 +1007,10 @@ static int i2c_ctrl_proc_read_msg(const struct device *dev, struct i2c_msg *msg)
 
 	if (data->oper_state == NPCX_I2C_IDLE) {
 		data->oper_state = NPCX_I2C_WAIT_START;
-
+#if !defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
 		/* Clear FIFO status before starting a new transaction */
 		i2c_ctrl_fifo_clear_status(dev);
-
+#endif
 		/* Issue a START, wait for transaction completed */
 		i2c_ctrl_start(dev);
 
@@ -714,19 +1019,26 @@ static int i2c_ctrl_proc_read_msg(const struct device *dev, struct i2c_msg *msg)
 		data->oper_state = NPCX_I2C_WAIT_RESTART;
 		/* Issue a RESTART, wait for transaction completed */
 		i2c_ctrl_start(dev);
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Clear DMA status bit and release bus */
+		i2c_ctrl_dma_clear_status(dev);
+#endif
 		i2c_ctrl_irq_enable(dev, 1);
 
 		return i2c_ctrl_wait_completion(dev);
 	} else if (data->oper_state == NPCX_I2C_READ_SUSPEND) {
-		data->oper_state = NPCX_I2C_READ_FIFO;
-
+		data->oper_state = NPCX_I2C_READ_DATA;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Start DMA received transaction */
+		i2c_ctrl_dma_proceed_read(dev);
+#else
 		/* Setup threshold of RX FIFO first */
 		i2c_ctrl_fifo_rx_setup_threshold_nack(dev, msg->len,
 				(msg->flags & I2C_MSG_STOP) != 0);
 
 		/* Release bus */
-		i2c_ctrl_hold_bus(dev, 0);
-
+		i2c_ctrl_fifo_hold_bus(dev, 0);
+#endif
 		/* Enable i2c interrupt first */
 		i2c_ctrl_irq_enable(dev, 1);
 		return i2c_ctrl_wait_completion(dev);
@@ -738,26 +1050,141 @@ static int i2c_ctrl_proc_read_msg(const struct device *dev, struct i2c_msg *msg)
 	return data->trans_err;
 }
 
+/* I2C controller isr function */
+#ifdef CONFIG_I2C_TARGET
+static void i2c_ctrl_target_isr(const struct device *dev, uint8_t status)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
+	struct i2c_ctrl_data *const data = dev->data;
+	const struct i2c_target_callbacks *target_cb = data->target_cfg->callbacks;
+	uint8_t val = 0;
+
+	/* A 'Bus Error' has been identified */
+	if (IS_BIT_SET(status, NPCX_SMBST_BER)) {
+		/* Clear BER Bit */
+		inst->SMBST = BIT(NPCX_SMBST_BER);
+
+		/* Notify upper layer the end of transaction */
+		if (target_cb->stop) {
+			target_cb->stop(data->target_cfg);
+		}
+
+		/* Reset i2c module in target mode */
+		inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+		inst->SMBCTL2 |= BIT(NPCX_SMBCTL2_ENABLE);
+
+		/* End of transaction */
+		data->oper_state = NPCX_I2C_IDLE;
+		return;
+	}
+
+	/* A 'Slave Stop' Condition has been identified */
+	if (IS_BIT_SET(status, NPCX_SMBST_SLVSTP)) {
+		/* Clear SLVSTP Bit */
+		inst->SMBST = BIT(NPCX_SMBST_SLVSTP);
+		/* End of transaction */
+		data->oper_state = NPCX_I2C_IDLE;
+		/* Notify upper layer a STOP condition received */
+		if (target_cb->stop) {
+			target_cb->stop(data->target_cfg);
+		}
+		return;
+	}
+
+	/* A negative acknowledge has occurred */
+	if (IS_BIT_SET(status, NPCX_SMBST_NEGACK)) {
+		/* Clear NEGACK Bit */
+		inst->SMBST = BIT(NPCX_SMBST_NEGACK);
+		/* Do nothing in i2c target mode */
+		return;
+	}
+
+	/* A 'Target Address Match' has been identified */
+	if (IS_BIT_SET(status, NPCX_SMBST_NMATCH)) {
+		/* Clear NMATCH Bit */
+		inst->SMBST = BIT(NPCX_SMBST_NMATCH);
+
+		/* Distinguish tje direction of i2c target mode by reading XMIT bit */
+		if (IS_BIT_SET(inst->SMBST, NPCX_SMBST_XMIT)) {
+			/* Start transmitting data in i2c target mode */
+			data->oper_state = NPCX_I2C_WRITE_DATA;
+			/* Write first requested byte after repeated start */
+			if (target_cb->read_requested) {
+				target_cb->read_requested(data->target_cfg, &val);
+			}
+			inst->SMBSDA = val;
+		} else {
+			/* Start receiving data in i2c target mode */
+			data->oper_state = NPCX_I2C_READ_DATA;
+			if (target_cb->write_requested) {
+				target_cb->write_requested(data->target_cfg);
+			}
+		}
+		return;
+	}
+
+	/* Tx byte empty or Rx byte full has occurred */
+	if (IS_BIT_SET(status, NPCX_SMBST_SDAST)) {
+		if (data->oper_state == NPCX_I2C_WRITE_DATA) {
+			/* Notify upper layer one byte will be transmitted */
+			if (target_cb->read_processed) {
+				target_cb->read_processed(data->target_cfg, &val);
+			}
+			inst->SMBSDA = val;
+		} else if (data->oper_state == NPCX_I2C_READ_DATA) {
+			if (target_cb->write_received) {
+				val = inst->SMBSDA;
+				/* Notify upper layer one byte received */
+				target_cb->write_received(data->target_cfg, val);
+			}
+		} else {
+			LOG_ERR("Unexpected oper state %d on i2c target port%02x!",
+				data->oper_state, data->port);
+		}
+		return;
+	}
+
+	/* Clear unexpected status bits */
+	if (status != 0) {
+		inst->SMBST = status;
+		LOG_ERR("Unexpected  SMBST 0x%02x occurred on i2c target port%02x!",
+			status, data->port);
+	}
+}
+#endif
+
 /* I2C controller isr function */
 static void i2c_ctrl_isr(const struct device *dev)
 {
-	struct smb_fifo_reg *const inst_fifo = HAL_I2C_FIFO_INSTANCE(dev);
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(dev);
 	struct i2c_ctrl_data *const data = dev->data;
-	uint8_t status, tmp;
+	uint8_t status = inst->SMBST & NPCX_VALID_SMBST_MASK;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+	uint8_t	dma_status = inst->DMA_CTRL;
 
-	status = inst_fifo->SMBST & NPCX_VALID_SMBST_MASK;
+	LOG_DBG("ISR status: %02x dma_ctrl: %02x, %d", status, dma_status, data->oper_state);
+#else
 	LOG_DBG("status: %02x, %d", status, data->oper_state);
+#endif
+
+#ifdef CONFIG_I2C_TARGET
+	if (atomic_test_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return i2c_ctrl_target_isr(dev, status);
+	}
+#endif
 
 	/* A 'Bus Error' has been identified */
 	if (IS_BIT_SET(status, NPCX_SMBST_BER)) {
+		uint8_t tmp;
+
 		/* Generate a STOP condition immediately */
 		i2c_ctrl_stop(dev);
 
 		/* Clear BER Bit */
-		inst_fifo->SMBST = BIT(NPCX_SMBST_BER);
+		inst->SMBST = BIT(NPCX_SMBST_BER);
 
 		/* Make sure slave doesn't hold bus by reading FIFO again */
-		tmp = i2c_ctrl_fifo_read(dev);
+		tmp = i2c_ctrl_data_read(dev);
 
 		LOG_ERR("Bus error occurred on i2c port%02x!", data->port);
 		data->oper_state = NPCX_I2C_ERROR_RECOVERY;
@@ -773,7 +1200,12 @@ static void i2c_ctrl_isr(const struct device *dev)
 		i2c_ctrl_stop(dev);
 
 		/* Clear NEGACK Bit */
-		inst_fifo->SMBST = BIT(NPCX_SMBST_NEGACK);
+		inst->SMBST = BIT(NPCX_SMBST_NEGACK);
+
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+		/* Clear DMA status bit to release bus */
+		i2c_ctrl_dma_clear_status(dev);
+#endif
 
 		/* End transaction */
 		data->oper_state = NPCX_I2C_WAIT_STOP;
@@ -791,9 +1223,20 @@ static void i2c_ctrl_isr(const struct device *dev)
 		}
 	}
 
+	/* DMA transaction has been finished */
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+	if (IS_BIT_SET(dma_status, NPCX_DMA_CTL_IRQSTS)) {
+		if (data->is_write) {
+			return i2c_ctrl_handle_write_dma_int_event(dev);
+		} else {
+			return i2c_ctrl_handle_read_dma_int_event(dev);
+		}
+	}
+#endif
+
 	/* Clear unexpected status bits */
 	if (status != 0) {
-		inst_fifo->SMBST = status;
+		inst->SMBST = status;
 		LOG_ERR("Unexpected  SMBST 0x%02x occurred on i2c port%02x!",
 			status, data->port);
 	}
@@ -892,32 +1335,7 @@ int npcx_i2c_ctrl_recover_bus(const struct device *dev)
 	}
 
 	for (int i = 0; i < I2C_RECOVER_SDA_RETRY; i++) {
-		/* Drive the clock high. */
-		i2c_ctrl_norm_free_scl(dev);
-		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-
-		/*
-		 * Toggle SCL to generate 9 clocks. If the I2C target releases the SDA, we can stop
-		 * toggle the SCL and issue a STOP.
-		 */
-		for (int j = 0; j < 9; j++) {
-			if (IS_BIT_SET(inst->SMBCTL3, NPCX_SMBCTL3_SDA_LVL)) {
-				break;
-			}
-
-			i2c_ctrl_norm_stall_scl(dev);
-			k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-			i2c_ctrl_norm_free_scl(dev);
-			k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-		}
-
-		/* Drive the SDA line to issue STOP. */
-		i2c_ctrl_norm_stall_sda(dev);
-		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-		i2c_ctrl_norm_free_sda(dev);
-		k_busy_wait(I2C_RECOVER_BUS_DELAY_US);
-
-		if (i2c_ctrl_is_scl_sda_both_high(dev)) {
+		if (i2c_ctrl_toggle_scls(dev)) {
 			ret = 0;
 			goto recover_exit;
 		}
@@ -938,6 +1356,86 @@ recover_exit:
 	return ret;
 }
 
+#ifdef CONFIG_I2C_TARGET
+int npcx_i2c_ctrl_target_register(const struct device *i2c_dev,
+				 struct i2c_target_config *target_cfg, uint8_t port)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(i2c_dev);
+	struct i2c_ctrl_data *const data = i2c_dev->data;
+	int idx_ctrl = (port & 0xF0) >> 4;
+	int idx_port = (port & 0x0F);
+	uint8_t addr = BIT(NPCX_SMBADDR1_SAEN) | target_cfg->address;
+
+	/* I2c module has been configured to target mode */
+	if (atomic_test_and_set_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return -EBUSY;
+	}
+
+	/* A transiaction is ongoing */
+	if (data->oper_state != NPCX_I2C_IDLE) {
+		atomic_clear_bit(&data->flags, NPCX_I2C_FLAG_TARGET);
+		return -EBUSY;
+	}
+
+	data->target_cfg = target_cfg;
+
+	i2c_ctrl_irq_enable(i2c_dev, 0);
+	/* Switch correct port for i2c controller first */
+	npcx_pinctrl_i2c_port_sel(idx_ctrl, idx_port);
+	/* Reset I2C module */
+	inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+	inst->SMBCTL2 |= BIT(NPCX_SMBCTL2_ENABLE);
+
+	/* Select normal bank and single byte mode for i2c target mode */
+	i2c_ctrl_bank_sel(i2c_dev, NPCX_I2C_BANK_NORMAL);
+	inst->SMBFIF_CTL &= ~BIT(NPCX_SMBFIF_CTL_FIFO_EN);
+	inst->SMBADDR1 = addr; /* Enable target mode and configure its address */
+
+	/* Reconfigure SMBCTL1 */
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_NMINTE) | BIT(NPCX_SMBCTL1_INTEN);
+	i2c_ctrl_irq_enable(i2c_dev, 1);
+
+	return 0;
+}
+
+int npcx_i2c_ctrl_target_unregister(const struct device *i2c_dev,
+				   struct i2c_target_config *target_cfg)
+{
+	struct smb_reg *const inst = HAL_I2C_INSTANCE(i2c_dev);
+	struct i2c_ctrl_data *const data = i2c_dev->data;
+
+	/* No I2c module has been configured to target mode */
+	if (!atomic_test_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return -EINVAL;
+	}
+
+	/* A transiaction is ongoing */
+	if (data->oper_state != NPCX_I2C_IDLE) {
+		return -EBUSY;
+	}
+	data->target_cfg = NULL;
+
+	i2c_ctrl_irq_enable(i2c_dev, 0);
+	/* Reset I2C module */
+	inst->SMBCTL2 &= ~BIT(NPCX_SMBCTL2_ENABLE);
+	inst->SMBCTL2 |= BIT(NPCX_SMBCTL2_ENABLE);
+
+	inst->SMBADDR1 = 0; /* Disable target mode and clear address setting */
+	/* Enable FIFO mode and select to FIFO bank for i2c controller mode */
+	inst->SMBFIF_CTL |= BIT(NPCX_SMBFIF_CTL_FIFO_EN);
+	i2c_ctrl_bank_sel(i2c_dev, NPCX_I2C_BANK_FIFO);
+
+	/* Reconfigure SMBCTL1 */
+	inst->SMBCTL1 |= BIT(NPCX_SMBCTL1_NMINTE) | BIT(NPCX_SMBCTL1_INTEN);
+	i2c_ctrl_irq_enable(i2c_dev, 1);
+
+	/* Mark it as controller mode */
+	atomic_clear_bit(&data->flags, NPCX_I2C_FLAG_TARGET);
+
+	return 0;
+}
+#endif
+
 int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
 			      uint8_t num_msgs, uint16_t addr, int port)
 {
@@ -945,6 +1443,13 @@ int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
 	int ret = 0;
 	uint8_t i;
 
+#ifdef CONFIG_I2C_TARGET
+	/* I2c module has been configured to target mode */
+	if (atomic_test_bit(&data->flags, NPCX_I2C_FLAG_TARGET)) {
+		return -EBUSY;
+	}
+#endif
+
 	/*
 	 * suspend-to-idle stops SMB module clocks (derived from APB2/APB3), which must remain
 	 * active during a transaction
@@ -1009,7 +1514,7 @@ int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
 		}
 	}
 
-	if (data->oper_state == NPCX_I2C_ERROR_RECOVERY) {
+	if (data->oper_state == NPCX_I2C_ERROR_RECOVERY || ret == -ETIMEDOUT) {
 		int recovery_error = i2c_ctrl_recovery(i2c_dev);
 		/*
 		 * Recovery failed, return it immediately. Otherwise, the upper
@@ -1040,7 +1545,7 @@ static int i2c_ctrl_init(const struct device *dev)
 
 	/* Turn on device clock first and get source clock freq. */
 	if (clock_control_on(clk_dev,
-		(clock_control_subsys_t *) &config->clk_cfg) != 0) {
+		(clock_control_subsys_t) &config->clk_cfg) != 0) {
 		LOG_ERR("Turn on %s clock fail.", dev->name);
 		return -EIO;
 	}
@@ -1050,7 +1555,7 @@ static int i2c_ctrl_init(const struct device *dev)
 	 * configuration of the device to meet SMBus timing spec. Please refer
 	 * Table 21/22/23 and section 7.5.9 SMBus Timing for more detail.
 	 */
-	if (clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	if (clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&config->clk_cfg, &i2c_rate) != 0) {
 		LOG_ERR("Get %s clock rate error.", dev->name);
 		return -EIO;
@@ -1110,7 +1615,7 @@ static int i2c_ctrl_init(const struct device *dev)
 									       \
 	static struct i2c_ctrl_data i2c_ctrl_data_##inst;                      \
 									       \
-	I2C_DEVICE_DT_INST_DEFINE(inst,                                        \
+	DEVICE_DT_INST_DEFINE(inst,                                            \
 			    NPCX_I2C_CTRL_INIT_FUNC(inst),                     \
 			    NULL,                                              \
 			    &i2c_ctrl_data_##inst, &i2c_ctrl_cfg_##inst,       \
diff --git a/drivers/i2c/i2c_npcx_controller.h b/drivers/i2c/i2c_npcx_controller.h
index d119b38fac..0833824404 100644
--- a/drivers/i2c/i2c_npcx_controller.h
+++ b/drivers/i2c/i2c_npcx_controller.h
@@ -80,6 +80,32 @@ int npcx_i2c_ctrl_transfer(const struct device *i2c_dev, struct i2c_msg *msgs,
  */
 int npcx_i2c_ctrl_recover_bus(const struct device *dev);
 
+/**
+ * @brief Registers the provided config as Target device of a npcx i2c controller.
+ *
+ * @param i2c_dev Pointer to the device structure for i2c controller instance.
+ * @param target_cfg Config struct used by the i2c target driver
+ * @param port Port index of selected i2c port.
+ *
+ * @retval 0 Is successful
+ * @retval -EBUSY If i2c transaction is proceeding.
+ */
+int npcx_i2c_ctrl_target_register(const struct device *i2c_dev,
+				 struct i2c_target_config *target_cfg, uint8_t port);
+
+/**
+ * @brief Unregisters the provided config as Target device of a npcx i2c controller.
+ *
+ * @param i2c_dev Pointer to the device structure for i2c controller instance.
+ * @param target_cfg Config struct used by the i2c target driver
+ *
+ * @retval 0 Is successful
+ * @retval -EBUSY If i2c transaction is proceeding.
+ * @retval -EINVAL If parameters are invalid
+ */
+int npcx_i2c_ctrl_target_unregister(const struct device *i2c_dev,
+				   struct i2c_target_config *target_cfg);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/i2c/i2c_npcx_port.c b/drivers/i2c/i2c_npcx_port.c
index d1ea375147..b43383c18d 100644
--- a/drivers/i2c/i2c_npcx_port.c
+++ b/drivers/i2c/i2c_npcx_port.c
@@ -143,6 +143,38 @@ static int i2c_npcx_port_recover_bus(const struct device *dev)
 	return ret;
 }
 
+#ifdef CONFIG_I2C_TARGET
+static int i2c_npcx_target_register(const struct device *dev,
+				  struct i2c_target_config *target_cfg)
+{
+	const struct i2c_npcx_port_config *const config = dev->config;
+
+	if (!target_cfg) {
+		return -EINVAL;
+	}
+
+	if (config->i2c_ctrl == NULL) {
+		LOG_ERR("Cannot find i2c controller on port%02x!", config->port);
+		return -EIO;
+	}
+
+	return npcx_i2c_ctrl_target_register(config->i2c_ctrl, target_cfg, config->port);
+}
+
+static int i2c_npcx_target_unregister(const struct device *dev,
+				     struct i2c_target_config *target_cfg)
+{
+	const struct i2c_npcx_port_config *const config = dev->config;
+
+	if (config->i2c_ctrl == NULL) {
+		LOG_ERR("Cannot find i2c controller on port%02x!", config->port);
+		return -EIO;
+	}
+
+	return npcx_i2c_ctrl_target_unregister(config->i2c_ctrl, target_cfg);
+}
+#endif
+
 /* I2C driver registration */
 static int i2c_npcx_port_init(const struct device *dev)
 {
@@ -173,6 +205,10 @@ static const struct i2c_driver_api i2c_port_npcx_driver_api = {
 	.get_config = i2c_npcx_port_get_config,
 	.transfer = i2c_npcx_port_transfer,
 	.recover_bus = i2c_npcx_port_recover_bus,
+#ifdef CONFIG_I2C_TARGET
+	.target_register = i2c_npcx_target_register,
+	.target_unregister = i2c_npcx_target_unregister,
+#endif
 };
 
 /* I2C port init macro functions */
@@ -190,7 +226,7 @@ static const struct i2c_driver_api i2c_port_npcx_driver_api = {
 			    i2c_npcx_port_init,                                \
 			    NULL, NULL,                                        \
 			    &i2c_npcx_port_cfg_##inst,                         \
-			    PRE_KERNEL_1, CONFIG_I2C_INIT_PRIORITY,            \
+			    PRE_KERNEL_1, CONFIG_I2C_NPCX_PORT_INIT_PRIORITY,  \
 			    &i2c_port_npcx_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(NPCX_I2C_PORT_INIT)
diff --git a/drivers/interrupt_controller/Kconfig b/drivers/interrupt_controller/Kconfig
index 93d6332294..a5ae5eb565 100644
--- a/drivers/interrupt_controller/Kconfig
+++ b/drivers/interrupt_controller/Kconfig
@@ -43,6 +43,19 @@ config INTC_INIT_PRIORITY
 	help
 	  Interrupt controller device initialization priority.
 
+if MCHP_ECIA_XEC
+
+config XEC_GIRQ_INIT_PRIORITY
+	int "XEX GIRQ Interrupt controller init priority"
+	default 41
+	help
+	  XEC GIRQ Interrupt controller device initialization priority.
+	  The priority value needs to be greater than INTC_INIT_PRIORITY
+	  So that the XEC GIRQ controllers are initialized after the
+	  xec_ecia.
+
+endif
+
 module = INTC
 module-str = intc
 source "subsys/logging/Kconfig.template.log_config"
diff --git a/drivers/interrupt_controller/intc_mchp_ecia_xec.c b/drivers/interrupt_controller/intc_mchp_ecia_xec.c
index 5a3a05953d..789c635b6a 100644
--- a/drivers/interrupt_controller/intc_mchp_ecia_xec.c
+++ b/drivers/interrupt_controller/intc_mchp_ecia_xec.c
@@ -572,7 +572,7 @@ static int xec_ecia_init(const struct device *dev)
 									\
 	DEVICE_DT_DEFINE(n, xec_girq_init_##n,				\
 		 NULL, &xec_data_girq_##n, &xec_config_girq_##n,	\
-		 PRE_KERNEL_1, CONFIG_INTC_INIT_PRIORITY,		\
+		 PRE_KERNEL_1, CONFIG_XEC_GIRQ_INIT_PRIORITY,		\
 		 NULL);							\
 									\
 	static int xec_girq_init_##n(const struct device *dev)		\
diff --git a/drivers/interrupt_controller/intc_miwu.c b/drivers/interrupt_controller/intc_miwu.c
index 509f90386e..81c5c515b1 100644
--- a/drivers/interrupt_controller/intc_miwu.c
+++ b/drivers/interrupt_controller/intc_miwu.c
@@ -57,6 +57,7 @@
 #include "soc_gpio.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(intc_miwu, LOG_LEVEL_ERR);
 
 /* MIWU module instances */
@@ -77,68 +78,53 @@ struct intc_miwu_config {
 	uint8_t index;
 };
 
-/* Callback functions list for GPIO wake-up inputs */
-sys_slist_t cb_list_gpio;
-
-/*
- * Callback functions list for the generic hardware modules  wake-up inputs
- * such as timer, uart, i2c, host interface and so on.
- */
-sys_slist_t cb_list_generic;
-
-BUILD_ASSERT(sizeof(struct miwu_io_callback) == sizeof(struct gpio_callback),
-	"Size of struct miwu_io_callback must equal to struct gpio_callback");
+/* Driver data */
+struct intc_miwu_data {
+	/* Callback functions list for each MIWU group */
+	sys_slist_t cb_list_grp[8];
+};
 
 BUILD_ASSERT(sizeof(struct miwu_io_params) == sizeof(gpio_port_pins_t),
 	"Size of struct miwu_io_params must equal to struct gpio_port_pins_t");
 
+BUILD_ASSERT(offsetof(struct miwu_callback, io_cb.params) +
+	sizeof(struct miwu_io_params) == sizeof(struct gpio_callback),
+	"Failed in size check of miwu_callback and gpio_callback structures!");
+
+BUILD_ASSERT(offsetof(struct miwu_callback, io_cb.params.cb_type) ==
+	offsetof(struct miwu_callback, dev_cb.params.cb_type),
+	"Failed in offset check of cb_type field of miwu_callback structure");
+
 /* MIWU local functions */
-static void intc_miwu_dispatch_gpio_isr(uint8_t wui_table,
-					uint8_t wui_group, uint8_t wui_bit)
+static void intc_miwu_dispatch_isr(sys_slist_t *cb_list, uint8_t mask)
 {
-	struct miwu_io_callback *cb, *tmp;
-
-	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&cb_list_gpio, cb, tmp, node) {
-		/* Pending bit, group and table match the wui item in list */
-		if (cb->params.wui.table == wui_table
-			&& cb->params.wui.group == wui_group
-			&& cb->params.wui.bit == wui_bit) {
-			__ASSERT(cb->handler, "No GPIO callback handler!");
-			/*
-			 * Execute GPIO callback and the other callback might
-			 * match the same wui item.
-			 */
-			cb->handler(npcx_get_gpio_dev(cb->params.gpio_port),
+	struct miwu_callback *cb, *tmp;
+
+	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(cb_list, cb, tmp, node) {
+
+		if (cb->io_cb.params.cb_type == NPCX_MIWU_CALLBACK_GPIO) {
+			if (BIT(cb->io_cb.params.wui.bit) & mask) {
+				__ASSERT(cb->io_cb.handler, "No GPIO callback handler!");
+				cb->io_cb.handler(
+					npcx_get_gpio_dev(cb->io_cb.params.gpio_port),
 					(struct gpio_callback *)cb,
-					cb->params.pin_mask);
-		}
-	}
-}
+					cb->io_cb.params.pin_mask);
+			}
+		} else {
+			if (BIT(cb->dev_cb.params.wui.bit) & mask) {
+				__ASSERT(cb->dev_cb.handler, "No device callback handler!");
 
-static void intc_miwu_dispatch_generic_isr(uint8_t wui_table,
-					uint8_t wui_group, uint8_t wui_bit)
-{
-	struct miwu_dev_callback *cb, *tmp;
-
-	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&cb_list_generic, cb, tmp, node) {
-		/* Pending bit, group and table match the wui item in list */
-		if (cb->wui.table == wui_table
-				&& cb->wui.group == wui_group
-				&& cb->wui.bit == wui_bit) {
-			__ASSERT(cb->handler, "No Generic callback handler!");
-			/*
-			 * Execute generic callback and the other callback might
-			 * match the same wui item.
-			 */
-			cb->handler(cb->source, &cb->wui);
+				cb->dev_cb.handler(cb->dev_cb.params.source,
+						   &cb->dev_cb.params.wui);
+			}
 		}
 	}
 }
 
 static void intc_miwu_isr_pri(int wui_table, int wui_group)
 {
-	int wui_bit;
 	const struct intc_miwu_config *config = miwu_devs[wui_table]->config;
+	struct intc_miwu_data *data = miwu_devs[wui_table]->data;
 	const uint32_t base = config->base;
 	uint8_t mask = NPCX_WKPND(base, wui_group) & NPCX_WKEN(base, wui_group);
 
@@ -147,17 +133,8 @@ static void intc_miwu_isr_pri(int wui_table, int wui_group)
 		NPCX_WKPCL(base, wui_group) = mask;
 	}
 
-	for (wui_bit = 0; wui_bit < 8; wui_bit++) {
-		if (mask & BIT(wui_bit)) {
-			LOG_DBG("miwu_isr %d %d %d!\n", wui_table,
-							wui_group, wui_bit);
-			/* Dispatch registered gpio and generic isrs */
-			intc_miwu_dispatch_gpio_isr(wui_table,
-							wui_group, wui_bit);
-			intc_miwu_dispatch_generic_isr(wui_table,
-							wui_group, wui_bit);
-		}
-	}
+	/* Dispatch registered gpio isrs */
+	intc_miwu_dispatch_isr(&data->cb_list_grp[wui_group], mask);
 }
 
 /* Platform specific MIWU functions */
@@ -277,50 +254,47 @@ int npcx_miwu_interrupt_configure(const struct npcx_wui *wui,
 	return 0;
 }
 
-void npcx_miwu_init_gpio_callback(struct miwu_io_callback *callback,
+void npcx_miwu_init_gpio_callback(struct miwu_callback *callback,
 				const struct npcx_wui *io_wui, int port)
 {
 	/* Initialize WUI and GPIO settings in unused bits field */
-	callback->params.wui.table = io_wui->table;
-	callback->params.wui.group = io_wui->group;
-	callback->params.wui.bit   = io_wui->bit;
-	callback->params.gpio_port = port;
+	callback->io_cb.params.wui.table = io_wui->table;
+	callback->io_cb.params.wui.bit   = io_wui->bit;
+	callback->io_cb.params.gpio_port = port;
+	callback->io_cb.params.cb_type = NPCX_MIWU_CALLBACK_GPIO;
+	callback->io_cb.params.wui.group = io_wui->group;
 }
 
-void npcx_miwu_init_dev_callback(struct miwu_dev_callback *callback,
+void npcx_miwu_init_dev_callback(struct miwu_callback *callback,
 				const struct npcx_wui *dev_wui,
 				miwu_dev_callback_handler_t handler,
 				const struct device *source)
 {
 	/* Initialize WUI and input device settings */
-	callback->wui.table = dev_wui->table;
-	callback->wui.group = dev_wui->group;
-	callback->wui.bit   = dev_wui->bit;
-	callback->handler = handler;
-	callback->source = source;
+	callback->dev_cb.params.wui.table = dev_wui->table;
+	callback->dev_cb.params.wui.group = dev_wui->group;
+	callback->dev_cb.params.wui.bit   = dev_wui->bit;
+	callback->dev_cb.params.source = source;
+	callback->dev_cb.params.cb_type = NPCX_MIWU_CALLBACK_DEV;
+	callback->dev_cb.handler = handler;
 }
 
-int npcx_miwu_manage_gpio_callback(struct miwu_io_callback *cb, bool set)
+int npcx_miwu_manage_callback(struct miwu_callback *cb, bool set)
 {
-	if (!sys_slist_is_empty(&cb_list_gpio)) {
-		if (!sys_slist_find_and_remove(&cb_list_gpio, &cb->node)) {
-			if (!set) {
-				return -EINVAL;
-			}
-		}
-	}
+	struct npcx_wui *wui;
+	struct intc_miwu_data *data;
+	sys_slist_t *cb_list;
 
-	if (set) {
-		sys_slist_prepend(&cb_list_gpio, &cb->node);
+	if (cb->io_cb.params.cb_type == NPCX_MIWU_CALLBACK_GPIO) {
+		wui = &cb->io_cb.params.wui;
+	} else {
+		wui = &cb->dev_cb.params.wui;
 	}
 
-	return 0;
-}
-
-int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set)
-{
-	if (!sys_slist_is_empty(&cb_list_generic)) {
-		if (!sys_slist_find_and_remove(&cb_list_generic, &cb->node)) {
+	data = miwu_devs[wui->table]->data;
+	cb_list = &data->cb_list_grp[wui->group];
+	if (!sys_slist_is_empty(cb_list)) {
+		if (!sys_slist_find_and_remove(cb_list, &cb->node)) {
 			if (!set) {
 				return -EINVAL;
 			}
@@ -328,7 +302,7 @@ int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set)
 	}
 
 	if (set) {
-		sys_slist_prepend(&cb_list_generic, &cb->node);
+		sys_slist_prepend(cb_list, &cb->node);
 	}
 
 	return 0;
@@ -384,11 +358,12 @@ int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set)
 		.base = DT_REG_ADDR(DT_NODELABEL(miwu##inst)),                 \
 		.index = DT_PROP(DT_NODELABEL(miwu##inst), index),             \
 	};                                                                     \
+	struct intc_miwu_data miwu_data_##inst;				       \
 									       \
 	DEVICE_DT_INST_DEFINE(inst,					       \
 			    NPCX_MIWU_INIT_FUNC(inst),                         \
 			    NULL,					       \
-			    NULL, &miwu_config_##inst,                         \
+			    &miwu_data_##inst, &miwu_config_##inst,            \
 			    PRE_KERNEL_1,                                      \
 			    CONFIG_INTC_INIT_PRIORITY, NULL);                  \
 									       \
diff --git a/drivers/led/CMakeLists.txt b/drivers/led/CMakeLists.txt
index b3d5147ef6..ba1dd973fa 100644
--- a/drivers/led/CMakeLists.txt
+++ b/drivers/led/CMakeLists.txt
@@ -5,6 +5,7 @@ zephyr_library()
 zephyr_library_sources_ifdef(CONFIG_HT16K33 ht16k33.c)
 zephyr_library_sources_ifdef(CONFIG_LED_GPIO led_gpio.c)
 zephyr_library_sources_ifdef(CONFIG_LED_PWM led_pwm.c)
+zephyr_library_sources_ifdef(CONFIG_LED_XEC led_mchp_xec.c)
 zephyr_library_sources_ifdef(CONFIG_LP3943 lp3943.c)
 zephyr_library_sources_ifdef(CONFIG_LP503X lp503x.c)
 zephyr_library_sources_ifdef(CONFIG_LP5562 lp5562.c)
diff --git a/drivers/led/Kconfig b/drivers/led/Kconfig
index 7c62be06ba..a93e4dc83c 100644
--- a/drivers/led/Kconfig
+++ b/drivers/led/Kconfig
@@ -34,5 +34,6 @@ source "drivers/led/Kconfig.lp5562"
 source "drivers/led/Kconfig.pca9633"
 source "drivers/led/Kconfig.pwm"
 source "drivers/led/Kconfig.tlc59108"
+source "drivers/led/Kconfig.xec"
 
 endif # LED
diff --git a/drivers/led/Kconfig.xec b/drivers/led/Kconfig.xec
new file mode 100644
index 0000000000..e0651567ca
--- /dev/null
+++ b/drivers/led/Kconfig.xec
@@ -0,0 +1,11 @@
+# Copyright (c) 2022 Microchip Technology Inc.
+# SPDX-License-Identifier: Apache-2.0
+
+config LED_XEC
+	bool "Microchip XEC BB-LED driver"
+	default y
+        # Backport note: Drop this and use device tree when intercepting 3.2
+	depends on LED
+	help
+	  Enable driver for the Microchip XEC Breathing-Blinking
+	  LED controller
diff --git a/drivers/led/led_mchp_xec.c b/drivers/led/led_mchp_xec.c
new file mode 100644
index 0000000000..1dfc405e0a
--- /dev/null
+++ b/drivers/led/led_mchp_xec.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2022 Microchip Technology Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT microchip_xec_bbled
+
+/**
+ * @file
+ * @brief Microchip Breathing-Blinking LED controller
+ */
+
+#include <soc.h>
+#ifndef CONFIG_SOC_SERIES_MEC1501X
+#include <zephyr/drivers/clock_control/mchp_xec_clock_control.h>
+#include <zephyr/drivers/interrupt_controller/intc_mchp_xec_ecia.h>
+#endif
+#include <zephyr/drivers/led.h>
+#include <zephyr/drivers/pinctrl.h>
+#include <zephyr/device.h>
+#include <zephyr/kernel.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(led_xec, CONFIG_LED_LOG_LEVEL);
+
+/* Same BBLED hardware block in MEC15xx and MEC172x families
+ * Config register
+ */
+#define XEC_BBLED_CFG_MSK		0x1ffffu
+#define XEC_BBLED_CFG_MODE_POS		0
+#define XEC_BBLED_CFG_MODE_MSK		0x3u
+#define XEC_BBLED_CFG_MODE_OFF		0
+#define XEC_BBLED_CFG_MODE_BREATHING	0x1u
+#define XEC_BBLED_CFG_MODE_PWM		0x2u
+#define XEC_BBLED_CFG_MODE_ALWAYS_ON	0x3u
+#define XEC_BBLED_CFG_CLK_SRC_48M_POS	2
+#define XEC_BBLED_CFG_EN_UPDATE_POS	6
+#define XEC_BBLED_CFG_RST_PWM_POS	7
+#define XEC_BBLED_CFG_WDT_RLD_POS	8
+#define XEC_BBLED_CFG_WDT_RLD_MSK0	0xffu
+#define XEC_BBLED_CFG_WDT_RLD_MSK	0xff00u
+#define XEC_BBLED_CFG_WDT_RLD_DFLT	0x1400u
+
+/* Limits register */
+#define XEC_BBLED_LIM_MSK		0xffffu
+#define XEC_BBLED_LIM_MIN_POS		0
+#define XEC_BBLED_LIM_MIN_MSK		0xffu
+#define XEC_BBLED_LIM_MAX_POS		8
+#define XEC_BBLED_LIM_MAX_MSK		0xff00u
+
+/* Delay register */
+#define XEC_BBLED_DLY_MSK		0xffffffu
+#define XEC_BBLED_DLY_LO_POS		0
+#define XEC_BBLED_DLY_LO_MSK		0xfffu
+#define XEC_BBLED_DLY_HI_POS		12
+#define XEC_BBLED_DLY_HI_MSK		0xfff000u
+
+/* Update step size and update interval registers implement
+ * eight 4-bit fields numbered 0 to 7
+ */
+#define XEC_BBLED_UPD_SSI_POS(n)	((uint32_t)(n) * 4u)
+#define XEC_BBLED_UPD_SSI0_MSK(n)	((uint32_t)0xfu << XEC_BBLED_UPD_SSI_POS(n))
+
+/* Output delay register: b[7:0] is delay in clock source units */
+#define XEC_BBLED_OUT_DLY_MSK		0xffu
+
+/* Delay.Lo register field */
+#define XEC_BBLED_MAX_PRESCALER		4095u
+/* Blink mode source frequency is 32768 Hz */
+#define XEC_BBLED_BLINK_CLK_SRC_HZ	32768u
+/* Fblink = 32768 / (256 * (prescaler+1))
+ * prescaler is 12 bit.
+ * Maximum Fblink = 128 Hz or 7.8125 ms
+ * Minimum Fblink = 32.25 mHz or 32000 ms
+ */
+#define XEC_BBLED_BLINK_PERIOD_MAX_MS	32000u
+#define XEC_BBLED_BLINK_PERIOD_MIN_MS	8u
+
+struct xec_bbled_regs {
+	volatile uint32_t config;
+	volatile uint32_t limits;
+	volatile uint32_t delay;
+	volatile uint32_t update_step_size;
+	volatile uint32_t update_interval;
+	volatile uint32_t output_delay;
+};
+
+struct xec_bbled_config {
+	struct xec_bbled_regs * const regs;
+	const struct pinctrl_dev_config *pcfg;
+	uint8_t girq_id;
+	uint8_t girq_pos;
+	uint8_t pcr_id;
+	uint8_t pcr_pos;
+};
+
+/* delay_on and delay_off are in milliseconds
+ * (prescale+1) = (32768 * Tblink_ms) / (256 * 1000)
+ * requires caller to limit delay_on and delay_off based
+ * on BBLED 32KHz minimum/maximum values.
+ */
+static uint32_t calc_blink_32k_prescaler(uint32_t delay_on, uint32_t delay_off)
+{
+	uint32_t temp = ((delay_on + delay_off) * XEC_BBLED_BLINK_CLK_SRC_HZ) / (256U * 1000U);
+	uint32_t prescaler = 0u;
+
+	if (temp) {
+		temp--;
+		if (temp > XEC_BBLED_MAX_PRESCALER) {
+			prescaler = XEC_BBLED_MAX_PRESCALER;
+		} else {
+			prescaler = (uint32_t)temp;
+		}
+	}
+
+	return prescaler;
+}
+
+/* return duty cycle scaled to [0, 255]
+ * caller must insure delay_on and delay_off are in hardware range.
+ */
+static inline uint32_t calc_blink_duty_cycle(uint32_t delay_on, uint32_t delay_off)
+{
+	return (256U * delay_on) / (delay_on + delay_off);
+}
+
+/* Enable HW blinking of the LED.
+ * delay_on = on time in milliseconds
+ * delay_off = off time in milliseconds
+ * BBLED blinking mode uses an 8-bit accumulator and an 8-bit duty cycle
+ * register. The duty cycle register is programmed once and the
+ * accumulator is used as an 8-bit up counter.
+ * The counter uses the 32768 Hz clock and is pre-scaled by the delay
+ * counter. Maximum blink rate is 128Hz to 32.25 mHz (7.8 ms to 32 seconds).
+ * 8-bit duty cycle values: 0x00 = full off, 0xff = full on.
+ * Fblink = 32768 / ((prescale + 1) * 256)
+ * HiWidth (seconds) = (1/Fblink) * (duty_cycle / 256)
+ * LoWidth (seconds) = (1/Fblink) * ((1 - duty_cycle) / 256)
+ * duty_cycle in [0, 1]. Register value for duty cycle is
+ * scaled to [0, 255].
+ * prescale is delay register low delay field, bits[11:0]
+ * duty_cycle is limits register minimum field, bits[7:0]
+ */
+static int xec_bbled_blink(const struct device *dev, uint32_t led,
+			    uint32_t delay_on, uint32_t delay_off)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+	uint32_t period, prescaler, dcs;
+
+	if (led) {
+		return -EINVAL;
+	}
+
+	/* insure period will not overflow uin32_t */
+	if ((delay_on > XEC_BBLED_BLINK_PERIOD_MAX_MS)
+	    || (delay_off > XEC_BBLED_BLINK_PERIOD_MAX_MS)) {
+		return -EINVAL;
+	}
+
+	period = delay_on + delay_off;
+	if ((period < XEC_BBLED_BLINK_PERIOD_MIN_MS)
+	    || (period > XEC_BBLED_BLINK_PERIOD_MAX_MS)) {
+		return -EINVAL;
+	}
+
+	prescaler = calc_blink_32k_prescaler(delay_on, delay_off);
+	dcs = calc_blink_duty_cycle(delay_on, delay_off);
+
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+		       | XEC_BBLED_CFG_MODE_OFF;
+	regs->delay = (regs->delay & ~(XEC_BBLED_DLY_LO_MSK))
+		      | (prescaler & XEC_BBLED_DLY_LO_MSK);
+	regs->limits = (regs->limits & ~(XEC_BBLED_LIM_MIN_MSK))
+		       | (dcs & XEC_BBLED_LIM_MIN_MSK);
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+		       | XEC_BBLED_CFG_MODE_PWM;
+	regs->config |= BIT(XEC_BBLED_CFG_EN_UPDATE_POS);
+
+	return 0;
+}
+
+static int xec_bbled_on(const struct device *dev, uint32_t led)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+
+	if (led) {
+		return -EINVAL;
+	}
+
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+			| XEC_BBLED_CFG_MODE_ALWAYS_ON;
+	return 0;
+}
+
+static int xec_bbled_off(const struct device *dev, uint32_t led)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+
+	if (led) {
+		return -EINVAL;
+	}
+
+	regs->config = (regs->config & ~(XEC_BBLED_CFG_MODE_MSK))
+			| XEC_BBLED_CFG_MODE_OFF;
+	return 0;
+}
+
+#ifdef CONFIG_SOC_SERIES_MEC1501X
+static inline void xec_bbled_slp_en_clr(const struct device *dev)
+{
+	const struct xec_bbled_config * const cfg = dev->config;
+	enum pcr_id pcr_val = PCR_MAX_ID;
+
+	switch (cfg->pcr_pos) {
+	case MCHP_PCR3_LED0_POS:
+		pcr_val = PCR_LED0;
+		break;
+	case MCHP_PCR3_LED1_POS:
+		pcr_val = PCR_LED1;
+		break;
+	case MCHP_PCR3_LED2_POS:
+		pcr_val = PCR_LED2;
+		break;
+	default:
+		return;
+	}
+
+	mchp_pcr_periph_slp_ctrl(pcr_val, 0);
+}
+#else
+static inline void xec_bbled_slp_en_clr(const struct device *dev)
+{
+	const struct xec_bbled_config * const cfg = dev->config;
+
+	z_mchp_xec_pcr_periph_sleep(cfg->pcr_id, cfg->pcr_pos, 0);
+}
+#endif
+
+static int xec_bbled_init(const struct device *dev)
+{
+	const struct xec_bbled_config * const config = dev->config;
+	struct xec_bbled_regs * const regs = config->regs;
+
+	xec_bbled_slp_en_clr(dev);
+
+	/* soft reset, disable BBLED WDT, set clock source to default (32KHz domain) */
+	regs->config |= BIT(XEC_BBLED_CFG_RST_PWM_POS);
+	regs->config = XEC_BBLED_CFG_MODE_OFF;
+
+	int ret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
+
+	if (ret != 0) {
+		LOG_ERR("XEC BBLED pinctrl setup failed (%d)", ret);
+	}
+
+	return ret;
+}
+
+static const struct led_driver_api xec_bbled_api = {
+	.on		= xec_bbled_on,
+	.off		= xec_bbled_off,
+	.blink		= xec_bbled_blink,
+};
+
+#define XEC_BBLED_PINCTRL_DEF(i) PINCTRL_DT_INST_DEFINE(i)
+
+#define XEC_BBLED_CONFIG(i)						\
+static struct xec_bbled_config xec_bbled_config_##i = {			\
+	.regs = (struct xec_bbled_regs * const)DT_INST_REG_ADDR(i),	\
+	.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),			\
+	.girq_id = (uint8_t)(DT_INST_PROP_BY_IDX(i, girqs, 0)),		\
+	.girq_pos = (uint8_t)(DT_INST_PROP_BY_IDX(i, girqs, 1)),	\
+	.pcr_id = (uint8_t)DT_INST_PROP_BY_IDX(i, pcrs, 0),		\
+	.pcr_pos = (uint8_t)DT_INST_PROP_BY_IDX(i, pcrs, 1),		\
+}
+
+#define XEC_BBLED_DEVICE(i)						\
+									\
+XEC_BBLED_PINCTRL_DEF(i);						\
+									\
+XEC_BBLED_CONFIG(i);							\
+									\
+DEVICE_DT_INST_DEFINE(i, &xec_bbled_init, NULL,				\
+		      NULL, &xec_bbled_config_##i,			\
+		      POST_KERNEL, CONFIG_LED_INIT_PRIORITY,		\
+		      &xec_bbled_api);
+
+DT_INST_FOREACH_STATUS_OKAY(XEC_BBLED_DEVICE)
diff --git a/drivers/peci/peci_mchp_xec.c b/drivers/peci/peci_mchp_xec.c
index fff0abe74b..d97f85d855 100644
--- a/drivers/peci/peci_mchp_xec.c
+++ b/drivers/peci/peci_mchp_xec.c
@@ -442,6 +442,7 @@ static int peci_xec_init(const struct device *dev)
 {
 	const struct peci_xec_config * const cfg = dev->config;
 	struct peci_regs * const regs = cfg->regs;
+	struct ecs_regs * const ecs_regs = (struct ecs_regs *)(DT_REG_ADDR(DT_NODELABEL(ecs)));
 
 #ifdef CONFIG_PINCTRL
 	int ret = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
@@ -458,6 +459,8 @@ static int peci_xec_init(const struct device *dev)
 
 	peci_clr_slp_en(dev);
 
+	ecs_regs->PECI_DIS = 0x00u;
+
 	/* Reset PECI interface */
 	regs->CONTROL |= MCHP_PECI_CTRL_RST;
 	k_msleep(PECI_RESET_DELAY_MS);
diff --git a/drivers/peci/peci_npcx.c b/drivers/peci/peci_npcx.c
index 7c7a2a45e5..a8579cbc21 100644
--- a/drivers/peci/peci_npcx.c
+++ b/drivers/peci/peci_npcx.c
@@ -12,8 +12,10 @@
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/peci.h>
 #include <zephyr/drivers/pinctrl.h>
+#include <zephyr/kernel.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(peci_npcx, CONFIG_PECI_LOG_LEVEL);
 
 #define PECI_TIMEOUT		 K_MSEC(300)
@@ -78,7 +80,7 @@ static int peci_npcx_configure(const struct device *dev, uint32_t bitrate)
 	 * The unit of the bitrate is in Kbps, need to convert it to bps when
 	 * calculate the divider
 	 */
-	bit_rate_divider = ceiling_fraction(data->peci_src_clk_freq, bitrate * 1000 * 4) - 1;
+	bit_rate_divider = DIV_ROUND_UP(data->peci_src_clk_freq, bitrate * 1000 * 4) - 1;
 	/*
 	 * Make sure the divider doesn't exceed the max valid value and is not lower than the
 	 * minimal valid value.
@@ -242,13 +244,13 @@ static int peci_npcx_init(const struct device *dev)
 		return -ENODEV;
 	}
 
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)&config->clk_cfg);
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on PECI clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)&config->clk_cfg,
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clk_cfg,
 				     &data->peci_src_clk_freq);
 	if (ret < 0) {
 		LOG_ERR("Get PECI source clock rate error %d", ret);
diff --git a/drivers/pinctrl/pinctrl_npcx.c b/drivers/pinctrl/pinctrl_npcx.c
index 22848b937d..afdd0ecf60 100644
--- a/drivers/pinctrl/pinctrl_npcx.c
+++ b/drivers/pinctrl/pinctrl_npcx.c
@@ -38,17 +38,10 @@ static const struct npcx_pwm_pinctrl_config pwm_pinctrl_cfg[] = {
 /* Pin-control local functions for peripheral devices */
 static bool npcx_periph_pinmux_has_lock(int group)
 {
-#if defined(CONFIG_SOC_SERIES_NPCX7)
-	if (group == 0x00 || (group >= 0x02 && group <= 0x04) || group == 0x06 ||
-		group == 0x0b || group == 0x0f) {
+	if ((BIT(group) & NPCX_DEVALT_LK_GROUP_MASK) != 0) {
 		return true;
 	}
-#elif defined(CONFIG_SOC_SERIES_NPCX9)
-	if (group == 0x00 || (group >= 0x02 && group <= 0x06) || group == 0x0b ||
-		group == 0x0d || (group >= 0x0f && group <= 0x12)) {
-		return true;
-	}
-#endif
+
 	return false;
 }
 
@@ -71,8 +64,11 @@ static void npcx_periph_pinmux_configure(const struct npcx_periph *alt, bool is_
 		NPCX_DEVALT(scfg_base, alt->group) &= ~alt_mask;
 	}
 
+	/* NPCK3 series doesn't support lock functionality */
 	if (is_locked && npcx_periph_pinmux_has_lock(alt->group)) {
+#if !defined(CONFIG_SOC_SERIES_NPCK3)
 		NPCX_DEVALT_LK(scfg_base, alt->group) |= alt_mask;
+#endif
 	}
 }
 
@@ -146,11 +142,35 @@ static void npcx_psl_input_detection_configure(const pinctrl_soc_pin_t *pin)
 	}
 
 	/* Configure detection mode of PSL input pads */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	if (pin->flags.psl_in_mode == NPCX_PSL_IN_MODE_EDGE) {
+		inst_glue->PSL_CTS3 |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	} else {
+		inst_glue->PSL_CTS3 &= ~NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	}
+
+	/* Clear event bits */
+	inst_glue->PSL_CTS |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	inst_glue->PSL_IN_POS |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+	inst_glue->PSL_IN_NEG |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
+
+#else
 	if (pin->flags.psl_in_mode == NPCX_PSL_IN_MODE_EDGE) {
 		inst_glue->PSL_CTS |= NPCX_PSL_CTS_MODE_BIT(psl_in->port);
 	} else {
 		inst_glue->PSL_CTS &= ~NPCX_PSL_CTS_MODE_BIT(psl_in->port);
 	}
+#endif
+}
+
+static void npcx_device_control_configure(const pinctrl_soc_pin_t *pin)
+{
+	const struct npcx_dev_ctl *ctrl = (const struct npcx_dev_ctl *)&pin->cfg.dev_ctl;
+	const uintptr_t scfg_base = npcx_pinctrl_cfg.base_scfg;
+
+	SET_FIELD(NPCX_DEV_CTL(scfg_base, ctrl->offest),
+			      FIELD(ctrl->field_offset, ctrl->field_size),
+			      ctrl->field_value);
 }
 
 /* Pinctrl API implementation */
@@ -164,6 +184,9 @@ int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
 		if (pins[i].flags.type == NPCX_PINCTRL_TYPE_PERIPH) {
 			/* Configure peripheral device's pinmux functionality */
 			npcx_periph_configure(&pins[i], reg);
+		} else if (pins[i].flags.type == NPCX_PINCTRL_TYPE_DEVICE_CTRL) {
+			/* Configure device's io characteristics */
+			npcx_device_control_configure(&pins[i]);
 		} else if (pins[i].flags.type == NPCX_PINCTRL_TYPE_PSL_IN) {
 			/* Configure SPL input's detection mode */
 			npcx_psl_input_detection_configure(&pins[i]);
diff --git a/drivers/ps2/Kconfig.npcx b/drivers/ps2/Kconfig.npcx
index e14e680eb3..afbec76d92 100644
--- a/drivers/ps2/Kconfig.npcx
+++ b/drivers/ps2/Kconfig.npcx
@@ -5,7 +5,8 @@
 
 menuconfig PS2_NPCX
 	bool "Nuvoton NPCX embedded controller (EC) PS2 driver"
-	depends on SOC_FAMILY_NPCX && ESPI_PERIPHERAL_8042_KBC
+	depends on DT_HAS_NUVOTON_NPCX_PS2_CHANNEL_ENABLED
+	default y
 	help
 	  Enable the NPCX family PS2 driver. It provides four PS/2 channels.
 	  Each channel has two quasi-bidirectional signals that serve as
diff --git a/drivers/ps2/ps2_npcx_controller.c b/drivers/ps2/ps2_npcx_controller.c
index aacb9973ef..ad37d5e162 100644
--- a/drivers/ps2/ps2_npcx_controller.c
+++ b/drivers/ps2/ps2_npcx_controller.c
@@ -15,11 +15,13 @@
  * The hardware accelerator mechanism is shared by four PS/2 channels.
  */
 
+#include <zephyr/kernel.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/ps2.h>
 #include <zephyr/dt-bindings/clock/npcx_clock.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(ps2_npcx_ctrl, CONFIG_PS2_LOG_LEVEL);
 
 #define NPCX_PS2_CH_COUNT 4
@@ -337,7 +339,7 @@ static int ps2_npcx_ctrl_init(const struct device *dev)
 
 	/* Turn on PS/2 controller device clock */
 	ret = clock_control_on(clk_dev,
-			       (clock_control_subsys_t *)&config->clk_cfg);
+			       (clock_control_subsys_t)&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on PS/2 clock fail %d", ret);
 		return ret;
diff --git a/drivers/pwm/pwm_npcx.c b/drivers/pwm/pwm_npcx.c
index d39c173581..44dd89d350 100644
--- a/drivers/pwm/pwm_npcx.c
+++ b/drivers/pwm/pwm_npcx.c
@@ -113,7 +113,7 @@ static int pwm_npcx_set_cycles(const struct device *dev, uint32_t channel,
 	 * maximum pwm period cycles and won't exceed it.
 	 * Then prescaler = ceil (period_cycles / pwm_max_period_cycles)
 	 */
-	prescaler = ceiling_fraction(period_cycles, NPCX_PWM_MAX_PERIOD_CYCLES);
+	prescaler = DIV_ROUND_UP(period_cycles, NPCX_PWM_MAX_PERIOD_CYCLES);
 	if (prescaler > NPCX_PWM_MAX_PRESCALER) {
 		return -EINVAL;
 	}
@@ -189,14 +189,14 @@ static int pwm_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on PWM clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&config->clk_cfg, &data->cycles_per_sec);
 	if (ret < 0) {
 		LOG_ERR("Get PWM clock rate error %d", ret);
@@ -230,7 +230,7 @@ static int pwm_npcx_init(const struct device *dev)
 	DEVICE_DT_INST_DEFINE(inst,					       \
 			    &pwm_npcx_init, NULL,			       \
 			    &pwm_npcx_data_##inst, &pwm_npcx_cfg_##inst,       \
-			    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \
+			    PRE_KERNEL_1, CONFIG_PWM_INIT_PRIORITY,	       \
 			    &pwm_npcx_driver_api);
 
 DT_INST_FOREACH_STATUS_OKAY(NPCX_PWM_INIT)
diff --git a/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig b/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig
index d40f36c573..e1abfacaea 100644
--- a/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig
+++ b/drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig
@@ -13,4 +13,32 @@ config ADC_CMP_NPCX
 	  This option enables threshold interruption using sensor
 	  trigger API.
 
+if ADC_CMP_NPCX
+
+config ADC_CMP_NPCX_WORKQUEUE
+	bool "NPCX ADC threshold detection uses internal work queue"
+	help
+	  Threshold detection ISR utilizes system work queue for calling
+	  trigger handlers; set this option to use dedicated work queue instead.
+
+if ADC_CMP_NPCX_WORKQUEUE
+
+config ADC_CMP_NPCX_WORKQUEUE_PRIORITY
+	int "Nuvoton NPCX ADC trheshold detection work queue priority"
+	default SYSTEM_WORKQUEUE_PRIORITY
+	help
+	  This option sets internal ADC NPCX threshold detection workqueue
+	  priority.
+
+config ADC_CMP_NPCX_WORKQUEUE_STACK_SIZE
+	int "Nuvoton NPCX ADC trheshold detection work queue stack size"
+	default 768
+	help
+	  This option sets internal ADC NPCX threshold detection workqueue
+	  stack size.
+
+endif # ADC_CMP_NPCX_WORKQUEUE
+
+endif # ADC_CMP_NPCX
+
 endif # ADC_NPCX
diff --git a/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c b/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c
index 900e91fe11..cba37069ce 100644
--- a/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c
+++ b/drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c
@@ -7,7 +7,7 @@
 #include <zephyr/drivers/sensor.h>
 #include <zephyr/drivers/adc/adc_npcx_threshold.h>
 #include <zephyr/drivers/sensor/adc_cmp_npcx.h>
-
+#include <zephyr/kernel.h>
 #include <zephyr/logging/log.h>
 
 LOG_MODULE_REGISTER(adc_cmp_npcx, CONFIG_SENSOR_LOG_LEVEL);
@@ -92,7 +92,7 @@ static int adc_cmp_npcx_init(const struct device *dev)
 	if (config->thr_mv != ADC_CMP_NPCX_UNDEFINED) {
 		param.type = ADC_NPCX_THRESHOLD_PARAM_THVAL;
 		/* Convert from millivolts to ADC raw register value */
-		ret = adc_npcx_threshold_mv_to_thrval(config->thr_mv,
+		ret = adc_npcx_threshold_mv_to_thrval(config->adc, config->thr_mv,
 						&param.val);
 		if (ret) {
 			goto init_error;
@@ -135,7 +135,7 @@ static int adc_cmp_npcx_set_threshold(const struct device *dev, bool is_upper,
 
 	param.type = ADC_NPCX_THRESHOLD_PARAM_THVAL;
 	if (is_mv) {
-		ret = adc_npcx_threshold_mv_to_thrval(value, &param.val);
+		ret = adc_npcx_threshold_mv_to_thrval(config->adc, value, &param.val);
 		if (ret) {
 			return ret;
 		}
@@ -251,20 +251,23 @@ static const struct sensor_driver_api adc_cmp_npcx_api = {
 	.channel_get = adc_cmp_npcx_channel_get,
 };
 
-#define NPCX_ADC_CMP_INIT(inst)                                               \
-	static struct adc_cmp_npcx_data adc_cmp_npcx_data_##inst;             \
-	static const struct adc_cmp_npcx_config adc_cmp_npcx_config_##inst = {\
-		.adc = DEVICE_DT_GET(DT_INST_IO_CHANNELS_CTLR(inst)),         \
-		.chnsel = DT_INST_IO_CHANNELS_INPUT(inst),                    \
-		.th_sel = inst,                                               \
-		.thr_mv = DT_INST_PROP_OR(inst, threshold_mv,                 \
-			ADC_CMP_NPCX_UNDEFINED),                              \
-		.comparison = DT_INST_STRING_TOKEN_OR(inst,                   \
-			comparison, ADC_CMP_NPCX_UNDEFINED)                   \
-	};                                                                    \
-	DEVICE_DT_INST_DEFINE(inst, adc_cmp_npcx_init, NULL,                  \
-			      &adc_cmp_npcx_data_##inst,                      \
-			      &adc_cmp_npcx_config_##inst, PRE_KERNEL_2,      \
-			      CONFIG_SENSOR_INIT_PRIORITY,                    \
-			      &adc_cmp_npcx_api);
+#define NPCX_ADC_CMP_INIT(inst)							\
+	static struct adc_cmp_npcx_data adc_cmp_npcx_data_##inst;		\
+	static const struct adc_cmp_npcx_config adc_cmp_npcx_config_##inst = {	\
+		.adc = DEVICE_DT_GET(DT_INST_IO_CHANNELS_CTLR(inst)),		\
+		.chnsel = DT_INST_IO_CHANNELS_INPUT(inst),			\
+		.th_sel = DT_INST_STRING_TOKEN_OR(inst, thr_sel, inst),		\
+		.thr_mv = DT_INST_PROP_OR(inst, threshold_mv,			\
+			ADC_CMP_NPCX_UNDEFINED),				\
+		.comparison = DT_INST_STRING_TOKEN_OR(inst,			\
+			comparison, ADC_CMP_NPCX_UNDEFINED)			\
+	};									\
+	SENSOR_DEVICE_DT_INST_DEFINE(inst, adc_cmp_npcx_init, NULL,		\
+			      &adc_cmp_npcx_data_##inst,			\
+			      &adc_cmp_npcx_config_##inst, POST_KERNEL,		\
+			      CONFIG_SENSOR_INIT_PRIORITY,			\
+			      &adc_cmp_npcx_api);				\
+	BUILD_ASSERT(DT_INST_STRING_TOKEN_OR(inst, thr_sel, inst) <		\
+		     DT_PROP(DT_INST_IO_CHANNELS_CTLR(inst), threshold_count),	\
+		     "Exceed the number of threshold detectors adc supports");
 DT_INST_FOREACH_STATUS_OKAY(NPCX_ADC_CMP_INIT)
diff --git a/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c b/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c
index 3efd363a90..b373d998b6 100644
--- a/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c
+++ b/drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c
@@ -176,7 +176,7 @@ static inline bool tach_npcx_is_captured(const struct device *dev)
 
 	LOG_DBG("port A is captured %d, port b is captured %d",
 		IS_BIT_SET(inst->TECTRL, NPCX_TECTRL_TAPND),
-		IS_BIT_SET(inst->TECTRL, NPCX_TECTRL_TAPND));
+		IS_BIT_SET(inst->TECTRL, NPCX_TECTRL_TBPND));
 
 	/*
 	 * In mode 5, the flag TAPND or TBPND indicates a input captured on
@@ -259,6 +259,8 @@ int tach_npcx_sample_fetch(const struct device *dev, enum sensor_channel chan)
 	if (tach_npcx_is_underflow(dev)) {
 		/* Clear pending flags */
 		tach_npcx_clear_underflow_flag(dev);
+		/* Clear stale captured data */
+		tach_npcx_clear_captured_flag(dev);
 		data->capture = 0;
 
 		return 0;
@@ -320,14 +322,14 @@ static int tach_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 							&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on tachometer clock fail %d", ret);
 		return ret;
 	}
 
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 					&config->clk_cfg, &data->input_clk);
 	if (ret < 0) {
 		LOG_ERR("Get tachometer clock rate error %d", ret);
@@ -380,7 +382,7 @@ static const struct sensor_driver_api tach_npcx_driver_api = {
 									       \
 	static struct tach_npcx_data tach_data_##inst;                         \
 									       \
-	DEVICE_DT_INST_DEFINE(inst,                                            \
+	SENSOR_DEVICE_DT_INST_DEFINE(inst,                                     \
 			      tach_npcx_init,                                  \
 			      NULL,                                            \
 			      &tach_data_##inst,                               \
diff --git a/drivers/serial/uart_npcx.c b/drivers/serial/uart_npcx.c
index c609a26026..84d197fab7 100644
--- a/drivers/serial/uart_npcx.c
+++ b/drivers/serial/uart_npcx.c
@@ -19,6 +19,7 @@
 #include "soc_power.h"
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(uart_npcx, CONFIG_UART_LOG_LEVEL);
 
 /* Driver config */
@@ -46,7 +47,8 @@ enum uart_pm_policy_state_flag {
 struct uart_npcx_data {
 	/* Baud rate */
 	uint32_t baud_rate;
-	struct miwu_dev_callback uart_rx_cb;
+	struct miwu_callback uart_rx_cb;
+	struct k_spinlock lock;
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
 	uart_irq_callback_user_data_t user_cb;
 	void *user_data;
@@ -59,7 +61,7 @@ struct uart_npcx_data {
 #endif
 };
 
-#if defined(CONFIG_PM) && defined(CONFIG_UART_INTERRUPT_DRIVEN)
+#ifdef CONFIG_PM
 static void uart_npcx_pm_policy_state_lock_get(struct uart_npcx_data *data,
 					       enum uart_pm_policy_state_flag flag)
 {
@@ -75,7 +77,7 @@ static void uart_npcx_pm_policy_state_lock_put(struct uart_npcx_data *data,
 		pm_policy_state_lock_put(PM_STATE_SUSPEND_TO_IDLE, PM_ALL_SUBSTATES);
 	}
 }
-#endif /* defined(CONFIG_PM) && defined(CONFIG_UART_INTERRUPT_DRIVEN) */
+#endif
 
 /* UART local functions */
 static int uart_set_npcx_baud_rate(struct uart_reg *const inst, int baud_rate, int src_clk)
@@ -105,7 +107,11 @@ static int uart_npcx_tx_fifo_ready(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* True if the Tx FIFO is not completely full */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return inst->UTXFLV != NPCK_SZ_UART_FIFO;
+#else
 	return !(GET_FIELD(inst->UFTSTS, NPCX_UFTSTS_TEMPTY_LVL) == 0);
+#endif
 }
 
 static int uart_npcx_rx_fifo_available(const struct device *dev)
@@ -114,7 +120,11 @@ static int uart_npcx_rx_fifo_available(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* True if at least one byte is in the Rx FIFO */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return inst->URXFLV != 0;
+#else
 	return IS_BIT_SET(inst->UFRSTS, NPCX_UFRSTS_RFIFO_NEMPTY_STS);
+#endif
 }
 
 static void uart_npcx_dis_all_tx_interrupts(const struct device *dev)
@@ -123,9 +133,13 @@ static void uart_npcx_dis_all_tx_interrupts(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* Disable all Tx interrupts */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL &= ~BIT(NPCX_UICTRL_ETI);
+#else
 	inst->UFTCTL &= ~(BIT(NPCX_UFTCTL_TEMPTY_LVL_EN) |
 			  BIT(NPCX_UFTCTL_TEMPTY_EN) |
 			  BIT(NPCX_UFTCTL_NXMIP_EN));
+#endif
 }
 
 static void uart_npcx_clear_rx_fifo(const struct device *dev)
@@ -143,21 +157,21 @@ static int uart_npcx_fifo_fill(const struct device *dev, const uint8_t *tx_data,
 {
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
+	struct uart_npcx_data *data = dev->data;
 	uint8_t tx_bytes = 0U;
+	k_spinlock_key_t key = k_spin_lock(&data->lock);
 
 	/* If Tx FIFO is still ready to send */
 	while ((size - tx_bytes > 0) && uart_npcx_tx_fifo_ready(dev)) {
 		/* Put a character into Tx FIFO */
-#ifdef CONFIG_PM
-		struct uart_npcx_data *data = dev->data;
-
-		uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_TX_FLAG);
-		inst->UTBUF = tx_data[tx_bytes++];
-		inst->UFTCTL |= BIT(NPCX_UFTCTL_NXMIP_EN);
-#else
 		inst->UTBUF = tx_data[tx_bytes++];
-#endif /* CONFIG_PM */
 	}
+#ifdef CONFIG_PM
+	uart_npcx_pm_policy_state_lock_get(data, UART_PM_POLICY_STATE_TX_FLAG);
+	/* Enable NXMIP interrupt in case ec enters deep sleep early */
+	inst->UFTCTL |= BIT(NPCX_UFTCTL_NXMIP_EN);
+#endif /* CONFIG_PM */
+	k_spin_unlock(&data->lock, key);
 
 	return tx_bytes;
 }
@@ -182,7 +196,15 @@ static void uart_npcx_irq_tx_enable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL |= BIT(NPCX_UICTRL_ETI);
+#else
+	struct uart_npcx_data *data = dev->data;
+	k_spinlock_key_t key = k_spin_lock(&data->lock);
+
 	inst->UFTCTL |= BIT(NPCX_UFTCTL_TEMPTY_EN);
+	k_spin_unlock(&data->lock, key);
+#endif
 }
 
 static void uart_npcx_irq_tx_disable(const struct device *dev)
@@ -190,12 +212,32 @@ static void uart_npcx_irq_tx_disable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL &= ~(BIT(NPCX_UICTRL_ETI));
+#else
+	struct uart_npcx_data *data = dev->data;
+	k_spinlock_key_t key = k_spin_lock(&data->lock);
+
 	inst->UFTCTL &= ~(BIT(NPCX_UFTCTL_TEMPTY_EN));
+	k_spin_unlock(&data->lock, key);
+#endif
+}
+
+static bool uart_npcx_irq_tx_is_enabled(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_ETI);
+#else
+	return IS_BIT_SET(inst->UFTCTL, NPCX_UFTCTL_TEMPTY_EN);
+#endif
 }
 
 static int uart_npcx_irq_tx_ready(const struct device *dev)
 {
-	return uart_npcx_tx_fifo_ready(dev);
+	return uart_npcx_tx_fifo_ready(dev) && uart_npcx_irq_tx_is_enabled(dev);
 }
 
 static int uart_npcx_irq_tx_complete(const struct device *dev)
@@ -204,7 +246,11 @@ static int uart_npcx_irq_tx_complete(const struct device *dev)
 	struct uart_reg *const inst = config->inst;
 
 	/* Tx FIFO is empty or last byte is sending */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return inst->UTXFLV == 0;
+#else
 	return IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP);
+#endif
 }
 
 static void uart_npcx_irq_rx_enable(const struct device *dev)
@@ -212,7 +258,11 @@ static void uart_npcx_irq_rx_enable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL |= BIT(NPCX_UICTRL_ERI);
+#else
 	inst->UFRCTL |= BIT(NPCX_UFRCTL_RNEMPTY_EN);
+#endif
 }
 
 static void uart_npcx_irq_rx_disable(const struct device *dev)
@@ -220,7 +270,23 @@ static void uart_npcx_irq_rx_disable(const struct device *dev)
 	const struct uart_npcx_config *const config = dev->config;
 	struct uart_reg *const inst = config->inst;
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UICTRL &= ~(BIT(NPCX_UICTRL_ERI));
+#else
 	inst->UFRCTL &= ~(BIT(NPCX_UFRCTL_RNEMPTY_EN));
+#endif
+}
+
+static bool uart_npcx_irq_rx_is_enabled(const struct device *dev)
+{
+	const struct uart_npcx_config *const config = dev->config;
+	struct uart_reg *const inst = config->inst;
+
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	return IS_BIT_SET(inst->UICTRL, NPCX_UICTRL_ERI);
+#else
+	return IS_BIT_SET(inst->UFRCTL, NPCX_UFRCTL_RNEMPTY_EN);
+#endif
 }
 
 static int uart_npcx_irq_rx_ready(const struct device *dev)
@@ -246,7 +312,8 @@ static void uart_npcx_irq_err_disable(const struct device *dev)
 
 static int uart_npcx_irq_is_pending(const struct device *dev)
 {
-	return (uart_npcx_irq_tx_ready(dev) || uart_npcx_irq_rx_ready(dev));
+	return uart_npcx_irq_tx_ready(dev) ||
+		(uart_npcx_irq_rx_ready(dev) && uart_npcx_irq_rx_is_enabled(dev));
 }
 
 static int uart_npcx_irq_update(const struct device *dev)
@@ -291,8 +358,12 @@ static void uart_npcx_isr(const struct device *dev)
 
 	if (IS_BIT_SET(inst->UFTCTL, NPCX_UFTCTL_NXMIP_EN) &&
 	    IS_BIT_SET(inst->UFTSTS, NPCX_UFTSTS_NXMIP)) {
-		uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_TX_FLAG);
+		k_spinlock_key_t key = k_spin_lock(&data->lock);
+
+		/* Disable NXMIP interrupt */
 		inst->UFTCTL &= ~BIT(NPCX_UFTCTL_NXMIP_EN);
+		k_spin_unlock(&data->lock, key);
+		uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_TX_FLAG);
 	}
 #endif /* CONFIG_PM */
 }
@@ -395,8 +466,9 @@ static __unused void uart_npcx_rx_wk_isr(const struct device *dev, struct npcx_w
 #ifdef CONFIG_UART_CONSOLE_INPUT_EXPIRED
 static void uart_npcx_rx_refresh_timeout(struct k_work *work)
 {
+	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 	struct uart_npcx_data *data =
-		CONTAINER_OF(work, struct uart_npcx_data, rx_refresh_timeout_work);
+		CONTAINER_OF(dwork, struct uart_npcx_data, rx_refresh_timeout_work);
 
 	uart_npcx_pm_policy_state_lock_put(data, UART_PM_POLICY_STATE_RX_FLAG);
 }
@@ -440,7 +512,7 @@ static int uart_npcx_init(const struct device *dev)
 	}
 
 	/* Turn on device clock first and get source clock freq. */
-	ret = clock_control_on(clk_dev, (clock_control_subsys_t *)&config->clk_cfg);
+	ret = clock_control_on(clk_dev, (clock_control_subsys_t)&config->clk_cfg);
 	if (ret < 0) {
 		LOG_ERR("Turn on UART clock fail %d", ret);
 		return ret;
@@ -450,7 +522,7 @@ static int uart_npcx_init(const struct device *dev)
 	 * If apb2's clock is not 15MHz, we need to find the other optimized
 	 * values of UPSR and UBAUD for baud rate 115200.
 	 */
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)&config->clk_cfg,
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)&config->clk_cfg,
 				     &uart_rate);
 	if (ret < 0) {
 		LOG_ERR("Get UART clock rate error %d", ret);
@@ -473,8 +545,12 @@ static int uart_npcx_init(const struct device *dev)
 
 	/* Initialize UART FIFO if mode is interrupt driven */
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->UFCTRL |= BIT(NPCK_FIFO_EN);
+#else
 	/* Enable the UART FIFO mode */
 	inst->UMDSL |= BIT(NPCX_UMDSL_FIFO_MD);
+#endif
 
 	/* Disable all UART tx FIFO interrupts */
 	uart_npcx_dis_all_tx_interrupts(dev);
@@ -490,7 +566,7 @@ static int uart_npcx_init(const struct device *dev)
 		/* Initialize a miwu device input and its callback function */
 		npcx_miwu_init_dev_callback(&data->uart_rx_cb, &config->uart_rx_wui,
 					    uart_npcx_rx_wk_isr, dev);
-		npcx_miwu_manage_dev_callback(&data->uart_rx_cb, true);
+		npcx_miwu_manage_callback(&data->uart_rx_cb, true);
 		/*
 		 * Configure the UART wake-up event triggered from a falling
 		 * edge on CR_SIN pin. No need for callback function.
diff --git a/drivers/spi/CMakeLists.txt b/drivers/spi/CMakeLists.txt
index 58e28804ac..a848904ef8 100644
--- a/drivers/spi/CMakeLists.txt
+++ b/drivers/spi/CMakeLists.txt
@@ -25,7 +25,7 @@ zephyr_library_sources_ifdef(CONFIG_SPI_XLNX_AXI_QUADSPI spi_xlnx_axi_quadspi.c)
 zephyr_library_sources_ifdef(CONFIG_ESP32_SPIM		spi_esp32_spim.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_TEST		spi_test.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_PSOC6		spi_psoc6.c)
-zephyr_library_sources_ifdef(CONFIG_SPI_NPCX_FIU	spi_npcx_fiu.c)
+# zephyr_library_sources_ifdef(CONFIG_SPI_NPCX_FIU	spi_npcx_fiu.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_BITBANG		spi_bitbang.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_XEC_QMSPI_LDMA	spi_xec_qmspi_ldma.c)
 zephyr_library_sources_ifdef(CONFIG_SPI_GD32		spi_gd32.c)
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 4d028b05c8..9739824530 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -93,7 +93,7 @@ source "drivers/spi/Kconfig.test"
 
 source "drivers/spi/Kconfig.psoc6"
 
-source "drivers/spi/Kconfig.npcx_fiu"
+# source "drivers/spi/Kconfig.npcx_fiu"
 
 source "drivers/spi/Kconfig.bitbang"
 
diff --git a/drivers/timer/npcx_itim_timer.c b/drivers/timer/npcx_itim_timer.c
index a6eb113c6f..590b9d25ba 100644
--- a/drivers/timer/npcx_itim_timer.c
+++ b/drivers/timer/npcx_itim_timer.c
@@ -34,14 +34,16 @@
  *   "sleep/deep sleep" power state if CONFIG_PM is enabled.
  */
 
-#include <zephyr/device.h>
+#include <zephyr/init.h>
 #include <zephyr/drivers/clock_control.h>
 #include <zephyr/drivers/timer/system_timer.h>
+#include <zephyr/kernel.h>
 #include <zephyr/sys_clock.h>
 #include <zephyr/spinlock.h>
 #include <soc.h>
 
 #include <zephyr/logging/log.h>
+#include <zephyr/irq.h>
 LOG_MODULE_REGISTER(itim, LOG_LEVEL_ERR);
 
 #define NPCX_ITIM32_MAX_CNT 0xffffffff
@@ -301,9 +303,8 @@ uint64_t npcx_clock_get_sleep_ticks(void)
 }
 #endif /* CONFIG_PM */
 
-static int sys_clock_driver_init(const struct device *dev)
+static int sys_clock_driver_init(void)
 {
-	ARG_UNUSED(dev);
 	int ret;
 	uint32_t sys_tmr_rate;
 	const struct device *const clk_dev = DEVICE_DT_GET(NPCX_CLK_CTRL_NODE);
@@ -315,7 +316,7 @@ static int sys_clock_driver_init(const struct device *dev)
 
 	/* Turn on all itim module clocks used for counting */
 	for (int i = 0; i < ARRAY_SIZE(itim_clk_cfg); i++) {
-		ret = clock_control_on(clk_dev, (clock_control_subsys_t *)
+		ret = clock_control_on(clk_dev, (clock_control_subsys_t)
 				&itim_clk_cfg[i]);
 		if (ret < 0) {
 			LOG_ERR("Turn on timer %d clock failed.", i);
@@ -327,7 +328,7 @@ static int sys_clock_driver_init(const struct device *dev)
 	 * In npcx series, we use ITIM64 as system kernel timer. Its source
 	 * clock frequency must equal to CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC.
 	 */
-	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t *)
+	ret = clock_control_get_rate(clk_dev, (clock_control_subsys_t)
 			&itim_clk_cfg[1], &sys_tmr_rate);
 	if (ret < 0) {
 		LOG_ERR("Get ITIM64 clock rate failed %d", ret);
diff --git a/drivers/watchdog/wdt_npcx.c b/drivers/watchdog/wdt_npcx.c
index 52df7c5866..b34cf13386 100644
--- a/drivers/watchdog/wdt_npcx.c
+++ b/drivers/watchdog/wdt_npcx.c
@@ -28,14 +28,18 @@
  *
  */
 
+#include "soc_miwu.h"
+
 #include <assert.h>
-#include <zephyr/drivers/gpio.h>
+
 #include <zephyr/drivers/clock_control.h>
+#include <zephyr/drivers/gpio.h>
 #include <zephyr/drivers/watchdog.h>
-#include <soc.h>
-
-#include "soc_miwu.h"
+#include <zephyr/kernel.h>
 #include <zephyr/logging/log.h>
+
+#include <soc.h>
+#include "soc_dbg.h"
 LOG_MODULE_REGISTER(wdt_npcx, CONFIG_WDT_LOG_LEVEL);
 
 /* Watchdog operating frequency is fixed to LFCLK (32.768) kHz */
@@ -79,7 +83,7 @@ struct wdt_npcx_data {
 	bool timeout_installed;
 };
 
-struct miwu_dev_callback miwu_cb;
+struct miwu_callback miwu_cb;
 
 /* Driver convenience defines */
 #define HAL_INSTANCE(dev) ((struct twd_reg *)((const struct wdt_npcx_config *)(dev)->config)->base)
@@ -150,7 +154,7 @@ static void wdt_config_t0out_interrupt(const struct device *dev)
 	/* Initialize a miwu device input and its callback function */
 	npcx_miwu_init_dev_callback(&miwu_cb, &config->t0out, wdt_t0out_isr,
 			dev);
-	npcx_miwu_manage_dev_callback(&miwu_cb, true);
+	npcx_miwu_manage_callback(&miwu_cb, true);
 
 	/*
 	 * Configure the T0 wake-up event triggered from a rising edge
@@ -224,20 +228,22 @@ static int wdt_npcx_setup(const struct device *dev, uint8_t options)
 		return -ENOTSUP;
 	}
 
+	/* Stall the WDT counter when halted by debugger */
 	if ((options & WDT_OPT_PAUSE_HALTED_BY_DBG) != 0) {
-		LOG_ERR("WDT_OPT_PAUSE_HALTED_BY_DBG is not supported");
-		return -ENOTSUP;
+		npcx_dbg_freeze_enable(true);
+	} else {
+		npcx_dbg_freeze_enable(false);
 	}
 
 	/*
 	 * One clock period of T0 timer is 32/32.768 KHz = 0.976 ms.
 	 * Then the counter value is timeout/0.976 - 1.
 	 */
-	inst->TWDT0 = MAX(ceiling_fraction(data->timeout * NPCX_WDT_CLK,
+	inst->TWDT0 = MAX(DIV_ROUND_UP(data->timeout * NPCX_WDT_CLK,
 				32 * 1000) - 1, 1);
 
 	/* Configure 8-bit watchdog counter */
-	inst->WDCNT = MIN(ceiling_fraction(data->timeout, 32) +
+	inst->WDCNT = MIN(DIV_ROUND_UP(data->timeout, 32) +
 					CONFIG_WDT_NPCX_DELAY_CYCLES, 0xff);
 
 	LOG_DBG("WDT setup: TWDT0, WDCNT are %d, %d", inst->TWDT0, inst->WDCNT);
@@ -337,6 +343,10 @@ static int wdt_npcx_init(const struct device *dev)
 	inst->WDCP = 0x05; /* Prescaler is 32 in Watchdog Timer */
 	inst->TWCP = 0x05; /* Prescaler is 32 in T0 Timer */
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst->T0CSR |= BIT(NPCX_T0CSR_T0EN); /* enable T0OUT */
+#endif
+
 	return 0;
 }
 
diff --git a/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi b/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi
index c662131f23..c242d74752 100644
--- a/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx-lvol-ctrl-map.dtsi
@@ -130,7 +130,7 @@
 		 * low voltage detection.)
 		 */
 		lvol_none: lvol-pseudo {
-			lvols = <&scfg 6 0>;
+			lvols = <&scfg 31 0>;
 		};
 	};
 };
diff --git a/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi b/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi
index f71349e805..e1a1266a48 100644
--- a/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi
+++ b/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi
@@ -23,9 +23,6 @@
 		wui_io83: wui0-1-3 {
 			miwus = <&miwu0 0 3>; /* GPIO83 */
 		};
-		wui_cr_sin2: wui0-1-6-2 {
-			miwus = <&miwu0 0 6>; /* CR_SIN2 */
-		};
 		wui_io87: wui0-1-7 {
 			miwus = <&miwu0 0 7>; /* GPIO87 */
 		};
diff --git a/dts/arm/nuvoton/npcx/npcx.dtsi b/dts/arm/nuvoton/npcx/npcx.dtsi
new file mode 100644
index 0000000000..bbb3ef3923
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx.dtsi
@@ -0,0 +1,681 @@
+/*
+ * Copyright (c) 2021 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <arm/armv7-m.dtsi>
+
+/* Macros for device tree declarations of npcx soc family */
+#include <zephyr/dt-bindings/adc/adc.h>
+#include <zephyr/dt-bindings/clock/npcx_clock.h>
+#include <zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h>
+#include <zephyr/dt-bindings/gpio/gpio.h>
+#include <zephyr/dt-bindings/i2c/i2c.h>
+#include <zephyr/dt-bindings/pinctrl/npcx-pinctrl.h>
+#include <zephyr/dt-bindings/pwm/pwm.h>
+#include <zephyr/dt-bindings/sensor/npcx_tach.h>
+#include <freq.h>
+
+/ {
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-m4f";
+			reg = <0>;
+			cpu-power-states = <&suspend_to_idle0 &suspend_to_idle1>;
+		};
+
+		power-states {
+			suspend_to_idle0: suspend-to-idle0 {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-idle";
+				substate-id = <0>;
+				min-residency-us = <1000>;
+			};
+
+			suspend_to_idle1: suspend-to-idle1 {
+				compatible = "zephyr,power-state";
+				power-state-name = "suspend-to-idle";
+				substate-id = <1>;
+				min-residency-us = <201000>;
+			};
+		};
+	};
+
+	def-io-conf-list {
+		compatible = "nuvoton,npcx-pinctrl-def";
+		/* Change default functional pads to GPIOs
+		 * no_spip - PIN95.97.A1.A3
+		 * no_fpip - PIN96.A0.A2.A4 - Internal flash only
+		 * no_pwrgd - PIN72
+		 * no_lpc_espi - PIN46.47.51.52.53.54.55.57
+		 * no_peci_en - PIN81
+		 * npsl_in1_sl - PIND2
+		 * npsl_in2_sl - PIN00
+		 * no_ksi0-7 - PIN31.30.27.26.25.24.23.22
+		 * no_ks000-17 - PIN21.20.17.16.15.14.13.12.11.10.07.06.05.04.
+		 *                  82.83.03.B1
+		 */
+		pinmux = <>;
+	};
+
+	/** Dummy pinctrl node. It will be initialized with defaults based on the SoC series.
+	 *  Then, the user can override the pin control options at the board level.
+	 */
+	pinctrl: pinctrl {
+		compatible = "nuvoton,npcx-pinctrl";
+		status = "okay";
+	};
+
+	/* Dummy node of IOs that have leakage current. The user can override
+	 * 'leak-gpios' prop. at board DT file to save more power consumption.
+	 */
+	power_leakage_io: power-leakage-io {
+		compatible = "nuvoton,npcx-leakage-io";
+		status = "okay";
+	};
+
+	soc {
+		bbram: bb-ram@400af000 {
+			compatible = "nuvoton,npcx-bbram";
+			reg = <0x400af000 0x80
+			       0x400af100 0x1>;
+			reg-names = "memory", "status";
+		};
+
+		pcc: clock-controller@4000d000 {
+			compatible = "nuvoton,npcx-pcc";
+			/* Cells for bus type, clock control reg and bit */
+			#clock-cells = <3>;
+			/* First reg region is Power Management Controller */
+			/* Second reg region is Core Domain Clock Generator */
+			reg = <0x4000d000 0x2000
+			       0x400b5000 0x2000>;
+			reg-names = "pmc", "cdcg";
+		};
+
+		scfg: scfg@400c3000 {
+			compatible = "nuvoton,npcx-scfg";
+			/* First reg region is System Configuration Device */
+			/* Second reg region is Debugger Interface Device */
+			/* Third reg region is System Glue Device */
+			reg = <0x400c3000 0x70
+			       0x400c3070 0x30
+			       0x400a5000 0x2000>;
+			reg-names = "scfg", "dbg", "glue";
+			#alt-cells = <3>;
+			#lvol-cells = <2>;
+		};
+
+		mdc: mdc@4000c000 {
+			compatible = "syscon";
+			reg = <0x4000c000 0xa>;
+			reg-io-width = <1>;
+		};
+
+		mdc_header: mdc@4000c00a {
+			compatible = "syscon";
+			reg = <0x4000c00a 0x4>;
+			reg-io-width = <2>;
+		};
+
+		miwu0: miwu@400bb000 {
+			compatible = "nuvoton,npcx-miwu";
+			reg = <0x400bb000 0x2000>;
+			index = <0>;
+			#miwu-cells = <2>;
+		};
+
+		miwu1: miwu@400bd000 {
+			compatible = "nuvoton,npcx-miwu";
+			reg = <0x400bd000 0x2000>;
+			index = <1>;
+			#miwu-cells = <2>;
+		};
+
+		miwu2: miwu@400bf000 {
+			compatible = "nuvoton,npcx-miwu";
+			reg = <0x400bf000 0x2000>;
+			index = <2>;
+			#miwu-cells = <2>;
+		};
+
+		gpio0: gpio@40081000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40081000 0x2000>;
+			gpio-controller;
+			index = <0x0>;
+			#gpio-cells=<2>;
+		};
+
+		gpio1: gpio@40083000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40083000 0x2000>;
+			gpio-controller;
+			index = <0x1>;
+			#gpio-cells=<2>;
+		};
+
+		gpio2: gpio@40085000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40085000 0x2000>;
+			gpio-controller;
+			index = <0x2>;
+			#gpio-cells=<2>;
+		};
+
+		gpio3: gpio@40087000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40087000 0x2000>;
+			gpio-controller;
+			index = <0x3>;
+			#gpio-cells=<2>;
+		};
+
+		gpio4: gpio@40089000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40089000 0x2000>;
+			gpio-controller;
+			index = <0x4>;
+			#gpio-cells=<2>;
+		};
+
+		gpio5: gpio@4008b000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4008b000 0x2000>;
+			gpio-controller;
+			index = <0x5>;
+			#gpio-cells=<2>;
+		};
+
+		gpio6: gpio@4008d000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4008d000 0x2000>;
+			gpio-controller;
+			index = <0x6>;
+			#gpio-cells=<2>;
+		};
+
+		gpio7: gpio@4008f000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4008f000 0x2000>;
+			gpio-controller;
+			index = <0x7>;
+			#gpio-cells=<2>;
+		};
+
+		gpio8: gpio@40091000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40091000 0x2000>;
+			gpio-controller;
+			index = <0x8>;
+			#gpio-cells=<2>;
+		};
+
+		gpio9: gpio@40093000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40093000 0x2000>;
+			gpio-controller;
+			index = <0x9>;
+			#gpio-cells=<2>;
+		};
+
+		gpioa: gpio@40095000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40095000 0x2000>;
+			gpio-controller;
+			index = <0xA>;
+			#gpio-cells=<2>;
+		};
+
+		gpiob: gpio@40097000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40097000 0x2000>;
+			gpio-controller;
+			index = <0xB>;
+			#gpio-cells=<2>;
+		};
+
+		gpioc: gpio@40099000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x40099000 0x2000>;
+			gpio-controller;
+			index = <0xC>;
+			#gpio-cells=<2>;
+		};
+
+		gpiod: gpio@4009b000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4009b000 0x2000>;
+			gpio-controller;
+			index = <0xD>;
+			#gpio-cells=<2>;
+		};
+
+		gpioe: gpio@4009d000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4009d000 0x2000>;
+			gpio-controller;
+			index = <0xE>;
+			#gpio-cells=<2>;
+		};
+
+		gpiof: gpio@4009f000 {
+			compatible = "nuvoton,npcx-gpio";
+			reg = <0x4009f000 0x2000>;
+			gpio-controller;
+			index = <0xF>;
+			#gpio-cells=<2>;
+		};
+
+		pwm0: pwm@40080000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40080000 0x2000>;
+			pwm-channel = <0>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 0>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm1: pwm@40082000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40082000 0x2000>;
+			pwm-channel = <1>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 1>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm2: pwm@40084000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40084000 0x2000>;
+			pwm-channel = <2>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 2>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm3: pwm@40086000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40086000 0x2000>;
+			pwm-channel = <3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 3>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm4: pwm@40088000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x40088000 0x2000>;
+			pwm-channel = <4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 4>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm5: pwm@4008a000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x4008a000 0x2000>;
+			pwm-channel = <5>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 5>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm6: pwm@4008c000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x4008c000 0x2000>;
+			pwm-channel = <6>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 6>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		pwm7: pwm@4008e000 {
+			compatible = "nuvoton,npcx-pwm";
+			reg = <0x4008e000 0x2000>;
+			pwm-channel = <7>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL2 7>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+		adc0: adc@400d1000 {
+			compatible = "nuvoton,npcx-adc";
+			#io-channel-cells = <1>;
+			reg = <0x400d1000 0x2000>;
+			interrupts = <10 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB1 NPCX_PWDWN_CTL4 4>;
+			vref-mv = <2816>;
+			status = "disabled";
+		};
+
+		twd0: watchdog@400d8000 {
+			compatible = "nuvoton,npcx-watchdog";
+			reg = <0x400d8000 0x2000>;
+			t0-out = <&wui_t0out>;
+		};
+
+		espi0: espi@4000a000 {
+			compatible = "nuvoton,npcx-espi";
+			reg = <0x4000a000 0x2000>;
+			interrupts = <18 3>; /* Interrupt for eSPI Bus */
+
+			/* clocks for eSPI modules */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL6 7>;
+			/* WUI maps for eSPI signals */
+			espi-rst-wui = <&wui_espi_rst>;
+			rx-plsize = <64>;
+			tx-plsize = <16>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#vw-cells = <3>;
+			status = "disabled";
+		};
+
+		shi0: shi@4000f000 {
+			compatible = "nuvoton,npcx-shi";
+			reg = <0x4000f000 0x120>;
+			interrupts = <18 1>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 1>;
+			status = "disabled";
+			buffer-rx-size = <128>;
+			buffer-tx-size = <128>;
+		};
+
+		host_sub: lpc@400c1000 {
+			compatible = "nuvoton,npcx-host-sub";
+			/* host sub-module register address & size */
+			reg = <0x400c1000 0x2000
+			       0x40010000 0x2000
+			       0x4000e000 0x2000
+			       0x400c7000 0x2000
+			       0x400c9000 0x2000
+			       0x400cb000 0x2000>;
+			reg-names = "mswc", "shm", "c2h", "kbc", "pm_acpi",
+				    "pm_hcmd";
+
+			/* host sub-module IRQ and priority */
+			interrupts = <25 3>, /* KBC Input-Buf-Full (IBF) */
+				     <56 3>, /* KBC Output-Buf-Empty (OBE) */
+				     <26 3>, /* PMCH Input-Buf-Full (IBF) */
+				     <3 3>,  /* PMCH Output-Buf-Empty (OBE) */
+				     <6 3>;  /* Port80 FIFO Not Empty */
+			interrupt-names = "kbc_ibf", "kbc_obe", "pmch_ibf",
+					  "pmch_obe", "p80_fifo";
+
+			/* WUI map for accessing host sub-modules */
+			host-acc-wui = <&wui_host_acc>;
+
+			/* clocks for host sub-modules */
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 3>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 4>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 5>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 6>,
+				<&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL5 7>;
+		};
+
+		/* I2c Controllers - Do not use them as i2c node directly */
+		i2c_ctrl0: i2c@40009000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40009000 0x1000>;
+			interrupts = <13 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL3 0>;
+			status = "disabled";
+		};
+
+		i2c_ctrl1: i2c@4000b000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x4000b000 0x1000>;
+			interrupts = <14 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL3 1>;
+			status = "disabled";
+		};
+
+		i2c_ctrl2: i2c@400c0000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x400c0000 0x1000>;
+			interrupts = <36 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL3 2>;
+			status = "disabled";
+		};
+
+		i2c_ctrl3: i2c@400c2000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x400c2000 0x1000>;
+			interrupts = <37 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL3 3>;
+			status = "disabled";
+		};
+
+		i2c_ctrl4: i2c@40008000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40008000 0x1000>;
+			interrupts = <19 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL3 4>;
+			status = "disabled";
+		};
+
+		i2c_ctrl5: i2c@40017000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40017000 0x1000>;
+			interrupts = <20 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL7 0>;
+			status = "disabled";
+		};
+
+		i2c_ctrl6: i2c@40018000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40018000 0x1000>;
+			interrupts = <16 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL7 1>;
+			status = "disabled";
+		};
+
+		i2c_ctrl7: i2c@40019000 {
+			compatible = "nuvoton,npcx-i2c-ctrl";
+			reg = <0x40019000 0x1000>;
+			interrupts = <8 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB3 NPCX_PWDWN_CTL7 2>;
+			status = "disabled";
+		};
+
+		tach1: tach@400e1000 {
+			compatible = "nuvoton,npcx-tach";
+			reg = <0x400e1000 0x2000>;
+			clocks = <&pcc NPCX_CLOCK_BUS_LFCLK NPCX_PWDWN_CTL1 5>;
+			status = "disabled";
+		};
+
+		tach2: tach@400e3000 {
+			compatible = "nuvoton,npcx-tach";
+			reg = <0x400e3000 0x2000>;
+			clocks = <&pcc NPCX_CLOCK_BUS_LFCLK NPCX_PWDWN_CTL1 6>;
+			status = "disabled";
+		};
+
+		ps2_ctrl0: ps2@400b1000 {
+			compatible = "nuvoton,npcx-ps2-ctrl";
+			reg = <0x400b1000 0x1000>;
+			interrupts = <21 4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_FREERUN NPCX_PWDWN_CTL1 3>;
+
+			/* PS2 Channels - Please use them as PS2 node */
+			ps2_channel0: io_ps2_channel0 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x00>;
+				status = "disabled";
+			};
+
+			ps2_channel1: io_ps2_channel1 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x01>;
+				status = "disabled";
+			};
+
+			ps2_channel2: io_ps2_channel2 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x02>;
+				status = "disabled";
+			};
+
+			ps2_channel3: io_ps2_channel3 {
+				compatible = "nuvoton,npcx-ps2-channel";
+				channel = <0x03>;
+				status = "disabled";
+			};
+		};
+
+		/* Dedicated Quad-SPI interface to access SPI flashes */
+		qspi_fiu0: quadspi@40020000 {
+			compatible = "nuvoton,npcx-fiu-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x40020000 0x2000>;
+		};
+
+		peci0: peci@400d4000 {
+			compatible = "nuvoton,npcx-peci";
+			reg = <0x400d4000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <4 4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_FMCLK NPCX_PWDWN_CTL4 5>;
+			status = "disabled";
+		};
+
+		kbd: kbd@400a3000 {
+			compatible = "nuvoton,npcx-kbd";
+			reg = <0x400a3000 0x2000>;
+			interrupts = <49 4>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB1 NPCX_PWDWN_CTL1 0>;
+			wui-maps = <&wui_io31 &wui_io30 &wui_io27 &wui_io26
+				    &wui_io25 &wui_io24 &wui_io23 &wui_io22>;
+			status = "disabled";
+		};
+	};
+
+	soc-if {
+		/* Soc specific peripheral interface phandles which don't contain
+		 * 'reg' prop. Please overwrite 'status' prop. to 'okay' if you
+		 * want to switch the interface from io to specific peripheral.
+		 */
+		host_uart: io_host_uart {
+			compatible = "nuvoton,npcx-host-uart";
+			status = "disabled";
+		};
+
+		i2c0_0: io_i2c_ctrl0_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x00>;
+			controller = <&i2c_ctrl0>;
+			status = "disabled";
+		};
+
+		i2c1_0: io_i2c_ctrl1_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x10>;
+			controller = <&i2c_ctrl1>;
+			status = "disabled";
+		};
+
+		i2c2_0: io_i2c_ctrl2_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x20>;
+			controller = <&i2c_ctrl2>;
+			status = "disabled";
+		};
+
+		i2c3_0: io_i2c_ctrl3_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x30>;
+			controller = <&i2c_ctrl3>;
+			status = "disabled";
+		};
+
+		i2c4_1: io_i2c_ctrl4_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x41>;
+			controller = <&i2c_ctrl4>;
+			status = "disabled";
+		};
+
+		i2c5_0: io_i2c_ctrl5_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x50>;
+			controller = <&i2c_ctrl5>;
+			status = "disabled";
+		};
+
+		i2c5_1: io_i2c_ctrl5_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x51>;
+			controller = <&i2c_ctrl5>;
+			status = "disabled";
+		};
+
+		i2c6_0: io_i2c_ctrl6_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x60>;
+			controller = <&i2c_ctrl6>;
+			status = "disabled";
+		};
+
+		i2c6_1: io_i2c_ctrl6_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x61>;
+			controller = <&i2c_ctrl6>;
+			status = "disabled";
+		};
+
+		i2c7_0: io_i2c_ctrl7_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x70>;
+			controller = <&i2c_ctrl7>;
+			status = "disabled";
+		};
+
+		power_ctrl_psl: power-ctrl-psl {
+			compatible = "nuvoton,npcx-power-psl";
+			status = "disabled";
+		};
+	};
+
+	soc-id {
+		compatible = "nuvoton,npcx-soc-id";
+		family-id = <0x20>;
+	};
+
+	booter-variant {
+		compatible = "nuvoton,npcx-booter-variant";
+	};
+};
+
+&nvic {
+	arm,num-irq-priority-bits = <3>;
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4.dtsi b/dts/arm/nuvoton/npcx/npcx4.dtsi
new file mode 100644
index 0000000000..a01d5d69ab
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4.dtsi
@@ -0,0 +1,325 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* npcx4 series pinmux mapping table */
+#include "npcx4/npcx4-alts-map.dtsi"
+/* npcx4 series mapping table between MIWU wui bits and source device */
+#include "npcx4/npcx4-miwus-wui-map.dtsi"
+/* npcx4 series mapping table between MIWU groups and interrupts */
+#include "npcx4/npcx4-miwus-int-map.dtsi"
+/* npcx4 series eSPI VW mapping table */
+#include "npcx4/npcx4-espi-vws-map.dtsi"
+/* npcx4 series low-voltage io controls mapping table */
+#include "npcx4/npcx4-lvol-ctrl-map.dtsi"
+
+/* Device tree declarations of npcx soc family */
+#include "npcx.dtsi"
+
+/ {
+	def-io-conf-list {
+		pinmux = <&alt0_gpio_no_spip
+			  &alt0_gpio_no_fpip
+			  &alt1_no_pwrgd
+			  &alt7_no_ksi0_sl
+			  &alt7_no_ksi1_sl
+			  &alt7_no_ksi2_sl
+			  &alt7_no_ksi3_sl
+			  &alt7_no_ksi4_sl
+			  &alt7_no_ksi5_sl
+			  &alt7_no_ksi6_sl
+			  &alt7_no_ksi7_sl
+			  &alt8_no_kso00_sl
+			  &alt8_no_kso01_sl
+			  &alt8_no_kso02_sl
+			  &alt8_no_kso03_sl
+			  &alt8_no_kso04_sl
+			  &alt8_no_kso05_sl
+			  &alt8_no_kso06_sl
+			  &alt8_no_kso07_sl
+			  &alt9_no_kso08_sl
+			  &alt9_no_kso09_sl
+			  &alt9_no_kso10_sl
+			  &alt9_no_kso11_sl
+			  &alt9_no_kso12_sl
+			  &alt9_no_kso13_sl
+			  &alt9_no_kso14_sl
+			  &alt9_no_kso15_sl
+			  &alta_no_kso16_sl
+			  &alta_no_kso17_sl
+			  &alta_no_peci_en
+			  &altc_gpio97_sl_inv
+			  &altd_npsl_in1_sl
+			  &altd_npsl_in2_sl
+			  &altd_psl_in3_sl
+			  &altd_psl_in4_sl
+			  &altg_psl_gpo_sl>;
+	};
+
+	soc {
+		compatible = "nuvoton,npcx4", "nuvoton,npcx", "simple-bus";
+
+		/* Specific soc devices in npcx4 series */
+		itims: timer@400b0000 {
+			compatible = "nuvoton,npcx-itim-timer";
+			reg = <0x400b0000 0x2000
+			       0x400be000 0x2000>;
+			reg-names = "evt_itim", "sys_itim";
+			clocks = <&pcc NPCX_CLOCK_BUS_LFCLK NPCX_PWDWN_CTL4 0
+				  &pcc NPCX_CLOCK_BUS_APB2 NPCX_PWDWN_CTL7 5>;
+			interrupts = <28 1>; /* Event timer interrupt */
+		};
+
+		uart1: serial@400e0000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E0000 0x2000>;
+			interrupts = <33 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL1 4>;
+			uart-rx = <&wui_cr_sin1>;
+			status = "disabled";
+		};
+
+		uart2: serial@400e2000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E2000 0x2000>;
+			interrupts = <32 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 6>;
+			uart-rx = <&wui_cr_sin2>;
+			status = "disabled";
+		};
+
+		uart3: serial@400e4000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E4000 0x2000>;
+			interrupts = <38 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 4>;
+			uart-rx = <&wui_cr_sin3>;
+			status = "disabled";
+		};
+
+		uart4: serial@400e6000 {
+			compatible = "nuvoton,npcx-uart";
+			reg = <0x400E6000 0x2000>;
+			interrupts = <39 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB4 NPCX_PWDWN_CTL7 3>;
+			uart-rx = <&wui_cr_sin4>;
+			status = "disabled";
+		};
+
+		/* Default clock and power settings in npcx4 series */
+		pcc: clock-controller@4000d000 {
+			clock-frequency = <DT_FREQ_M(120)>; /* OFMCLK runs at 120MHz */
+			core-prescaler = <8>; /* CORE_CLK runs at 15MHz */
+			apb1-prescaler = <8>; /* APB1_CLK runs at 15MHz */
+			apb2-prescaler = <8>; /* APB2_CLK runs at 15MHz */
+			apb3-prescaler = <8>; /* APB3_CLK runs at 15MHz */
+			apb4-prescaler = <8>; /* APB4_CLK runs at 15MHz */
+			ram-pd-depth = <8>; /* Valid bit-depth of RAM_PDn reg */
+			pwdwn-ctl-val = <0xfb
+					 0xff
+					 0x1f /* No GDMA1_PD/GDMA2_PD */
+					 0xff
+					 0xfa
+					 0x7f /* No ESPI_PD */
+					 0xff
+					 0xcf>; /* No FIU_PD */
+		};
+
+		/* Wake-up input source mapping for GPIOs in npcx4 series */
+		gpio0: gpio@40081000 {
+			wui-maps = <&wui_io00 &wui_io01 &wui_io02 &wui_io03
+				    &wui_io04 &wui_io05 &wui_io06 &wui_io07>;
+
+			lvol-maps = <&lvol_io00 &lvol_io01 &lvol_io02 &lvol_io03
+				     &lvol_io04 &lvol_io05 &lvol_io06 &lvol_io07>;
+		};
+
+		gpio1: gpio@40083000 {
+			wui-maps = <&wui_io10 &wui_io11 &wui_io12 &wui_io13
+				    &wui_io14 &wui_io15 &wui_io16 &wui_io17>;
+
+			lvol-maps = <&lvol_io10 &lvol_io11 &lvol_none &lvol_io13
+				     &lvol_io14 &lvol_io15 &lvol_io16 &lvol_io17>;
+		};
+
+		gpio2: gpio@40085000 {
+			wui-maps = <&wui_io20 &wui_io21 &wui_io22 &wui_io23
+				    &wui_io24 &wui_io25 &wui_io26 &wui_io27>;
+
+			lvol-maps = <&lvol_io20 &lvol_io21 &lvol_io22 &lvol_io23
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpio3: gpio@40087000 {
+			wui-maps = <&wui_io30 &wui_io31 &wui_none &wui_io33
+				    &wui_io34 &wui_none &wui_io36 &wui_io37>;
+
+			lvol-maps = <&lvol_none &lvol_none &lvol_none &lvol_io33
+				     &lvol_io34 &lvol_none &lvol_io36 &lvol_io37>;
+		};
+
+		gpio4: gpio@40089000 {
+			wui-maps = <&wui_io40 &wui_io41 &wui_io42 &wui_io43
+				    &wui_io44 &wui_io45 &wui_io46 &wui_io47>;
+
+			lvol-maps = <&lvol_io40 &lvol_io41 &lvol_io42 &lvol_io43
+				     &lvol_io44 &lvol_io45 &lvol_none &lvol_none>;
+		};
+
+		gpio5: gpio@4008b000 {
+			wui-maps = <&wui_io50 &wui_io51 &wui_io52 &wui_io53
+				    &wui_io54 &wui_io55 &wui_io56 &wui_io57>;
+
+			lvol-maps = <&lvol_io50 &lvol_none &lvol_none &lvol_none
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpio6: gpio@4008d000 {
+			wui-maps = <&wui_io60 &wui_io61 &wui_io62 &wui_io63
+				    &wui_io64 &wui_none &wui_io66 &wui_io67>;
+
+			lvol-maps = <&lvol_io60 &lvol_io61 &lvol_io62 &lvol_io63
+				     &lvol_io64 &lvol_none &lvol_io66 &lvol_io67>;
+		};
+
+		gpio7: gpio@4008f000 {
+			wui-maps = <&wui_io70 &wui_none &wui_io72 &wui_io73
+				    &wui_io74 &wui_io75 &wui_io76 &wui_none>;
+
+			lvol-maps = <&lvol_io70 &lvol_none &lvol_io72 &lvol_io73
+				     &lvol_io74 &lvol_io75 &lvol_io76 &lvol_none>;
+		};
+
+		gpio8: gpio@40091000 {
+			wui-maps = <&wui_io80 &wui_io81 &wui_io82 &wui_io83
+				    &wui_none &wui_none &wui_none &wui_io87>;
+
+			lvol-maps = <&lvol_io80 &lvol_none &lvol_io82 &lvol_io83
+				     &lvol_none &lvol_none &lvol_none &lvol_io87>;
+		};
+
+		gpio9: gpio@40093000 {
+			wui-maps = <&wui_io90 &wui_io91 &wui_io92 &wui_io93
+				    &wui_io94 &wui_io95 &wui_io96 &wui_io97>;
+
+			lvol-maps = <&lvol_io90 &lvol_io91 &lvol_io92 &lvol_none
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpioa: gpio@40095000 {
+			wui-maps = <&wui_ioa0 &wui_ioa1 &wui_ioa2 &wui_ioa3
+				    &wui_ioa4 &wui_ioa5 &wui_ioa6 &wui_ioa7>;
+
+			lvol-maps = <&lvol_none &lvol_none &lvol_none &lvol_none
+				     &lvol_none &lvol_none &lvol_none &lvol_none>;
+		};
+
+		gpiob: gpio@40097000 {
+			wui-maps = <&wui_iob0 &wui_iob1 &wui_iob2 &wui_iob3
+				    &wui_iob4 &wui_iob5 &wui_iob6 &wui_iob7>;
+
+			lvol-maps = <&lvol_none &lvol_iob1 &lvol_iob2 &lvol_iob3
+				     &lvol_iob4 &lvol_iob5 &lvol_iob6 &lvol_iob7>;
+		};
+
+		gpioc: gpio@40099000 {
+			wui-maps = <&wui_ioc0 &wui_ioc1 &wui_ioc2 &wui_ioc3
+				    &wui_ioc4 &wui_ioc5 &wui_ioc6 &wui_ioc7>;
+
+			lvol-maps = <&lvol_ioc0 &lvol_ioc1 &lvol_ioc2 &lvol_ioc3
+				     &lvol_ioc4 &lvol_ioc5 &lvol_ioc6 &lvol_ioc7>;
+		};
+
+		gpiod: gpio@4009b000 {
+			wui-maps = <&wui_iod0 &wui_iod1 &wui_iod2 &wui_iod3
+				    &wui_iod4 &wui_iod5 &wui_iod6 &wui_none>;
+
+			lvol-maps = <&lvol_iod0 &lvol_iod1 &lvol_iod2 &lvol_iod3
+				     &lvol_iod4 &lvol_iod5 &lvol_iod6 &lvol_none>;
+		};
+
+		gpioe: gpio@4009d000 {
+			wui-maps = <&wui_ioe0 &wui_ioe1 &wui_ioe2 &wui_ioe3
+				    &wui_ioe4 &wui_ioe5 &wui_none &wui_ioe7>;
+
+			lvol-maps = <&lvol_ioe0 &lvol_ioe1 &lvol_ioe2 &lvol_ioe3
+				     &lvol_ioe4 &lvol_ioe5 &lvol_none &lvol_ioe7>;
+		};
+
+		gpiof: gpio@4009f000 {
+			wui-maps = <&wui_iof0 &wui_iof1 &wui_iof2 &wui_iof3
+				    &wui_iof4 &wui_iof5 &wui_none &wui_none>;
+
+			lvol-maps = <&lvol_iof0 &lvol_iof1 &lvol_iof2 &lvol_iof3
+				     &lvol_iof4 &lvol_iof5 &lvol_none &lvol_none>;
+		};
+
+		/* ADC0 comparator configuration in npcx4 series */
+		adc0: adc@400d1000 {
+			channel-count = <26>;
+			threshold-count = <6>;
+		};
+
+		/* ADC1 which reference voltage is AVCC */
+		adc1: adc@400d5000 {
+			compatible = "nuvoton,npcx-adc";
+			#io-channel-cells = <1>;
+			reg = <0x400d5000 0x2000>;
+			interrupts = <22 3>;
+			clocks = <&pcc NPCX_CLOCK_BUS_APB1 NPCX_PWDWN_CTL4 3>;
+			vref-mv = <3300>;
+			channel-count = <26>;
+			threshold-count = <6>;
+			status = "disabled";
+		};
+
+		/* FIU0 configuration in npcx4 series */
+		qspi_fiu0: quadspi@40020000 {
+			clocks = <&pcc NPCX_CLOCK_BUS_FIU0 NPCX_PWDWN_CTL8 5>;
+		};
+
+		/* FIU1 configuration in npcx4 series */
+		qspi_fiu1: quadspi@40021000 {
+			compatible = "nuvoton,npcx-fiu-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x40021000 0x1000>;
+			clocks = <&pcc NPCX_CLOCK_BUS_FIU0 NPCX_PWDWN_CTL8 6>;
+		};
+
+		sha0: sha@13c {
+			compatible = "nuvoton,npcx-sha";
+			reg = <0x13c 0x3c>;
+			context-buffer-size = <228>;
+			status = "disabled";
+		};
+	};
+
+	soc-if {
+		i2c4_0: io_i2c_ctrl4_port0 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x40>;
+			controller = <&i2c_ctrl4>;
+			status = "disabled";
+		};
+
+		i2c7_1: io_i2c_ctrl7_port1 {
+			compatible = "nuvoton,npcx-i2c-port";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port = <0x71>;
+			controller = <&i2c_ctrl7>;
+			status = "disabled";
+		};
+	};
+
+	soc-id {
+		family-id = <0x23>;
+		chip-id = <0x0a>;
+		revision-reg = <0x0000FFFC 4>;
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi
new file mode 100644
index 0000000000..b5e8c5b88a
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-alts-map.dtsi
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common pin-mux configurations in npcx family */
+#include <nuvoton/npcx/npcx-alts-map.dtsi>
+
+/* Specific pin-mux configurations in npcx4 series */
+/ {
+	npcx-alts-map {
+		compatible = "nuvoton,npcx-pinctrl-conf";
+
+		/* SCFG DEVALT 0 */
+		alt0_f_spi_cs1: alt04 {
+			alts = <&scfg 0x00 0x4 0>;
+		};
+		alt0_f_spi_quad: alt06 {
+			alts = <&scfg 0x00 0x6 0>;
+		};
+
+		/* SCFG DEVALT 2 */
+		alt2_i2c4_0_sl: alt27 {
+			alts = <&scfg 0x02 0x7 0>;
+		};
+
+		/* SCFG DEVALT 5 */
+		alt5_jen_lk: alt51 {
+			alts = <&scfg 0x05 0x1 0>;
+		};
+		alt5_gp_lk: alt57 {
+			alts = <&scfg 0x05 0x7 0>;
+		};
+
+		/* SCFG DEVALT E */
+		alte_cr_sin4_sl: alte6 {
+			alts = <&scfg 0x0E 0x6 0>;
+		};
+		alte_cr_sout4_sl: alte7 {
+			alts = <&scfg 0x0E 0x7 0>;
+		};
+
+		/* SCFG DEVALT F */
+		altf_adc10_sl: altf5 {
+			alts = <&scfg 0x0F 0x5 0>;
+		};
+		altf_adc11_sl: altf6 {
+			alts = <&scfg 0x0F 0x6 0>;
+		};
+
+		/* SCFG DEVALT A */
+		alta_32kclkin_sl: alta3 {
+			alts = <&scfg 0x0A 0x3 0>;
+		};
+
+		/* SCFG DEVALT C */
+		altc_gpio97_sl_inv: altc2-inv {
+			alts = <&scfg 0x0C 0x2 1>;
+		};
+
+		/* SCFG DEVALT F */
+		altf_adc12_sl: altf7 {
+			alts = <&scfg 0x0F 0x7 0>;
+		};
+
+		/* SCFG DEVALT G */
+		altg_vcc1_rst_pud: altg4 {
+			alts = <&scfg 0x10 0x4 0>;
+		};
+		altg_vcc1_rst_pud_lk: altg5 {
+			alts = <&scfg 0x10 0x5 0>;
+		};
+		altg_psl_out_sl: altg6 {
+			alts = <&scfg 0x10 0x6 0>;
+		};
+		altg_psl_gpo_sl: altg7 {
+			alts = <&scfg 0x10 0x7 0>;
+		};
+
+		/* SCFG DEVALT H */
+		alth_fcsi_typ: alth1 {
+			alts = <&scfg 0x11 0x1 0>;
+		};
+		alth_flm_quad: alth5 {
+			alts = <&scfg 0x11 0x5 0>;
+		};
+		alth_flm_mon_md: alth6-inv {
+			alts = <&scfg 0x11 0x6 1>;
+		};
+		alth_flm_sl: alth7 {
+			alts = <&scfg 0x11 0x7 0>;
+		};
+
+		/*
+		 * Note: DEVALT I is skipped in the datasheet, the offset of
+		 * DEVALT J is 0x12 not 0x13.
+		 */
+		/* SCFG DEVALT J */
+		altj_cr_sin1_sl1: altj0 {
+			alts = <&scfg 0x12 0x0 0>;
+		};
+		altj_cr_sout1_sl1: altj1 {
+			alts = <&scfg 0x12 0x1 0>;
+		};
+		altj_cr_sin1_sl2:  altj2 {
+			alts = <&scfg 0x12 0x2 0>;
+		};
+		altj_cr_sout1_sl2: altj3 {
+			alts = <&scfg 0x12 0x3 0>;
+		};
+		altj_cr_sin2_sl: altj4 {
+			alts = <&scfg 0x12 0x4 0>;
+		};
+		altj_cr_sout2_sl: altj5 {
+			alts = <&scfg 0x12 0x5 0>;
+		};
+		altj_cr_sin3_sl: altj6 {
+			alts = <&scfg 0x12 0x6 0>;
+		};
+		altj_cr_sout3_sl: altj7 {
+			alts = <&scfg 0x12 0x7 0>;
+		};
+
+		/* SCFG DEVALT K */
+		altk_i2c7_1_sl: altk7 {
+			alts = <&scfg 0x13 0x7 0>;
+		};
+
+		/* SCFG DEVALT L */
+		altl_adc13_sl: altl0 {
+			alts = <&scfg 0x14 0x0 0>;
+		};
+		altl_adc14_sl: altl1 {
+			alts = <&scfg 0x14 0x1 0>;
+		};
+		altl_adc15_sl:  altl2 {
+			alts = <&scfg 0x14 0x2 0>;
+		};
+		altl_adc16_sl: altl3 {
+			alts = <&scfg 0x14 0x3 0>;
+		};
+		altl_adc17_sl: altl4 {
+			alts = <&scfg 0x14 0x4 0>;
+		};
+		altl_adc18_sl: altl5 {
+			alts = <&scfg 0x14 0x5 0>;
+		};
+		altl_adc19_sl: altl6 {
+			alts = <&scfg 0x14 0x6 0>;
+		};
+		altl_adc20_sl: altl7 {
+			alts = <&scfg 0x14 0x7 0>;
+		};
+
+		/* SCFG DEVALT M */
+		altm_adc21_sl: altm0 {
+			alts = <&scfg 0x15 0x0 0>;
+		};
+		altm_adc22_sl: altm1 {
+			alts = <&scfg 0x15 0x1 0>;
+		};
+		altm_adc23_sl:  altm2 {
+			alts = <&scfg 0x15 0x2 0>;
+		};
+		altm_adc24_sl: altm3 {
+			alts = <&scfg 0x15 0x3 0>;
+		};
+		altm_adc25_sl: altm4 {
+			alts = <&scfg 0x15 0x4 0>;
+		};
+
+		/* SCFG DEVALT N */
+		altn_i3c1_sl: altn0 {
+			alts = <&scfg 0x16 0x0 0>;
+		};
+		altn_i3c2_sl: altn1 {
+			alts = <&scfg 0x16 0x1 0>;
+		};
+		altn_i3c3_sl:  altn2 {
+			alts = <&scfg 0x16 0x2 0>;
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi
new file mode 100644
index 0000000000..26a467f0a5
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-espi-vws-map.dtsi
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common eSPI Virtual Wire (VW) mapping configurations in npcx family */
+#include <nuvoton/npcx/npcx-espi-vws-map.dtsi>
+
+/*
+ *   Specific eSPI Virtual Wire (VW) mapping configurations in npcx4 series
+ * |--------------------------------------------------------------------------|
+ * | VW idx | SLV reg | Wire Bit 3   | Wire Bit 2   | Wire Bit 1| Wire Bit 0  |
+ * |--------------------------------------------------------------------------|
+ * |       Output (Slave-to-Master) Virtual Wires (High at reset state)       |
+ * |--------------------------------------------------------------------------|
+ * | 50h[P] | VWGPSM0 | SLV_GPIO_3   | SLV_GPIO_2   | SLV_GPIO_1| SLV_GPIO_0  |
+ * | 51h[P] | VWGPSM1 | SLV_GPIO_7   | SLV_GPIO_6   | SLV_GPIO_5| SLV_GPIO_4  |
+ * |--------------------------------------------------------------------------|
+ *  [S] System-/[P] Platform-Specific Virtual Wires
+ */
+
+/ {
+	npcx-espi-vws-map {
+		compatible = "nuvoton,npcx-espi-vw-conf";
+
+		/*
+		 * Virtual wires for platform level usage (High at Reset state)
+		 */
+		/* index 50h (Out) */
+		vw_slv_gpio_0 {
+			vw-reg = <NPCX_VWGPSM0 0x01>;
+		};
+		vw_slv_gpio_1 {
+			vw-reg = <NPCX_VWGPSM0 0x02>;
+		};
+		vw_slv_gpio_2 {
+			vw-reg = <NPCX_VWGPSM0 0x04>;
+		};
+		vw_slv_gpio_3 {
+			vw-reg = <NPCX_VWGPSM0 0x08>;
+		};
+
+		/* index 51h (Out) */
+		vw_slv_gpio_4 {
+			vw-reg = <NPCX_VWGPSM1 0x01>;
+		};
+		vw_slv_gpio_5 {
+			vw-reg = <NPCX_VWGPSM1 0x02>;
+		};
+		vw_slv_gpio_6 {
+			vw-reg = <NPCX_VWGPSM1 0x04>;
+		};
+		vw_slv_gpio_7 {
+			vw-reg = <NPCX_VWGPSM1 0x08>;
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi
new file mode 100644
index 0000000000..e4a7a38798
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-lvol-ctrl-map.dtsi
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common Low-Voltage level configurations in npcx family */
+#include <nuvoton/npcx/npcx-lvol-ctrl-map.dtsi>
+
+/* Specific Low-Voltage level configurations in npcx4 series */
+/ {
+	def-lvol-conf-list {
+		compatible = "nuvoton,npcx-lvolctrl-conf";
+
+		/* Low-Voltage IO Control 1 */
+		lvol_io66: lvol17 {
+			lvols = <&scfg 1 7>;
+		};
+
+		/* Low-Voltage IO Control 2 */
+		lvol_ioe7: lvol26 {
+			lvols = <&scfg 2 6>;
+		};
+
+		/* Low-Voltage IO Control 5 */
+		lvol_io02: lvol54 {
+			lvols = <&scfg 5 4>;
+		};
+		lvol_io01: lvol55 {
+			lvols = <&scfg 5 5>;
+		};
+		lvol_ioe2: lvol56 {
+			lvols = <&scfg 5 6>;
+		};
+		lvol_iod6: lvol57 {
+			lvols = <&scfg 5 7>;
+		};
+
+		/* Low-Voltage IO Control 6 */
+		lvol_io03: lvol60 {
+			lvols = <&scfg 6 0>;
+		};
+		lvol_io05: lvol61 {
+			lvols = <&scfg 6 1>;
+		};
+		lvol_io04: lvol62 {
+			lvols = <&scfg 6 2>;
+		};
+		lvol_io06: lvol63 {
+			lvols = <&scfg 6 3>;
+		};
+		lvol_io07: lvol64 {
+			lvols = <&scfg 6 4>;
+		};
+		lvol_io10: lvol65 {
+			lvols = <&scfg 6 5>;
+		};
+		lvol_io11: lvol66 {
+			lvols = <&scfg 6 6>;
+		};
+		lvol_io13: lvol67 {
+			lvols = <&scfg 6 7>;
+		};
+
+		/* Low-Voltage IO Control 7 */
+		lvol_io14: lvol70 {
+			lvols = <&scfg 7 0>;
+		};
+		lvol_io15: lvol71 {
+			lvols = <&scfg 7 1>;
+		};
+		lvol_io16: lvol72 {
+			lvols = <&scfg 7 2>;
+		};
+		lvol_io17: lvol73 {
+			lvols = <&scfg 7 3>;
+		};
+		lvol_io20: lvol74 {
+			lvols = <&scfg 7 4>;
+		};
+		lvol_io21: lvol75 {
+			lvols = <&scfg 7 5>;
+		};
+		lvol_io22: lvol76 {
+			lvols = <&scfg 7 6>;
+		};
+		lvol_io23: lvol77 {
+			lvols = <&scfg 7 7>;
+		};
+
+		/* Low-Voltage IO Control 8 */
+		lvol_ioe0: lvol80 {
+			lvols = <&scfg 8 0>;
+		};
+		lvol_io41: lvol81 {
+			lvols = <&scfg 8 1>;
+		};
+		lvol_iof0: lvol82 {
+			lvols = <&scfg 8 2>;
+		};
+		lvol_io42: lvol83 {
+			lvols = <&scfg 8 3>;
+		};
+		lvol_io43: lvol84 {
+			lvols = <&scfg 8 4>;
+		};
+		lvol_io44: lvol85 {
+			lvols = <&scfg 8 5>;
+		};
+		lvol_io45: lvol86 {
+			lvols = <&scfg 8 6>;
+		};
+		lvol_ioe1: lvol87 {
+			lvols = <&scfg 8 7>;
+		};
+
+		/* Low-Voltage IO Control 9 */
+		lvol_iof1: lvol90 {
+			lvols = <&scfg 9 0>;
+		};
+		lvol_io61: lvol91 {
+			lvols = <&scfg 9 1>;
+		};
+		lvol_io62: lvol92 {
+			lvols = <&scfg 9 2>;
+		};
+		lvol_io63: lvol93 {
+			lvols = <&scfg 9 3>;
+		};
+		lvol_io67: lvol94 {
+			lvols = <&scfg 9 4>;
+		};
+		lvol_io70: lvol95 {
+			lvols = <&scfg 9 5>;
+		};
+		lvol_io76: lvol96 {
+			lvols = <&scfg 9 6>;
+		};
+		lvol_io83: lvol97 {
+			lvols = <&scfg 9 7>;
+		};
+
+		/* Low-Voltage IO Control A */
+		lvol_iob1: lvola0 {
+			lvols = <&scfg 10 0>;
+		};
+		lvol_iob6: lvola1 {
+			lvols = <&scfg 10 1>;
+		};
+		lvol_iob7: lvola2 {
+			lvols = <&scfg 10 2>;
+		};
+		lvol_ioc0: lvola3 {
+			lvols = <&scfg 10 3>;
+		};
+		lvol_ioc3: lvola4 {
+			lvols = <&scfg 10 4>;
+		};
+		lvol_ioc4: lvola5 {
+			lvols = <&scfg 10 5>;
+		};
+		lvol_iod2: lvola6 {
+			lvols = <&scfg 10 6>;
+		};
+		lvol_iod3: lvola7 {
+			lvols = <&scfg 10 7>;
+		};
+
+		/* Low-Voltage IO Control B */
+		lvol_iod4: lvolb0 {
+			lvols = <&scfg 11 0>;
+		};
+		lvol_iod5: lvolb1 {
+			lvols = <&scfg 11 1>;
+		};
+		lvol_ioe5: lvolb2 {
+			lvols = <&scfg 11 2>;
+		};
+		lvol_io60: lvolb7 {
+			lvols = <&scfg 11 7>;
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi
new file mode 100644
index 0000000000..d8c228b424
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-int-map.dtsi
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common MIWU group-interrupt mapping configurations in npcx family */
+#include <nuvoton/npcx/npcx-miwus-int-map.dtsi>
+
+/* Specific MIWU group-interrupt mapping configurations in npcx4 series */
+/ {
+	/* Mapping between MIWU group and interrupts */
+	npcx-miwus-int-map {
+		map_miwu0_groups: map-miwu0-groups {
+			compatible = "nuvoton,npcx-miwu-int-map";
+			parent = <&miwu0>;
+
+			group_a0: group-a0-map {
+				irq        = <7>;
+				irq-prio   = <2>;
+				group-mask = <0x01>;
+			};
+			group_d0: group-d0-map {
+				irq        = <5>;
+				irq-prio   = <2>;
+				group-mask = <0x08>;
+			};
+			group_e0: group-e0-map {
+				irq        = <11>;
+				irq-prio   = <2>;
+				group-mask = <0x10>;
+			};
+			group_f0: group-f0-map {
+				irq        = <35>;
+				irq-prio   = <2>;
+				group-mask = <0x20>;
+			};
+			group_g0: group-g0-map {
+				irq        = <42>;
+				irq-prio   = <2>;
+				group-mask = <0x40>;
+			};
+			group_h0: group-h0-map {
+				irq        = <46>;
+				irq-prio   = <2>;
+				group-mask = <0x80>;
+			};
+		};
+
+		map_miwu2_groups: map-miwu2-groups {
+			compatible = "nuvoton,npcx-miwu-int-map";
+			parent = <&miwu2>;
+
+			group_e2: group-e2-map {
+				irq        = <64>;
+				irq-prio   = <2>;
+				group-mask = <0x10>;
+			};
+			group_f2: group-f2-map {
+				irq        = <59>;
+				irq-prio   = <2>;
+				group-mask = <0x20>;
+			};
+			group_g2: group-g2-map {
+				irq        = <55>;
+				irq-prio   = <2>;
+				group-mask = <0x40>;
+			};
+			group_h2: group-h2-map {
+				irq        = <82>;
+				irq-prio   = <2>;
+				group-mask = <0x80>;
+			};
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi
new file mode 100644
index 0000000000..ace5d4b156
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-miwus-wui-map.dtsi
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+/* Common Wake-Up Unit Input (WUI) mapping configurations in npcx family */
+#include <nuvoton/npcx/npcx-miwus-wui-map.dtsi>
+
+/* Specific Wake-Up Unit Input (WUI) mapping configurations in npcx4 series */
+/ {
+	/* Mapping between MIWU wui bits and source device */
+	npcx-miwus-wui-map {
+		compatible = "nuvoton,npcx-miwu-wui-map";
+
+		/* MIWU table 0 */
+		/* MIWU group H */
+		wui_ioe7: wui0-8-7 {
+			miwus = <&miwu0 7 7>; /* GPIOE7 */
+		};
+
+		/* MIWU table 1 */
+		/* MIWU group B */
+		wui_io13: wui1-2-3 {
+			miwus = <&miwu1 1 3>; /* GPIO13 */
+		};
+
+		/* MIWU group G */
+		wui_io66: wui1-7-6 {
+			miwus = <&miwu1 6 6>; /* GPIO66 */
+		};
+
+		/* MIWU table 2 */
+		/* MIWU group E */
+		wui_slp_msc: wui2-5-0 {
+			miwus = <&miwu2 4 0>; /* SLP_MSC */
+		};
+		wui_z8: wui2-5-1 {
+			miwus = <&miwu2 4 1>; /* Z8 */
+		};
+		wui_z9: wui2-5-2 {
+			miwus = <&miwu2 4 2>; /* Z9 */
+		};
+		wui_z10: wui2-5-3 {
+			miwus = <&miwu2 4 3>; /* Z10 */
+		};
+
+		/* MIWU group F */
+		wui_io12: wui2-6-0 {
+			miwus = <&miwu2 5 0>; /* GPIO12 */
+		};
+		wui_smb2: wui2-6-3 {
+			miwus = <&miwu2 5 3>; /* SMB2 */
+		};
+		wui_smb3: wui2-6-4 {
+			miwus = <&miwu2 5 4>; /* SMB3 */
+		};
+		wui_iod6: wui2-6-5 {
+			miwus = <&miwu2 5 5>; /* GPIOD6 */
+		};
+		wui_iob6: wui2-6-6 {
+			miwus = <&miwu2 5 6>; /* GPIOB6 */
+		};
+		wui_lct: wui2-6-7 {
+			miwus = <&miwu2 5 7>; /* LCT Event */
+		};
+
+		/* MIWU group G */
+		wui_cr_sin2: wui2-7-3 {
+			miwus = <&miwu2 6 3>; /* CR_SIN2 */
+		};
+		wui_cr_sin3: wui2-7-4 {
+			miwus = <&miwu2 6 4>; /* CR_SIN3 */
+		};
+		wui_cr_sin4: wui2-7-5 {
+			miwus = <&miwu2 6 5>; /* CR_SIN4 */
+		};
+		wui_i3c1_addrw: wui2-7-6 {
+			miwus = <&miwu2 6 6>; /* I3C1_ADDRW */
+		};
+		wui_i3c1_rstw: wui2-7-7 {
+			miwus = <&miwu2 6 7>; /* I3C1_RSTW */
+		};
+
+		/* MIWU group G */
+		wui_i3c2_addrw: wui2-8-0 {
+			miwus = <&miwu2 7 0>; /* I3C2_ADDRW */
+		};
+		wui_i3c2_rstw: wui2-8-1 {
+			miwus = <&miwu2 7 1>; /* I3C2_RSTW */
+		};
+		wui_i3c3_addrw: wui2-8-2 {
+			miwus = <&miwu2 7 2>; /* I3C3_ADDRW */
+		};
+		wui_i3c3_rstw: wui2-8-3 {
+			miwus = <&miwu2 7 3>; /* I3C3_RSTW */
+		};
+	};
+};
diff --git a/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi b/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
new file mode 100644
index 0000000000..c795a41736
--- /dev/null
+++ b/dts/arm/nuvoton/npcx/npcx4/npcx4-pinctrl.dtsi
@@ -0,0 +1,558 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+&pinctrl {
+	/* Prebuild nodes for peripheral device's characteristics (Optional) */
+	/omit-if-no-ref/ vhif_lpc_sl: devctl-vhif-3p3v-lpc {
+		dev-ctl = <0x0 2 2 0x01>;
+	};
+
+	/omit-if-no-ref/ vhif_espi_shi_sl: devctl-vhif-1p8v-espi-shi {
+		dev-ctl = <0x0 2 2 0x02>;
+	};
+
+	/omit-if-no-ref/ vspi_3p3v_sl: devctl-vspi-3p3v {
+		dev-ctl = <0x0 4 2 0x01>;
+	};
+
+	/omit-if-no-ref/ vspi_1p8v_sl: devctl-vspi-1p8v {
+		dev-ctl = <0x0 4 2 0x02>;
+	};
+
+	/omit-if-no-ref/ ext_flash_tris_off: devctl-fiu-ext-tris-off {
+		dev-ctl = <0x0 6 1 0x00>;
+	};
+
+	/omit-if-no-ref/ ext_flash_tris_on: devctl-fiu-ext-tris-on {
+		dev-ctl = <0x0 6 1 0x01>;
+	};
+
+	/* Prebuild nodes for peripheral device's pin-muxing and pad properties */
+	/* Flash Interface Unit (FIU) */
+	/omit-if-no-ref/ fiu_ext_io0_io1_clk_cs_gpa4_96_a2_a0: periph-fiu-ext {
+		pinmux = <&alt0_gpio_no_fpip>;
+	};
+
+	/omit-if-no-ref/ fiu_ext_quad_io2_io3_gp93_a7: periph-fiu-ext-quad {
+		pinmux = <&alt0_f_spi_quad>;
+	};
+
+	/omit-if-no-ref/ ext_flash_cs1_sl: periph-ext-spi-flash-cs1 {
+		pinmux = <&alt0_f_spi_cs1>;
+	};
+
+	/* Host peripheral interfaces */
+	/omit-if-no-ref/ espi_lpc_gp46_47_51_52_53_54_55_57: periph-lpc-espi {
+		pinmux = <&alt1_no_lpc_espi>;
+	};
+
+	/* I2C peripheral interfaces */
+	/omit-if-no-ref/ i2c0_0_sda_scl_gpb4_b5: periph-i2c0-0 {
+		pinmux = <&alt2_i2c0_0_sl>;
+		periph-pupd = <0x00 0>;
+	};
+
+	/omit-if-no-ref/ i2c1_0_sda_scl_gp87_90: periph-i2c1-0 {
+		pinmux = <&alt2_i2c1_0_sl>;
+		periph-pupd = <0x00 2>;
+	};
+
+	/omit-if-no-ref/ i2c2_0_sda_scl_gp91_92: periph-i2c2-0 {
+		pinmux = <&alt2_i2c2_0_sl>;
+		periph-pupd = <0x00 4>;
+	};
+
+	/omit-if-no-ref/ i2c3_0_sda_scl_gpd0_d1: periph-i2c3-0 {
+		pinmux = <&alt2_i2c3_0_sl>;
+		periph-pupd = <0x00 6>;
+	};
+
+	/omit-if-no-ref/ i2c4_0_sda_scl_gp75_86: periph-i2c4-0 {
+		pinmux = <&alt2_i2c4_0_sl>;
+		periph-pupd = <0x00 7>;
+	};
+
+	/omit-if-no-ref/ i2c4_1_sda_scl_gpf2_f3: periph-i2c4-1 {
+		pinmux = <&alt6_i2c4_1_sl>;
+		periph-pupd = <0x01 2>;
+	};
+
+	/omit-if-no-ref/ i2c5_0_sda_scl_gp33_36: periph-i2c5-0 {
+		pinmux = <&alt2_i2c5_0_sl>;
+		periph-pupd = <0x00 5>;
+	};
+
+	/omit-if-no-ref/ i2c5_1_sda_scl_gpf4_f5: periph-i2c5-1 {
+		pinmux = <&alt6_i2c5_1_sl>;
+		periph-pupd = <0x01 1>;
+	};
+
+	/omit-if-no-ref/ i2c6_0_sda_scl_gpc1_c2: periph-i2c6-0 {
+		pinmux = <&alt2_i2c6_0_sl>;
+		periph-pupd = <0x00 3>;
+	};
+
+	/omit-if-no-ref/ i2c6_1_sda_scl_gpe3_e4: periph-i2c6-1 {
+		pinmux = <&alt6_i2c6_1_sl>;
+		periph-pupd = <0x01 0>;
+	};
+
+	/omit-if-no-ref/ i2c7_0_sda_scl_gpb2_b3: periph-i2c7-0 {
+		pinmux = <&alt2_i2c7_0_sl>;
+		periph-pupd = <0x00 1>;
+	};
+
+	/omit-if-no-ref/ i2c7_1_sda_scl_gpb7_c0: periph-i2c7-1 {
+		pinmux = <&altk_i2c7_1_sl>;
+		periph-pupd = <0x01 3>;
+	};
+
+	/* PS2 peripheral interfaces */
+	/omit-if-no-ref/ ps2_0_dat_clk_gp67_70: periph-ps2-0 {
+		pinmux = <&alt3_ps2_0_sl>;
+	};
+
+	/omit-if-no-ref/ ps2_1_dat_clk_gp62_63: periph-ps2-1 {
+		pinmux = <&alt3_ps2_1_sl>;
+	};
+
+	/omit-if-no-ref/ ps2_2_dat_clk_gp34_37: periph-ps2-2 {
+		pinmux = <&alt3_ps2_2_sl>;
+	};
+
+	/omit-if-no-ref/ ps2_3_2_dat_clk_gpa6_a7: periph-ps2-3-2 {
+		pinmux = <&altc_ps2_3_sl2>;
+	};
+
+	/* Tachometer peripheral interfaces */
+	/omit-if-no-ref/ ta1_1_in_gp40: periph-ta1-1 {
+		pinmux = <&alt3_ta1_sl1>;
+	};
+
+	/omit-if-no-ref/ ta1_2_in_gp93: periph-ta1-2 {
+		pinmux = <&altc_ta1_sl2>;
+	};
+
+	/omit-if-no-ref/ ta2_1_in_gp73: periph-ta2-1 {
+		pinmux = <&alt3_ta2_sl1>;
+	};
+
+	/omit-if-no-ref/ ta2_2_in_gpa6: periph-ta2-2 {
+		pinmux = <&altc_ta2_sl2>;
+	};
+
+	/omit-if-no-ref/ tb1_1_in_gpa4: periph-tb1-1 {
+		pinmux = <&alt3_tb1_sl1>;
+	};
+
+	/omit-if-no-ref/ tb1_2_in_gpd3: periph-tb1-2 {
+		pinmux = <&altc_tb1_sl2>;
+	};
+
+	/omit-if-no-ref/ tb2_2_in_gpa7: periph-tb2-2 {
+		pinmux = <&altc_tb2_sl2>;
+	};
+
+	/* PWM peripheral interfaces */
+	/omit-if-no-ref/ pwm0_gpc3: periph-pwm0 {
+		pinmux = <&alt4_pwm0_sl>;
+	};
+
+	/omit-if-no-ref/ pwm1_gpc2: periph-pwm1 {
+		pinmux = <&alt4_pwm1_sl>;
+	};
+
+	/omit-if-no-ref/ pwm2_gpc4: periph-pwm2 {
+		pinmux = <&alt4_pwm2_sl>;
+	};
+
+	/omit-if-no-ref/ pwm3_gp80: periph-pwm3 {
+		pinmux = <&alt4_pwm3_sl>;
+	};
+
+	/omit-if-no-ref/ pwm4_gpb6: periph-pwm4 {
+		pinmux = <&alt4_pwm4_sl>;
+	};
+
+	/omit-if-no-ref/ pwm5_gpb7: periph-pwm5 {
+		pinmux = <&alt4_pwm5_sl>;
+	};
+
+	/omit-if-no-ref/ pwm6_gpc0: periph-pwm6 {
+		pinmux = <&alt4_pwm6_sl>;
+	};
+
+	/omit-if-no-ref/ pwm7_gp60: periph-pwm7 {
+		pinmux = <&alt4_pwm7_sl>;
+	};
+
+	/* Keyboard peripheral interfaces. */
+	/omit-if-no-ref/ ksi0_gp31: periph-kbscan-ksi0 {
+		pinmux = <&alt7_no_ksi0_sl>;
+	};
+
+	/omit-if-no-ref/ ksi1_gp30: periph-kbscan-ksi1 {
+		pinmux = <&alt7_no_ksi1_sl>;
+	};
+
+	/omit-if-no-ref/ ksi2_gp27: periph-kbscan-ksi2 {
+		pinmux = <&alt7_no_ksi2_sl>;
+	};
+
+	/omit-if-no-ref/ ksi3_gp26: periph-kbscan-ksi3 {
+		pinmux = <&alt7_no_ksi3_sl>;
+	};
+
+	/omit-if-no-ref/ ksi4_gp25: periph-kbscan-ksi4 {
+		pinmux = <&alt7_no_ksi4_sl>;
+	};
+
+	/omit-if-no-ref/ ksi5_gp24: periph-kbscan-ksi5 {
+		pinmux = <&alt7_no_ksi5_sl>;
+	};
+
+	/omit-if-no-ref/ ksi6_gp23: periph-kbscan-ksi6 {
+		pinmux = <&alt7_no_ksi6_sl>;
+	};
+
+	/omit-if-no-ref/ ksi7_gp22: periph-kbscan-ksi7 {
+		pinmux = <&alt7_no_ksi7_sl>;
+	};
+
+	/omit-if-no-ref/ kso00_gp21: periph-kbscan-kso00 {
+		pinmux = <&alt8_no_kso00_sl>;
+	};
+
+	/omit-if-no-ref/ kso01_gp20: periph-kbscan-kso01 {
+		pinmux = <&alt8_no_kso01_sl>;
+	};
+
+	/omit-if-no-ref/ kso02_gp17: periph-kbscan-kso02 {
+		pinmux = <&alt8_no_kso02_sl>;
+	};
+
+	/omit-if-no-ref/ kso03_gp16: periph-kbscan-kso03 {
+		pinmux = <&alt8_no_kso03_sl>;
+	};
+
+	/omit-if-no-ref/ kso04_gp15: periph-kbscan-kso04 {
+		pinmux = <&alt8_no_kso04_sl>;
+	};
+
+	/omit-if-no-ref/ kso05_gp14: periph-kbscan-kso05 {
+		pinmux = <&alt8_no_kso05_sl>;
+	};
+
+	/omit-if-no-ref/ kso06_gp13: periph-kbscan-kso06 {
+		pinmux = <&alt8_no_kso06_sl>;
+	};
+
+	/omit-if-no-ref/ kso07_gp12: periph-kbscan-kso07 {
+		pinmux = <&alt8_no_kso07_sl>;
+	};
+
+	/omit-if-no-ref/ kso08_gp11: periph-kbscan-kso08 {
+		pinmux = <&alt9_no_kso08_sl>;
+	};
+
+	/omit-if-no-ref/ kso09_gp10: periph-kbscan-kso09 {
+		pinmux = <&alt9_no_kso09_sl>;
+	};
+
+	/omit-if-no-ref/ kso10_gp07: periph-kbscan-kso10 {
+		pinmux = <&alt9_no_kso10_sl>;
+	};
+
+	/omit-if-no-ref/ kso11_gp06: periph-kbscan-kso11 {
+		pinmux = <&alt9_no_kso11_sl>;
+	};
+
+	/omit-if-no-ref/ kso12_gp05: periph-kbscan-kso12 {
+		pinmux = <&alt9_no_kso12_sl>;
+	};
+
+	/omit-if-no-ref/ kso13_gp04: periph-kbscan-kso13 {
+		pinmux = <&alt9_no_kso13_sl>;
+	};
+
+	/omit-if-no-ref/ kso14_gp82: periph-kbscan-kso14 {
+		pinmux = <&alt9_no_kso14_sl>;
+	};
+
+	/omit-if-no-ref/ kso15_gp83: periph-kbscan-kso15 {
+		pinmux = <&alt9_no_kso15_sl>;
+	};
+
+	/omit-if-no-ref/ kso16_gp03: periph-kbscan-kso16 {
+		pinmux = <&alta_no_kso16_sl>;
+	};
+
+	/omit-if-no-ref/ kso17_gpb1: periph-kbscan-kso17 {
+		pinmux = <&alta_no_kso17_sl>;
+	};
+
+	/* Miscellaneous peripheral interfaces */
+	/omit-if-no-ref/ clk_32k_out_gp75: periph-clk-32k-out {
+		pinmux = <&alta_32k_out_sl>;
+	};
+
+	/omit-if-no-ref/ clk_32k_in_gpe7: periph-clk-32k-in {
+		pinmux = <&alta_32kclkin_sl>;
+	};
+
+	/omit-if-no-ref/ vcc1_rst_gp77: periph-vcc1-rst {
+		pinmux = <&alta_no_vcc1_rst>;
+	};
+
+	/omit-if-no-ref/ peci_dat_gp81: periph-peci-dat {
+		pinmux = <&alta_no_peci_en>;
+	};
+
+	/* Host UART peripheral interfaces */
+	/omit-if-no-ref/ huart_rxd_gp75: periph-host-uart-rxd {
+		pinmux = <&altb_rxd_sl>;
+	};
+
+	/omit-if-no-ref/ huart_txd_gp86: periph-host-uart-txd {
+		pinmux = <&altb_txd_sl>;
+	};
+
+	/omit-if-no-ref/ huart_rts_gp36: periph-host-uart-rts {
+		pinmux = <&altb_rts_sl>;
+	};
+
+	/omit-if-no-ref/ huart_cts_gp33: periph-host-uart-cts {
+		pinmux = <&altb_cts_sl>;
+	};
+
+	/omit-if-no-ref/ huart_ri_gp42: periph-host-uart-ri {
+		pinmux = <&altb_ri_sl>;
+	};
+
+	/omit-if-no-ref/ huart_dtr_bout_gpc7: periph-host-uart-dtr_bout {
+		pinmux = <&altb_dtr_bout_sl>;
+	};
+
+	/omit-if-no-ref/ huart_dcd_gpb3: periph-host-uart-dcd {
+		pinmux = <&altb_dcd_sl>;
+	};
+
+	/omit-if-no-ref/ huart_dsr_gpb2: periph-host-uart-dsr {
+		pinmux = <&altb_dsr_sl>;
+	};
+
+	/* SHI peripheral interfaces */
+	/omit-if-no-ref/ shi_gp46_47_53_55: periph-shi {
+		pinmux = <&altc_shi_sl>;
+		periph-pupd = <0x01 4>;
+	};
+
+	/* FLM peripheral interfaces */
+	/omit-if-no-ref/ flm_gp96_a0_a2_a4: periph-flm {
+		pinmux = <&alth_flm_sl>;
+	};
+
+	/omit-if-no-ref/ flm_quad_gp93_a7: periph-flm-quad {
+		pinmux = <&alth_flm_quad>;
+	};
+
+	/omit-if-no-ref/ flm_mon_md_gpd6: periph-flm-mon-md {
+		pinmux = <&alth_flm_mon_md>;
+	};
+
+
+	/* ADC peripheral interfaces. */
+	/omit-if-no-ref/ adc0_chan0_gp45: periph-adc0-0 {
+		pinmux = <&alt6_adc0_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan1_gp44: periph-adc0-1 {
+		pinmux = <&alt6_adc1_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan2_gp43: periph-adc0-2 {
+		pinmux = <&alt6_adc2_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan3_gp42: periph-adc0-3 {
+		pinmux = <&alt6_adc3_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan4_gp41: periph-adc0-4 {
+		pinmux = <&alt6_adc4_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan5_gp37: periph-adc0-5 {
+		pinmux = <&altf_adc5_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan6_gp34: periph-adc0-6 {
+		pinmux = <&altf_adc6_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan7_gpe1: periph-adc0-7 {
+		pinmux = <&altf_adc7_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan8_gpf1: periph-adc0-8 {
+		pinmux = <&altf_adc8_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan9_gpf0: periph-adc0-9 {
+		pinmux = <&altf_adc9_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan10_gpe0: periph-adc0-10 {
+		pinmux = <&altf_adc10_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan11_gpc7: periph-adc0-11 {
+		pinmux = <&altf_adc11_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan12_gp24: periph-adc0-12 {
+		pinmux = <&altf_adc12_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan13_gp26: periph-adc0-13 {
+		pinmux = <&altl_adc13_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan14_gp27: periph-adc0-14 {
+		pinmux = <&altl_adc14_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan15_gp31: periph-adc0-15 {
+		pinmux = <&altl_adc15_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan16_gp62: periph-adc0-16 {
+		pinmux = <&altl_adc16_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan17_gp63: periph-adc0-17 {
+		pinmux = <&altl_adc17_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan18_gp67: periph-adc0-18 {
+		pinmux = <&altl_adc18_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan19_gp70: periph-adc0-19 {
+		pinmux = <&altl_adc19_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan20_gp22: periph-adc0-20 {
+		pinmux = <&altl_adc20_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan21_gp23: periph-adc0-21 {
+		pinmux = <&altm_adc21_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan22_gpc1: periph-adc0-22 {
+		pinmux = <&altm_adc22_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan23_gp74: periph-adc0-23 {
+		pinmux = <&altm_adc23_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan24_gp25: periph-adc0-24 {
+		pinmux = <&altm_adc24_sl>;
+	};
+
+	/omit-if-no-ref/ adc0_chan25_gp30: periph-adc0-25 {
+		pinmux = <&altm_adc25_sl>;
+	};
+
+	/* PSL peripheral interfaces */
+	/omit-if-no-ref/ psl_in1_gpd2: periph-psl-in1 {
+		pinmux = <&altd_npsl_in1_sl>;
+		psl-offset = <0>;
+		psl-polarity = <&altd_psl_in1_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_in2_gp00: periph-psl-in2 {
+		pinmux = <&altd_npsl_in2_sl>;
+		psl-offset = <1>;
+		psl-polarity = <&altd_psl_in2_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_in3_gp01: periph-psl-in3 {
+		pinmux = <&altd_psl_in3_sl>;
+		psl-offset = <2>;
+		psl-polarity = <&altd_psl_in3_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_in4_gp02: periph-psl-in4 {
+		pinmux = <&altd_psl_in4_sl>;
+		psl-offset = <3>;
+		psl-polarity = <&altd_psl_in4_ahi>;
+	};
+
+	/omit-if-no-ref/ psl_gpo_gpd7: periph-psl-gpo {
+		pinmux = <&altg_psl_gpo_sl>;
+	};
+
+	/omit-if-no-ref/ psl_out_gp85: periph-psl-out {
+		pinmux = <&altg_psl_out_sl>;
+	};
+
+	/* I3C peripheral interfaces */
+	/omit-if-no-ref/ i3c1_sda_scl_gpe3_e4: periph-i3c1 {
+		pinmux = <&altn_i3c1_sl>;
+	};
+
+	/omit-if-no-ref/ i3c2_sda_scl_gp50_56: periph-i3c2 {
+		pinmux = <&altn_i3c2_sl>;
+	};
+
+	/omit-if-no-ref/ i3c3_sda_scl_gpf4_f5: periph-i3c3 {
+		pinmux = <&altn_i3c3_sl>;
+	};
+
+	/* UART peripheral interfaces */
+	/omit-if-no-ref/ uart1_1_sin_gp10: periph-uart1-1-sin {
+		pinmux = <&altj_cr_sin1_sl1>;
+	};
+
+	/omit-if-no-ref/ uart1_1_sout_gp11: periph-uart1-1-sout {
+		pinmux = <&altj_cr_sout1_sl1>;
+	};
+
+	/omit-if-no-ref/ uart1_2_sin_gp64: periph-uart1-2-sin {
+		pinmux = <&altj_cr_sin1_sl2>;
+	};
+
+	/omit-if-no-ref/ uart1_2_sout_gp65: periph-uart1-2-sout {
+		pinmux = <&altj_cr_sout1_sl2>;
+	};
+
+	/omit-if-no-ref/ uart2_sin_gp75: periph-uart2-sin {
+		pinmux = <&altj_cr_sin2_sl>;
+	};
+
+	/omit-if-no-ref/ uart2_sout_gp86: periph-uart2-sout {
+		pinmux = <&altj_cr_sout2_sl>;
+	};
+
+	/omit-if-no-ref/ uart3_sin_gpd4: periph-uart3-sin {
+		pinmux = <&altj_cr_sin3_sl>;
+	};
+
+	/omit-if-no-ref/ uart3_sout_gpd6: periph-uart3-sout {
+		pinmux = <&altj_cr_sout3_sl>;
+	};
+
+	/omit-if-no-ref/ uart4_sin_gpb1: periph-uart4-sin {
+		pinmux = <&alte_cr_sin4_sl>;
+	};
+
+	/omit-if-no-ref/ uart4_sout_gp35: periph-uart4-sout {
+		pinmux = <&alte_cr_sout4_sl>;
+	};
+};
diff --git a/dts/arm/nuvoton/npcx4m3f.dtsi b/dts/arm/nuvoton/npcx4m3f.dtsi
new file mode 100644
index 0000000000..334cd2db65
--- /dev/null
+++ b/dts/arm/nuvoton/npcx4m3f.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <mem.h>
+#include "npcx/npcx4.dtsi"
+
+/ {
+	flash0: flash@10088000 {
+		reg = <0x10088000 DT_SIZE_K(224)>;
+	};
+
+	flash1: flash@60000000 {
+		reg = <0x60000000 DT_SIZE_K(512)>;
+	};
+
+	sram0: memory@200c0000 {
+		compatible = "mmio-sram";
+		reg = <0x200C0000 DT_SIZE_K(96)>;
+	};
+
+	soc-id {
+		device-id = <0x25>;
+	};
+};
+
+&qspi_fiu0 {
+	status = "okay";
+
+	int_flash: w25q40@0 {
+		compatible ="nuvoton,npcx-fiu-nor";
+		size = <DT_SIZE_K(512 * 8)>;
+		reg = <0>;
+		status = "okay";
+
+		/* quad spi bus configuration of nor flash device */
+		qspi-flags = <NPCX_QSPI_SW_CS0>;
+		mapped-addr = <0x60000000>;
+	};
+};
diff --git a/dts/arm/nuvoton/npcx4m8f.dtsi b/dts/arm/nuvoton/npcx4m8f.dtsi
new file mode 100644
index 0000000000..ac141ab31b
--- /dev/null
+++ b/dts/arm/nuvoton/npcx4m8f.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <mem.h>
+#include "npcx/npcx4.dtsi"
+
+/ {
+	flash0: flash@10060000 {
+		reg = <0x10060000 DT_SIZE_K(384)>;
+	};
+
+	flash1: flash@60000000 {
+		reg = <0x60000000 DT_SIZE_M(1)>;
+	};
+
+	sram0: memory@200c0000 {
+		compatible = "mmio-sram";
+		reg = <0x200C0000 DT_SIZE_K(114)>;
+	};
+
+	soc-id {
+		device-id = <0x23>;
+	};
+};
+
+&qspi_fiu0 {
+	status = "okay";
+
+	int_flash: w25q80@0 {
+		compatible ="nuvoton,npcx-fiu-nor";
+		size = <DT_SIZE_M(1 * 8)>;
+		reg = <0>;
+		status = "okay";
+
+		/* quad spi bus configuration of nor flash device */
+		qspi-flags = <NPCX_QSPI_SW_CS0>;
+		mapped-addr = <0x60000000>;
+	};
+};
diff --git a/dts/bindings/clock/nuvoton,npcx-pcc.yaml b/dts/bindings/clock/nuvoton,npcx-pcc.yaml
index 7f66dd0f90..c825390387 100644
--- a/dts/bindings/clock/nuvoton,npcx-pcc.yaml
+++ b/dts/bindings/clock/nuvoton,npcx-pcc.yaml
@@ -23,202 +23,207 @@ compatible: "nuvoton,npcx-pcc"
 include: [clock-controller.yaml, base.yaml]
 
 properties:
-    reg:
-        required: true
+  reg:
+    required: true
 
-    clock-frequency:
-        required: true
-        type: int
-        description: |
-          Default frequency in Hz for HFCG output clock (OFMCLK). Currently,
-          only the following values are allowed:
-            100000000, 100 MHz
-            96000000, 96 MHz
-            90000000, 90 MHz
-            80000000, 80 MHz
-            66000000, 66 MHz
-            50000000, 50 MHz
-            48000000, 48 MHz
-            40000000, 40 MHz (default value after reset)
-            33000000, 33 MHz
-        enum:
-          - 100000000
-          - 96000000
-          - 90000000
-          - 80000000
-          - 66000000
-          - 50000000
-          - 48000000
-          - 40000000
-          - 33000000
+  clock-frequency:
+    required: true
+    type: int
+    description: |
+      Default frequency in Hz for HFCG output clock (OFMCLK). Currently,
+      only the following values are allowed:
+        120000000, 120 MHz
+        100000000, 100 MHz
+        96000000, 96 MHz
+        90000000, 90 MHz
+        80000000, 80 MHz
+        66000000, 66 MHz
+        50000000, 50 MHz
+        48000000, 48 MHz
+    enum:
+      - 120000000
+      - 100000000
+      - 96000000
+      - 90000000
+      - 80000000
+      - 66000000
+      - 50000000
+      - 48000000
 
-    core-prescaler:
-        type: int
-        required: true
-        description: |
-          Core clock prescaler (FPRED). It sets the Core frequency, CORE_CLK, by
-          dividing OFMCLK(MCLK) and needs to meet the following requirements.
-          - CORE_CLK must be set to 4MHz <= CORE_CLK <= 100MHz.
-          = Only the following values are allowed:
-            1, CORE_CLK = OFMCLK
-            2, CORE_CLK = OFMCLK / 2
-            3, CORE_CLK = OFMCLK / 3
-            4, CORE_CLK = OFMCLK / 4
-            5, CORE_CLK = OFMCLK / 5
-            6, CORE_CLK = OFMCLK / 6
-            7, CORE_CLK = OFMCLK / 7
-            8, CORE_CLK = OFMCLK / 8
-            9, CORE_CLK = OFMCLK / 9
-            10, CORE_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  core-prescaler:
+    type: int
+    required: true
+    description: |
+      Core clock prescaler (FPRED). It sets the Core frequency, CORE_CLK, by
+      dividing OFMCLK(MCLK) and needs to meet the following requirements.
+      - CORE_CLK must be set to 4MHz <= CORE_CLK <= 100MHz.
+      = Only the following values are allowed:
+        1, CORE_CLK = OFMCLK
+        2, CORE_CLK = OFMCLK / 2
+        3, CORE_CLK = OFMCLK / 3
+        4, CORE_CLK = OFMCLK / 4
+        5, CORE_CLK = OFMCLK / 5
+        6, CORE_CLK = OFMCLK / 6
+        7, CORE_CLK = OFMCLK / 7
+        8, CORE_CLK = OFMCLK / 8
+        9, CORE_CLK = OFMCLK / 9
+        10, CORE_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb1-prescaler:
-        type: int
-        required: true
-        description: |
-          APB1 prescaler. It sets the APB1 bus frequency, APB1_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB1_CLK must be set to 4MHz <= APB1_CLK <= 50MHz.
-          - APB1_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB1_CLK = OFMCLK
-            2, APB1_CLK = OFMCLK / 2
-            3, APB1_CLK = OFMCLK / 3
-            4, APB1_CLK = OFMCLK / 4
-            5, APB1_CLK = OFMCLK / 5
-            6, APB1_CLK = OFMCLK / 6
-            7, APB1_CLK = OFMCLK / 7
-            8, APB1_CLK = OFMCLK / 8
-            9, APB1_CLK = OFMCLK / 9
-            10, APB1_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb1-prescaler:
+    type: int
+    required: true
+    description: |
+      APB1 prescaler. It sets the APB1 bus frequency, APB1_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB1_CLK must be set to 4MHz <= APB1_CLK <= 50MHz.
+      - APB1_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB1_CLK = OFMCLK
+        2, APB1_CLK = OFMCLK / 2
+        3, APB1_CLK = OFMCLK / 3
+        4, APB1_CLK = OFMCLK / 4
+        5, APB1_CLK = OFMCLK / 5
+        6, APB1_CLK = OFMCLK / 6
+        7, APB1_CLK = OFMCLK / 7
+        8, APB1_CLK = OFMCLK / 8
+        9, APB1_CLK = OFMCLK / 9
+        10, APB1_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb2-prescaler:
-        type: int
-        required: true
-        description: |
-          APB2 prescaler. It sets the APB2 bus frequency, APB2_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB2_CLK must be set to 8MHz <= APB2_CLK <= 50MHz.
-          - APB2_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB2_CLK = OFMCLK
-            2, APB2_CLK = OFMCLK / 2
-            3, APB2_CLK = OFMCLK / 3
-            4, APB2_CLK = OFMCLK / 4
-            5, APB2_CLK = OFMCLK / 5
-            6, APB2_CLK = OFMCLK / 6
-            7, APB2_CLK = OFMCLK / 7
-            8, APB2_CLK = OFMCLK / 8
-            9, APB2_CLK = OFMCLK / 9
-            10, APB2_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb2-prescaler:
+    type: int
+    required: true
+    description: |
+      APB2 prescaler. It sets the APB2 bus frequency, APB2_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB2_CLK must be set to 8MHz <= APB2_CLK <= 50MHz.
+      - APB2_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB2_CLK = OFMCLK
+        2, APB2_CLK = OFMCLK / 2
+        3, APB2_CLK = OFMCLK / 3
+        4, APB2_CLK = OFMCLK / 4
+        5, APB2_CLK = OFMCLK / 5
+        6, APB2_CLK = OFMCLK / 6
+        7, APB2_CLK = OFMCLK / 7
+        8, APB2_CLK = OFMCLK / 8
+        9, APB2_CLK = OFMCLK / 9
+        10, APB2_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb3-prescaler:
-        type: int
-        required: true
-        description: |
-          APB3 prescaler. It sets the APB3 bus frequency, APB3_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB3_CLK must be set to 12.5MHz <= APB3_CLK <= 50MHz.
-          - APB3_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB3_CLK = OFMCLK
-            2, APB3_CLK = OFMCLK / 2
-            3, APB3_CLK = OFMCLK / 3
-            4, APB3_CLK = OFMCLK / 4
-            5, APB3_CLK = OFMCLK / 5
-            6, APB3_CLK = OFMCLK / 6
-            7, APB3_CLK = OFMCLK / 7
-            8, APB3_CLK = OFMCLK / 8
-            9, APB3_CLK = OFMCLK / 9
-            10, APB3_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb3-prescaler:
+    type: int
+    required: true
+    description: |
+      APB3 prescaler. It sets the APB3 bus frequency, APB3_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB3_CLK must be set to 12.5MHz <= APB3_CLK <= 50MHz.
+      - APB3_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB3_CLK = OFMCLK
+        2, APB3_CLK = OFMCLK / 2
+        3, APB3_CLK = OFMCLK / 3
+        4, APB3_CLK = OFMCLK / 4
+        5, APB3_CLK = OFMCLK / 5
+        6, APB3_CLK = OFMCLK / 6
+        7, APB3_CLK = OFMCLK / 7
+        8, APB3_CLK = OFMCLK / 8
+        9, APB3_CLK = OFMCLK / 9
+        10, APB3_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    apb4-prescaler:
-        type: int
-        required: false
-        description: |
-          APB4 prescaler. It sets the APB4 bus frequency, APB4_CLK, by dividing
-          OFMCLK(MCLK) and needs to meet the following requirements.
-          - APB4_CLK must be set to 8MHz <= APB4_CLK <= 50MHz.
-          - APB4_CLK must be an integer division (including 1) of CORE_CLK.
-          = Only the following values are allowed:
-            1, APB4_CLK = OFMCLK
-            2, APB4_CLK = OFMCLK / 2
-            3, APB4_CLK = OFMCLK / 3
-            4, APB4_CLK = OFMCLK / 4
-            5, APB4_CLK = OFMCLK / 5
-            6, APB4_CLK = OFMCLK / 6
-            7, APB4_CLK = OFMCLK / 7
-            8, APB4_CLK = OFMCLK / 8
-            9, APB4_CLK = OFMCLK / 9
-            10, APB4_CLK = OFMCLK / 10
-        enum:
-          - 1
-          - 2
-          - 3
-          - 4
-          - 5
-          - 6
-          - 7
-          - 8
-          - 9
-          - 10
+  apb4-prescaler:
+    type: int
+    required: false
+    description: |
+      APB4 prescaler. It sets the APB4 bus frequency, APB4_CLK, by dividing
+      OFMCLK(MCLK) and needs to meet the following requirements.
+      - APB4_CLK must be set to 8MHz <= APB4_CLK <= 50MHz.
+      - APB4_CLK must be an integer division (including 1) of CORE_CLK.
+      = Only the following values are allowed:
+        1, APB4_CLK = OFMCLK
+        2, APB4_CLK = OFMCLK / 2
+        3, APB4_CLK = OFMCLK / 3
+        4, APB4_CLK = OFMCLK / 4
+        5, APB4_CLK = OFMCLK / 5
+        6, APB4_CLK = OFMCLK / 6
+        7, APB4_CLK = OFMCLK / 7
+        8, APB4_CLK = OFMCLK / 8
+        9, APB4_CLK = OFMCLK / 9
+        10, APB4_CLK = OFMCLK / 10
+    enum:
+      - 1
+      - 2
+      - 3
+      - 4
+      - 5
+      - 6
+      - 7
+      - 8
+      - 9
+      - 10
 
-    ram-pd-depth:
-        required: false
-        type: int
-        enum:
-          - 12
-          - 15
-        description: |
-          Valid bit-depth of RAM block Power-Down control (RAM_PD) registers.
-          Each bit in RAM_PDn can power down the relevant RAM block by setting
-          itself to 1 for better power consumption and this valid bit-depth
-          varies in different NPCX series.
+  ram-pd-depth:
+    type: int
+    enum:
+      - 8
+      - 12
+      - 15
+    description: |
+      Valid bit-depth of RAM block Power-Down control (RAM_PD) registers.
+      Each bit in RAM_PDn can power down the relevant RAM block by setting
+      itself to 1 for better power consumption and this valid bit-depth
+      varies in different NPCX series.
+
+  pwdwn-ctl-val:
+    type: array
+    required: true
+    description: |
+      Power-down (turn off clock) the modules during system initialization for
+      better power consumption.
 
 clock-cells:
-    - bus
-    - ctl
-    - bit
+  - bus
+  - ctl
+  - bit
diff --git a/dts/bindings/espi/nuvoton,npcx-espi.yaml b/dts/bindings/espi/nuvoton,npcx-espi.yaml
index eb5cd9bdb6..61f0057358 100644
--- a/dts/bindings/espi/nuvoton,npcx-espi.yaml
+++ b/dts/bindings/espi/nuvoton,npcx-espi.yaml
@@ -8,25 +8,35 @@ compatible: "nuvoton,npcx-espi"
 include: [espi-controller.yaml, pinctrl-device.yaml]
 
 properties:
-    reg:
-      description: mmio register space
-      required: true
-
-    clocks:
-        required: true
-        description: configurations of device source clock controller
-
-    pinctrl-0:
-        required: true
-
-    pinctrl-names:
-        required: true
-
-    espi-rst-wui:
-        type: phandle
-        required: true
-        description: |
-            Mapping table between Wake-Up Input (WUI) and ESPI_RST signal.
-
-            For example the WUI mapping on NPCX7 would be
-               espi-rst-wui = <&wui_cr_sin1>;
+  reg:
+    description: mmio register space
+    required: true
+
+  clocks:
+    required: true
+    description: configurations of device source clock controller
+
+  pinctrl-0:
+    required: true
+
+  pinctrl-names:
+    required: true
+
+  espi-rst-wui:
+    type: phandle
+    required: true
+    description: |
+        Mapping table between Wake-Up Input (WUI) and ESPI_RST signal.
+
+        For example the WUI mapping on NPCX7 would be
+           espi-rst-wui = <&wui_cr_sin1>;
+
+  rx-plsize:
+    type: int
+    required: true
+    description: The amount of flash receive buffer register.
+
+  tx-plsize:
+    type: int
+    required: true
+    description: The amount of flash transmit buffer register.
diff --git a/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml b/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml
index 17414926b2..50d37d19d8 100644
--- a/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml
+++ b/dts/bindings/iio/adc/nuvoton,npcx-adc.yaml
@@ -8,26 +8,26 @@ compatible: "nuvoton,npcx-adc"
 include: [adc-controller.yaml, pinctrl-device.yaml]
 
 properties:
-    reg:
-        required: true
-    clocks:
-        required: true
-    pinctrl-0:
-        required: true
-    pinctrl-names:
-        required: true
-    channel-count:
-        type: int
-        required: true
-        description: the number of ADC channels
-    threshold-reg-offset:
-        type: int
-        required: true
-        description: the offset of threshold detector register address
-    threshold-count:
-        type: int
-        required: true
-        description: the number of threshold detectors adc supports
+  reg:
+    required: true
+  clocks:
+    required: true
+  pinctrl-0:
+    required: true
+  pinctrl-names:
+    required: true
+  vref-mv:
+    type: int
+    required: true
+    description: ADC reference voltage (Unit:mV)
+  channel-count:
+    type: int
+    required: true
+    description: the number of ADC channels
+  threshold-count:
+    type: int
+    required: true
+    description: the number of threshold detectors adc supports
 
 io-channel-cells:
-    - input
+  - input
diff --git a/include/zephyr/dt-bindings/clock/npck_clock.h b/include/zephyr/dt-bindings/clock/npck_clock.h
new file mode 100644
index 0000000000..9d5a3d4809
--- /dev/null
+++ b/include/zephyr/dt-bindings/clock/npck_clock.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2020 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_CLOCK_H_
+#define ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_CLOCK_H_
+
+/* clock bus references */
+#define NPCX_CLOCK_BUS_FREERUN     0
+#define NPCX_CLOCK_BUS_LFCLK       1
+#define NPCX_CLOCK_BUS_OSC         2
+#define NPCX_CLOCK_BUS_FIU         3
+#define NPCX_CLOCK_BUS_CORE        4
+#define NPCX_CLOCK_BUS_APB1        5
+#define NPCX_CLOCK_BUS_APB2        6
+#define NPCX_CLOCK_BUS_APB3        7
+#define NPCX_CLOCK_BUS_APB4        8
+#define NPCX_CLOCK_BUS_AHB6        9
+#define NPCX_CLOCK_BUS_FMCLK       10
+
+/* clock enable/disable references */
+#define NPCX_PWDWN_CTL0            0
+#define NPCX_PWDWN_CTL1            1
+#define NPCX_PWDWN_CTL2            2
+#define NPCX_PWDWN_CTL3            3
+#define NPCX_PWDWN_CTL4            4
+#define NPCX_PWDWN_CTL5            5
+#define NPCX_PWDWN_CTL6            6
+#define NPCX_PWDWN_CTL_COUNT       7
+
+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCX_CLOCK_H_ */
diff --git a/include/zephyr/dt-bindings/clock/npcx_clock.h b/include/zephyr/dt-bindings/clock/npcx_clock.h
index adca438f2d..713a05c572 100644
--- a/include/zephyr/dt-bindings/clock/npcx_clock.h
+++ b/include/zephyr/dt-bindings/clock/npcx_clock.h
@@ -18,6 +18,8 @@
 #define NPCX_CLOCK_BUS_APB4        8
 #define NPCX_CLOCK_BUS_AHB6        9
 #define NPCX_CLOCK_BUS_FMCLK       10
+#define NPCX_CLOCK_BUS_FIU0        NPCX_CLOCK_BUS_FIU
+#define NPCX_CLOCK_BUS_FIU1        11
 
 /* clock enable/disable references */
 #define NPCX_PWDWN_CTL1            0
diff --git a/include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h b/include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h
new file mode 100644
index 0000000000..99dec3c5f2
--- /dev/null
+++ b/include/zephyr/dt-bindings/flash_controller/npcx_fiu_qspi.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_FIU_QSPI_H_
+#define ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_FIU_QSPI_H_
+
+#include <zephyr/dt-bindings/dt-util.h>
+
+/* Software controlled Chip-Select number for UMA transactions */
+#define NPCX_QSPI_SW_CS0	BIT(0)
+#define NPCX_QSPI_SW_CS1	BIT(1)
+#define NPCX_QSPI_SW_CS2	BIT(2)
+#define NPCX_QSPI_SW_CS_MASK	(NPCX_QSPI_SW_CS0 | NPCX_QSPI_SW_CS1 | NPCX_QSPI_SW_CS2)
+
+/* Supported flash interfaces for UMA transactions */
+#define NPCX_QSPI_SEC_FLASH_SL	BIT(4)
+#define NPCX_QSPI_PVT_FLASH_SL	BIT(5)
+#define NPCX_QSPI_SHD_FLASH_SL	BIT(6)
+#define NPCX_QSPI_BKP_FLASH_SL	BIT(7)
+
+/* Supported read mode for Direct Read Access */
+#define NPCX_RD_MODE_NORMAL	0
+#define NPCX_RD_MODE_FAST	1
+#define NPCX_RD_MODE_FAST_DUAL	3
+
+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_CLOCK_NPCK_FIU_QSPI_H_ */
diff --git a/include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h b/include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h
new file mode 100644
index 0000000000..70d20ee629
--- /dev/null
+++ b/include/zephyr/dt-bindings/gpio/nuvoton-npcx-gpio.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2022 Nordic Semiconductor ASA
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_GPIO_NUVOTON_NPCX_GPIO_H_
+#define ZEPHYR_INCLUDE_DT_BINDINGS_GPIO_NUVOTON_NPCX_GPIO_H_
+
+/**
+ * @name GPIO pin voltage flags
+ *
+ * The voltage flags are a Zephyr specific extension of the standard GPIO flags
+ * specified by the Linux GPIO binding for use with the Nuvoton NPCX SoCs.
+ *
+ * @{
+ */
+
+/** @cond INTERNAL_HIDDEN */
+#define NPCX_GPIO_VOLTAGE_POS	11
+#define NPCX_GPIO_VOLTAGE_MASK	(1U << NPCX_GPIO_VOLTAGE_POS)
+/** @endcond */
+
+/** Set pin at the default voltage level (3.3V) */
+#define NPCX_GPIO_VOLTAGE_DEFAULT	(0U << NPCX_GPIO_VOLTAGE_POS)
+/** Set pin voltage level at 1.8 V */
+#define NPCX_GPIO_VOLTAGE_1P8		(1U << NPCX_GPIO_VOLTAGE_POS)
+
+/** @} */
+
+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_GPIO_NUVOTON_NPCX_GPIO_H_ */
diff --git a/soc/arm/nuvoton_npcx/Kconfig b/soc/arm/nuvoton_npcx/Kconfig
index ac5daf8e0b..8bf9bc6317 100644
--- a/soc/arm/nuvoton_npcx/Kconfig
+++ b/soc/arm/nuvoton_npcx/Kconfig
@@ -37,11 +37,14 @@ config NPCX_IMAGE_OUTPUT_HEX
 
 config NPCX_HEADER_CHIP
 	string
+	default "npck3m7" if SOC_NPCK3M7K
 	default "npcx7m6" if SOC_NPCX7M6FB || SOC_NPCX7M6FC
 	default "npcx7m7" if SOC_NPCX7M7FC
 	default "npcx9m3" if SOC_NPCX9M3F
 	default "npcx9m6" if SOC_NPCX9M6F
 	default "npcx9m7" if SOC_NPCX9M7F
+	default "npcx4m3" if SOC_NPCX4M3F
+	default "npcx4m8" if SOC_NPCX4M8F
 
 choice NPCX_HEADER_SPI_MAX_CLOCK_CHOICE
 	prompt "Clock rate to use for SPI flash"
@@ -139,7 +142,8 @@ config NPCX_HEADER_ENABLE_FIRMWARE_CRC
 choice NPCX_HEADER_FLASH_SIZE_CHOICE
 	prompt "Flash size"
 	default NPCX_HEADER_FLASH_SIZE_0P5M_1M if SOC_SERIES_NPCX7 || \
-						  SOC_SERIES_NPCX9
+						  SOC_SERIES_NPCX9 || \
+						  SOC_SERIES_NPCK3
 	default NPCX_HEADER_FLASH_SIZE_16M
 	help
 	  This sets the SPI flash size.
diff --git a/soc/arm/nuvoton_npcx/common/ecst/ecst.py b/soc/arm/nuvoton_npcx/common/ecst/ecst.py
old mode 100755
new mode 100644
index 33c2fe1c40..ff5be14302
--- a/soc/arm/nuvoton_npcx/common/ecst/ecst.py
+++ b/soc/arm/nuvoton_npcx/common/ecst/ecst.py
@@ -213,8 +213,8 @@ def _check_chip(output, ecst_args):
 
     if ecst_args.chip_name == INVALID_INPUT:
         message = f'Invalid chip name, '
-        message += "should be npcx9m8, npcx9m7, npcx9m6, npcx7m7," \
-                   " npcx7m6, npcx7m5, npcx5m5 or npcx5m6."
+        message += "should be npcx4m3, npcx4m8, npcx9m8, npcx9m7, npcx9m6, " \
+                   "npcx7m7, npcx7m6, npcx7m5, npck3m7k."
         _exit_with_failure_delete_file(output, message)
 
 def _set_anchor(output, ecst_args):
@@ -924,7 +924,7 @@ def _crc_update(cur, crc, table):
     :param crc
     :param table
     """
-    l_crc = (0x000000ff & cur)
+    l_crc = 0x000000ff & cur
 
     tmp = crc ^ l_crc
     crc = (crc >> 8) ^ table[(tmp & 0xff)]
diff --git a/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py b/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
old mode 100755
new mode 100644
index c596760e34..7da4e2ac15
--- a/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
+++ b/soc/arm/nuvoton_npcx/common/ecst/ecst_args.py
@@ -47,12 +47,15 @@ POINTER_OFFSET_DEFAULT = 0x0
 
 # Chips: convert from name to index.
 CHIPS_INFO = {
+    'npck3m7': {'ram_address': 0x10070000, 'ram_size': 0x50000},
     'npcx7m5': {'ram_address': 0x100a8000, 'ram_size': 0x20000},
     'npcx7m6': {'ram_address': 0x10090000, 'ram_size': 0x40000},
     'npcx7m7': {'ram_address': 0x10070000, 'ram_size': 0x60000},
     'npcx9m3': {'ram_address': 0x10080000, 'ram_size': 0x50000},
     'npcx9m6': {'ram_address': 0x10090000, 'ram_size': 0x40000},
     'npcx9m7': {'ram_address': 0x10070000, 'ram_size': 0x60000},
+    'npcx4m3': {'ram_address': 0x10088000, 'ram_size': 0x50000},
+    'npcx4m8': {'ram_address': 0x10060000, 'ram_size': 0x7c800},
 }
 DEFAULT_CHIP = 'npcx7m6'
 
@@ -180,7 +183,7 @@ def _create_parser(arg_list):
     else parses the given string
     """
 
-    parser = argparse.ArgumentParser(conflict_handler='resolve')
+    parser = argparse.ArgumentParser(conflict_handler='resolve', allow_abbrev=False)
     parser.add_argument("-i", nargs='?', dest="input")
     parser.add_argument("-o", nargs='?', dest="output")
     parser.add_argument("-chip", dest="chip")
diff --git a/soc/arm/nuvoton_npcx/common/pinctrl_soc.h b/soc/arm/nuvoton_npcx/common/pinctrl_soc.h
index cd8af7584b..8f03faa82b 100644
--- a/soc/arm/nuvoton_npcx/common/pinctrl_soc.h
+++ b/soc/arm/nuvoton_npcx/common/pinctrl_soc.h
@@ -16,6 +16,7 @@
  */
 enum npcx_pinctrl_type {
 	NPCX_PINCTRL_TYPE_PERIPH,
+	NPCX_PINCTRL_TYPE_DEVICE_CTRL,
 	NPCX_PINCTRL_TYPE_PSL_IN,
 	NPCX_PINCTRL_TYPE_RESERVED,
 };
@@ -81,6 +82,23 @@ struct npcx_periph {
 	uint16_t reserved: 2;
 } __packed;
 
+/**
+ * @brief NPCX device control structure
+ *
+ * Used to indicate the device's corresponding register/field for its io
+ * characteristics such as tri-state, power supply type selection, and so on.
+ */
+struct npcx_dev_ctl {
+	/** Related register offset for device configuration. */
+	uint16_t offest: 5;
+	/** Related register field offset for device control. */
+	uint16_t field_offset: 3;
+	/** Related register field size for device control. */
+	uint16_t field_size: 3;
+	/** field value */
+	uint16_t field_value: 5;
+} __packed;
+
 /**
  * @brief NPCX Power Switch Logic (PSL) input pad configuration structure
  *
@@ -103,6 +121,7 @@ struct npcx_psl_input {
 struct npcx_pinctrl {
 	union {
 		struct npcx_periph periph;
+		struct npcx_dev_ctl dev_ctl;
 		struct npcx_psl_input psl_in;
 		uint16_t cfg_word;
 	} cfg;
@@ -163,6 +182,21 @@ typedef struct npcx_pinctrl pinctrl_soc_pin_t;
 		.cfg.periph.inverted = DT_PHA(DT_PROP(node_id, prop), alts, inv),	\
 	},
 
+/**
+ * @brief Utility macro to initialize a periphral pinmux configuration.
+ *
+ * @param node_id Node identifier.
+ * @param prop Property name for pinmux configuration. (i.e. 'pinmux')
+ */
+#define Z_PINCTRL_NPCX_DEVICE_CONTROL_INIT(node_id, prop)			\
+	{									\
+		.flags.type = NPCX_PINCTRL_TYPE_DEVICE_CTRL,			\
+		.cfg.dev_ctl.offest = DT_PROP_BY_IDX(node_id, prop, 0),		\
+		.cfg.dev_ctl.field_offset = DT_PROP_BY_IDX(node_id, prop, 1),	\
+		.cfg.dev_ctl.field_size = DT_PROP_BY_IDX(node_id, prop, 2),	\
+		.cfg.dev_ctl.field_value = DT_PROP_BY_IDX(node_id, prop, 3),	\
+	},
+
 /**
  * @brief Utility macro to initialize a periphral pull-up/down configuration.
  *
@@ -227,6 +261,9 @@ typedef struct npcx_pinctrl pinctrl_soc_pin_t;
 	COND_CODE_1(Z_PINCTRL_NPCX_HAS_PSL_IN_PROP(DT_PROP_BY_IDX(node_id, prop, idx)),	\
 		(Z_PINCTRL_NPCX_PSL_IN_DETECT_CONF_INIT(				\
 			DT_PROP_BY_IDX(node_id, prop, idx), psl_polarity)), ())		\
+	COND_CODE_1(DT_NODE_HAS_PROP(DT_PROP_BY_IDX(node_id, prop, idx), dev_ctl),	\
+		(Z_PINCTRL_NPCX_DEVICE_CONTROL_INIT(					\
+			DT_PROP_BY_IDX(node_id, prop, idx), dev_ctl)), ())		\
 	COND_CODE_1(DT_NODE_HAS_PROP(DT_PROP_BY_IDX(node_id, prop, idx), pinmux),	\
 		(Z_PINCTRL_NPCX_PERIPH_PINMUX_INIT(					\
 			DT_PROP_BY_IDX(node_id, prop, idx), pinmux)), ())
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_access.h b/soc/arm/nuvoton_npcx/common/reg/reg_access.h
index 4f302f5146..90bf73a866 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_access.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_access.h
@@ -27,4 +27,8 @@
 	((reg) = ((reg) & (~(((1 << (f_size))-1) << (f_pos)))) \
 			| ((value) << (f_pos)))
 
+#define GET_POS(field) \
+	_GET_POS_(FIELD_POS(field))
+#define _GET_POS_(f_ops) f_ops
+
 #endif /* _NUVOTON_NPCX_REG_ACCESS_H */
diff --git a/soc/arm/nuvoton_npcx/common/reg/reg_def.h b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
index c428a06342..861291bbf2 100644
--- a/soc/arm/nuvoton_npcx/common/reg/reg_def.h
+++ b/soc/arm/nuvoton_npcx/common/reg/reg_def.h
@@ -131,19 +131,9 @@ struct pmc_reg {
 	volatile uint8_t PWDWN_CTL7[1];
 };
 
-/* PMC internal inline functions for multi-registers */
-static inline uint32_t npcx_pwdwn_ctl_offset(uint32_t ctl_no)
-{
-	if (ctl_no < 6) {
-		return 0x008 + ctl_no;
-	} else {
-		return 0x024 + ctl_no - 6;
-	}
-}
-
 /* Macro functions for PMC multi-registers */
-#define NPCX_PWDWN_CTL(base, n) (*(volatile uint8_t *)(base + \
-						npcx_pwdwn_ctl_offset(n)))
+#define NPCX_PWDWN_CTL(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_PWDWN_CTL_OFFSET(n)))
 
 /* PMC register fields */
 #define NPCX_PMCSR_DI_INSTW                   0
@@ -158,6 +148,48 @@ static inline uint32_t npcx_pwdwn_ctl_offset(uint32_t ctl_no)
 #define NPCX_ENIDL_CTL_PECI_ENI               2
 #define NPCX_ENIDL_CTL_ADC_ACC_DIS            1
 
+/* Macro functions for Development and Debugger Interface (DDI) registers */
+#define NPCX_DBGCTRL(base)   (*(volatile uint8_t *)(base + 0x004))
+#define NPCX_DBGFRZEN1(base) (*(volatile uint8_t *)(base + 0x006))
+#define NPCX_DBGFRZEN2(base) (*(volatile uint8_t *)(base + 0x007))
+#define NPCX_DBGFRZEN3(base) (*(volatile uint8_t *)(base + 0x008))
+#define NPCX_DBGFRZEN4(base) (*(volatile uint8_t *)(base + 0x009))
+
+/* DDI register fields */
+#define NPCX_DBGCTRL_CCDEV_SEL		FIELD(6, 2)
+#define NPCX_DBGCTRL_CCDEV_DIR		5
+#define NPCX_DBGCTRL_SEQ_WK_EN		4
+#define NPCX_DBGCTRL_FRCLK_SEL_DIS	3
+#define NPCX_DBGFRZEN1_SPIFEN		7
+#define NPCX_DBGFRZEN1_HIFEN		6
+#define NPCX_DBGFRZEN1_ESPISEN		5
+#define NPCX_DBGFRZEN1_UART1FEN		4
+#define NPCX_DBGFRZEN1_SMB3FEN		3
+#define NPCX_DBGFRZEN1_SMB2FEN		2
+#define NPCX_DBGFRZEN1_MFT2FEN		1
+#define NPCX_DBGFRZEN1_MFT1FEN		0
+#define NPCX_DBGFRZEN2_ITIM6FEN		7
+#define NPCX_DBGFRZEN2_ITIM5FEN		6
+#define NPCX_DBGFRZEN2_ITIM4FEN		5
+#define NPCX_DBGFRZEN2_ITIM64FEN	3
+#define NPCX_DBGFRZEN2_SMB1FEN		2
+#define NPCX_DBGFRZEN2_SMB0FEN		1
+#define NPCX_DBGFRZEN2_MFT3FEN		0
+#define NPCX_DBGFRZEN3_GLBL_FRZ_DIS	7
+#define NPCX_DBGFRZEN3_ITIM3FEN		6
+#define NPCX_DBGFRZEN3_ITIM2FEN		5
+#define NPCX_DBGFRZEN3_ITIM1FEN		4
+#define NPCX_DBGFRZEN3_I3CFEN		2
+#define NPCX_DBGFRZEN3_SMB4FEN		1
+#define NPCX_DBGFRZEN3_SHMFEN		0
+#define NPCX_DBGFRZEN4_UART2FEN		6
+#define NPCX_DBGFRZEN4_UART3FEN		5
+#define NPCX_DBGFRZEN4_UART4FEN		4
+#define NPCX_DBGFRZEN4_LCTFEN		3
+#define NPCX_DBGFRZEN4_SMB7FEN		2
+#define NPCX_DBGFRZEN4_SMB6FEN		1
+#define NPCX_DBGFRZEN4_SMB5FEN		0
+
 /*
  * System Configuration (SCFG) device registers
  */
@@ -168,7 +200,16 @@ struct scfg_reg {
 	volatile uint8_t STRPST;
 	/* 0x002: Reset Control and Status */
 	volatile uint8_t RSTCTL;
-	volatile uint8_t reserved1[3];
+	/* 0x003: Reset Control and Status */
+	volatile uint8_t reserved5;
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	/* 0x004: Reset Control and Status */
+	volatile uint8_t DEV_CTL3;
+#else
+	volatile uint8_t reserved6;
+#endif /* CONFIG_SOC_SERIES_NPCK3 */
+	/* 0x005: Reset Control and Status */
+	volatile uint8_t reserved7;
 	/* 0x006: Device Control 4 */
 	volatile uint8_t DEV_CTL4;
 	volatile uint8_t reserved2[9];
@@ -186,40 +227,17 @@ struct scfg_reg {
 	volatile uint8_t LV_GPIO_CTL0[5];
 };
 
-/* SCFG internal inline functions for multi-registers */
-static inline uint32_t npcx_devalt_offset(uint32_t alt_no)
-{
-	return 0x010 + alt_no;
-}
-
-static inline uint32_t npcx_devalt_lk_offset(uint32_t alt_lk_no)
-{
-	return 0x210 + alt_lk_no;
-}
-
-static inline uint32_t npcx_pupd_en_offset(uint32_t pupd_en_no)
-{
-	return 0x28 + pupd_en_no;
-}
-
-static inline uint32_t npcx_lv_gpio_ctl_offset(uint32_t ctl_no)
-{
-	if (ctl_no < 5) {
-		return 0x02a + ctl_no;
-	} else {
-		return 0x026 + ctl_no - 5;
-	}
-}
-
 /* Macro functions for SCFG multi-registers */
-#define NPCX_DEVALT(base, n) (*(volatile uint8_t *)(base + \
-						npcx_devalt_offset(n)))
-#define NPCX_DEVALT_LK(base, n) (*(volatile uint8_t *)(base + \
-						npcx_devalt_lk_offset(n)))
-#define NPCX_PUPD_EN(base, n) (*(volatile uint8_t *)(base + \
-						npcx_pupd_en_offset(n)))
-#define NPCX_LV_GPIO_CTL(base, n) (*(volatile uint8_t *)(base + \
-						npcx_lv_gpio_ctl_offset(n)))
+#define NPCX_DEV_CTL(base, n) \
+	(*(volatile uint8_t *)(base + n))
+#define NPCX_DEVALT(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_DEVALT_OFFSET(n)))
+#define NPCX_DEVALT_LK(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_DEVALT_LK_OFFSET(n)))
+#define NPCX_PUPD_EN(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_PUPD_EN_OFFSET(n)))
+#define NPCX_LV_GPIO_CTL(base, n) \
+	(*(volatile uint8_t *)(base + NPCX_LV_GPIO_CTL_OFFSET(n)))
 
 /* SCFG register fields */
 #define NPCX_DEVCNT_F_SPI_TRIS                6
@@ -278,6 +296,30 @@ struct glue_reg {
 	volatile uint8_t reserved6[5];
 	/* 0x027: PSL Control and Status */
 	volatile uint8_t PSL_CTS;
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	/* 0x028: PSL IN Posetive Edge Status */
+	volatile uint8_t PSL_IN_POS;
+	/* 0x029: PSL IN Negative Edge Status */
+	volatile uint8_t PSL_IN_NEG;
+	/* 0x02a: Voltage Detection Down Threshold */
+	volatile uint8_t VD_THD;
+	/* 0x02b: Voltage Detection Up Threshold */
+	volatile uint8_t VD_THU;
+	/* 0x02c: Voltage Detection Control */
+	volatile uint8_t VD_CTL;
+	/* 0x02d: Voltage Detection Control and Status */
+	volatile uint8_t VD_CTS;
+	volatile uint8_t reserved7[2];
+	/* 0x030: Exteral Power-Up Reset Control */
+	volatile uint8_t EPURST_CTL;
+	volatile uint8_t reserved8[7];
+	/* 0x038: PSL Control and Status 3 */
+	volatile uint8_t PSL_CTS3;
+	/* 0x039: PSL Control and Status 3 */
+	volatile uint8_t PSL_CTS4;
+	/* 0x03a: I3CI maxRd value */
+	volatile uint8_t I3CI_MAXRD;
+#endif
 };
 
 /* GLUE register fields */
@@ -313,6 +355,18 @@ struct uart_reg {
 	volatile uint8_t reserved7;
 	/* 0x00E: Baud Rate Prescaler */
 	volatile uint8_t UPSR;
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	volatile uint8_t reserved8[7];
+	/* 0x16: FIFO Control */
+	volatile uint8_t UFCTRL;
+	volatile uint8_t reserved9;
+	/* 0x18: TX FIFO Current Level */
+	volatile uint8_t UTXFLV;
+	volatile uint8_t reserved10;
+	/* 0x1A: RX FIFO Current Level Byte */
+	volatile uint8_t URXFLV;
+	volatile uint8_t reserved11[12];
+#else
 	volatile uint8_t reserved8[17];
 	/* 0x020: FIFO Mode Transmit Status */
 	volatile uint8_t UFTSTS;
@@ -325,6 +379,7 @@ struct uart_reg {
 	volatile uint8_t reserved11;
 	/* 0x026: FIFO Mode Receive Control */
 	volatile uint8_t UFRCTL;
+#endif
 };
 
 /* UART register fields */
@@ -362,95 +417,21 @@ struct uart_reg {
 #define NPCX_UFRCTL_RNEMPTY_EN                6
 #define NPCX_UFRCTL_ERR_EN                    7
 
-/*
- * Multi-Input Wake-Up Unit (MIWU) device registers
- */
-
-/* MIWU internal inline functions for multi-registers */
-static inline uint32_t npcx_wkedg_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x000 + (group * 2ul) + (group < 5 ? 0 : 0x1e);
-	} else { /* NPCX9 and later series */
-		return 0x000 + group * 0x10UL;
-	}
-}
-
-static inline uint32_t npcx_wkaedg_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x001 + (group * 2ul) + (group < 5 ? 0 : 0x1e);
-	} else { /* NPCX9 and later series */
-		return 0x001 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkmod_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x070 + group;
-	} else { /* NPCX9 and later series */
-		return 0x002 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkpnd_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x00a + (group * 4ul) + (group < 5 ? 0 : 0x10);
-	} else { /* NPCX9 and later series */
-		return 0x003 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkpcl_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x00c + (group * 4ul) + (group < 5 ? 0 : 0x10);
-	} else { /* NPCX9 and later series */
-		return 0x004 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wken_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x01e + (group * 2ul) + (group < 5 ? 0 : 0x12);
-	} else { /* NPCX9 and later series */
-		return 0x005 + group * 0x10ul;
-	}
-}
-
-static inline uint32_t npcx_wkst_offset(uint32_t group)
-{
-	/* NPCX9 and later series only */
-	return 0x006 + group * 0x10ul;
-}
-
-static inline uint32_t npcx_wkinen_offset(uint32_t group)
-{
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		return 0x01f + (group * 2ul) + (group < 5 ? 0 : 0x12);
-	} else { /* NPCX9 and later series */
-		return 0x007 + group * 0x10ul;
-	}
-}
-
 /* Macro functions for MIWU multi-registers */
 #define NPCX_WKEDG(base, group) \
-	(*(volatile uint8_t *)(base +  npcx_wkedg_offset(group)))
+	(*(volatile uint8_t *)(base +  NPCX_WKEDG_OFFSET(group)))
 #define NPCX_WKAEDG(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkaedg_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKAEDG_OFFSET(group)))
 #define NPCX_WKPND(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkpnd_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKPND_OFFSET(group)))
 #define NPCX_WKPCL(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkpcl_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKPCL_OFFSET(group)))
 #define NPCX_WKEN(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wken_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKEN_OFFSET(group)))
 #define NPCX_WKINEN(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkinen_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKINEN_OFFSET(group)))
 #define NPCX_WKMOD(base, group) \
-	(*(volatile uint8_t *)(base + npcx_wkmod_offset(group)))
+	(*(volatile uint8_t *)(base + NPCX_WKMOD_OFFSET(group)))
 
 /*
  * General-Purpose I/O (GPIO) device registers
@@ -515,7 +496,9 @@ struct adc_reg {
 	volatile uint16_t ASCADD;
 	/* 0x008: ADC Scan Channels Select */
 	volatile uint16_t ADCCS;
-	volatile uint8_t reserved1[16];
+	/* 0x00A: ADC Scan Channels Select 2 */
+	volatile uint16_t ADCCS2;
+	volatile uint8_t reserved1[14];
 	/* 0x01A:  Threshold Status */
 	volatile uint16_t THRCTS;
 	volatile uint8_t reserved2[4];
@@ -528,12 +511,11 @@ struct adc_reg {
 	volatile uint16_t MEAST;
 };
 
-static inline uint32_t npcx_chndat_offset(uint32_t ch)
-{
-	return 0x40 + ch * 2;
-}
-
-#define CHNDAT(base, ch) (*(volatile uint16_t *)((base) + npcx_chndat_offset(ch)))
+/* ADC internal inline functions for multi-registers */
+#define CHNDAT(base, ch) \
+	(*(volatile uint16_t *)((base) + NPCX_CHNDAT_OFFSET(ch)))
+#define THRCTL(base, ctrl) \
+	(*(volatile uint16_t *)(base + NPCX_THRCTL_OFFSET(ctrl)))
 
 /* ADC register fields */
 #define NPCX_ATCTL_SCLKDIV_FIELD              FIELD(0, 6)
@@ -553,10 +535,6 @@ static inline uint32_t npcx_chndat_offset(uint32_t ch)
 #define NPCX_ADCCNF_STOP                      11
 #define NPCX_CHNDAT_CHDAT_FIELD               FIELD(0, 10)
 #define NPCX_CHNDAT_NEW                       15
-#define NPCX_THRCTL_THEN                      15
-#define NPCX_THRCTL_L_H                       14
-#define NPCX_THRCTL_CHNSEL                    FIELD(10, 4)
-#define NPCX_THRCTL_THRVAL                    FIELD(0, 10)
 #define NPCX_THRCTS_ADC_WKEN                  15
 #define NPCX_THRCTS_THR3_IEN                  10
 #define NPCX_THRCTS_THR2_IEN                  9
@@ -617,80 +595,127 @@ struct twd_reg {
  * Enhanced Serial Peripheral Interface (eSPI) device registers
  */
 struct espi_reg {
-	/* 0x000: eSPI Identification */
+	/* 0x000 - 0x003: eSPI Identification */
 	volatile uint32_t ESPIID;
-	/* 0x004: eSPI Configuration */
+	/* 0x004 - 0x007: eSPI Configuration */
 	volatile uint32_t ESPICFG;
-	/* 0x008: eSPI Status */
+	/* 0x008 - 0x00B: eSPI Status */
 	volatile uint32_t ESPISTS;
-	/* 0x00C: eSPI Interrupt Enable */
+	/* 0x00C - 0x00F: eSPI Interrupt Enable */
 	volatile uint32_t ESPIIE;
-	/* 0x010: eSPI Wake-Up Enable */
+	/* 0x010 - 0x013: eSPI Wake-Up Enable */
 	volatile uint32_t ESPIWE;
-	/* 0x014: Virtual Wire Register Index */
+	/* 0x014 - 0x017: Virtual Wire Register Index */
 	volatile uint32_t VWREGIDX;
-	/* 0x018: Virtual Wire Register Data */
+	/* 0x018 - 0x01B: Virtual Wire Register Data */
 	volatile uint32_t VWREGDATA;
-	/* 0x01C: OOB Receive Buffer Read Head */
+	/* 0x01C - 0x01F: OOB Receive Buffer Read Head */
 	volatile uint32_t OOBRXRDHEAD;
-	/* 0x020: OOB Transmit Buffer Write Head */
+	/* 0x020 - 0x023: OOB Transmit Buffer Write Head */
 	volatile uint32_t OOBTXWRHEAD;
-	/* 0x024: OOB Channel Control */
+	/* 0x024 - 0x027: OOB Channel Control */
 	volatile uint32_t OOBCTL;
-	/* 0x028: Flash Receive Buffer Read Head */
+	/* 0x028 - 0x02B: Flash Receive Buffer Read Head */
 	volatile uint32_t FLASHRXRDHEAD;
-	/* 0x02C: Flash Transmit Buffer Write Head */
+	/* 0x02C - 0x02F: Flash Transmit Buffer Write Head */
 	volatile uint32_t FLASHTXWRHEAD;
+	/* 0x030 - 0x033 */
 	volatile uint32_t reserved1;
-	/* 0x034: Flash Channel Configuration */
+	/* 0x034 - 0x037: Flash Channel Configuration */
 	volatile uint32_t FLASHCFG;
-	/* 0x038: Flash Channel Control */
+	/* 0x038 - 0x03B: Flash Channel Control */
 	volatile uint32_t FLASHCTL;
-	/* 0x03C: eSPI Error Status */
+	/* 0x03C - 0x03F: eSPI Error Status */
 	volatile uint32_t ESPIERR;
-	/* 0x040: Peripheral Bus Master Receive Buffer Read Head */
+	/* 0x040 - 0x043: Peripheral Bus Master Receive Buffer Read Head */
 	volatile uint32_t PBMRXRDHEAD;
-	/* 0x044: Peripheral Bus Master Transmit Buffer Write Head */
+	/* 0x044 - 0x047: Peripheral Bus Master Transmit Buffer Write Head */
 	volatile uint32_t PBMTXWRHEAD;
-	/* 0x048: Peripheral Channel Configuration */
+	/* 0x048 - 0x04B: Peripheral Channel Configuration */
 	volatile uint32_t PERCFG;
-	/* 0x04C: Peripheral Channel Control */
+	/* 0x04C - 0x04F: Peripheral Channel Control */
 	volatile uint32_t PERCTL;
-	/* 0x050: Status Image Register */
+	/* 0x050 - 0x051: Status Image Register */
 	volatile uint16_t STATUS_IMG;
-	volatile uint16_t reserved2[79];
+	/* 0x052 - 0x053 */
+	volatile uint16_t reserved2;
+	/* 0x054 - 0x055: eSPI SAF Lock Control */
+	volatile uint16_t SAFLOCKCTL;
+	/* 0x056 - 0x057 */
+	volatile uint16_t reserved3;
+	/* 0x058 - 0x059: eSPI SAF illegal Access Region */
+	volatile uint16_t SAFILL_REG;
+	/* 0x05A - 0x05B */
+	volatile uint16_t reserved4;
+	/* 0x05C - 0x05D: Protection Region Dirty Access */
+	volatile uint16_t PRDIRTY;
+	/* 0x05E - 0x0EF */
+	volatile uint16_t reserved5[73];
 	/* 0x0F0: NPCX specific eSPI Register1 */
 	volatile uint8_t NPCX_ONLY_ESPI_REG1;
 	/* 0x0F1: NPCX specific eSPI Register2 */
 	volatile uint8_t NPCX_ONLY_ESPI_REG2;
-	volatile uint16_t reserved3[7];
+	/* 0x0F2 - 0x0FF */
+	volatile uint16_t reserved6[7];
 	/* 0x100 - 127: Virtual Wire Event Slave-to-Master 0 - 9 */
 	volatile uint32_t VWEVSM[10];
-	volatile uint32_t reserved4[6];
+	/* 0x128 - 0x13B*/
+	volatile uint32_t reserved7[5];
+	/* 0x13C - 0x13F: Virtual Wire Software IRQ Register */
+	volatile uint32_t VWSWIRQ;
 	/* 0x140 - 16F: Virtual Wire Event Master-to-Slave 0 - 11 */
 	volatile uint32_t VWEVMS[12];
-	volatile uint32_t reserved5[4];
+	/* 0x170 - 0x17F*/
+	volatile uint32_t reserved8[4];
 	/* 0x180 - 1BF: Virtual Wire GPIO Event Master-to-Slave 0 - 15 */
 	volatile uint32_t VWGPSM[16];
-	volatile uint32_t reserved6[79];
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	volatile uint32_t reserved6_1[16];
+	/* 0x200: Virtual Wire Event Master-to-Slave Status */
+	volatile uint32_t VWEVMSSTS;
+	volatile uint32_t reserved6_2;
+	/* 0x208: Virtual Wire Event Slave-to-Master Type */
+	volatile uint32_t VWEVSMTYPE;
+	volatile uint32_t reserved6_3[60];
+#else
+	volatile uint32_t reserved6_1[79];
+#endif
 	/* 0x2FC: Virtual Wire Channel Control */
 	volatile uint32_t VWCTL;
-	/* 0x300 - 34F: OOB Receive Buffer 0 - 19 */
+	/* 0x300 - 0x34F: OOB Receive Buffer 0 - 19 */
 	volatile uint32_t OOBRXBUF[20];
-	volatile uint32_t reserved7[12];
+	/* 0x350 - 0x37F */
+	volatile uint32_t reserved11[12];
 	/* 0x380 - 3CF: OOB Transmit Buffer 0-19 */
 	volatile uint32_t OOBTXBUF[20];
-	volatile uint32_t reserved8[11];
-	/* 0x3FC: OOB Channel Control used in 'direct' mode */
+	/* 0x3D0 - 0x3FB */
+	volatile uint32_t reserved12[11];
+	/* 0x3FC - 0x3FF: OOB Channel Control used in 'direct' mode */
 	volatile uint32_t OOBCTL_DIRECT;
-	/* 0x400 - 443: Flash Receive Buffer 0-16 */
-	volatile uint32_t FLASHRXBUF[17];
-	volatile uint32_t reserved9[15];
-	/* 0x480 - 497: Flash Transmit Buffer 0-5 */
-	volatile uint32_t FLASHTXBUF[6];
-	volatile uint32_t reserved10[25];
-	/* 0x4FC: Flash Channel Control used in 'direct' mode */
+	/* 0x400 - 0x447: Flash Receive Buffer 0-17 */
+	volatile uint32_t FLASHRXBUF[18];
+	/* 0x448 - 0x47F */
+	volatile uint32_t reserved13[14];
+	/* 0x480 - 0x4C3: Flash Transmit Buffer 0-16 */
+	volatile uint32_t FLASHTXBUF[17];
+	/* 0x4C4 - 0x4EF */
+	volatile uint32_t reserved14[11];
+	/* 0x4F0 - 0x4F3: Flash base */
+	volatile uint32_t FLASHBASE;
+	/* 0x4F4 - 0x4FB*/
+	volatile uint32_t reserved15[2];
+	/* 0x4FC - 0x4FF: Flash Channel Control used in 'direct' mode */
 	volatile uint32_t FLASHCTL_DIRECT;
+	/* 0x500 - 0x5FF */
+	volatile uint32_t reserved16[64];
+	/* 0x600 - 0x64F */
+	volatile uint32_t FLASH_PRTR_BADDR[20];
+	/* 0x650 - 0x69F */
+	volatile uint32_t FLASH_PRTR_HADDR[20];
+	/* 0x6A0 - 0x6EF */
+	volatile uint32_t FLASH_RGN_TAG_OVR[20];
+	/* 0x6F0 - 0x8FF*/
+	volatile uint32_t reserved17[132];
 };
 
 /* eSPI register fields */
@@ -706,6 +731,11 @@ struct espi_reg {
 #define NPCX_ESPICFG_HCHANS_FIELD        FIELD(4, 4)
 #define NPCX_ESPICFG_IOMODE_FIELD        FIELD(8, 2)
 #define NPCX_ESPICFG_MAXFREQ_FIELD       FIELD(10, 3)
+#define NPCX_ESPICFG_FLCHANMODE          16
+#define NPCX_ESPICFG_OPFREQ              FIELD(17, 3)
+#define NPCX_ESPICFG_IOMODESEL           FIELD(20, 2)
+#define NPCX_ESPICFG_ALERTMODE           22
+#define NPCX_ESPICFG_CRC_CHK_EN          23
 #define NPCX_ESPICFG_PCCHN_SUPP          24
 #define NPCX_ESPICFG_VWCHN_SUPP          25
 #define NPCX_ESPICFG_OOBCHN_SUPP         26
@@ -715,7 +745,7 @@ struct espi_reg {
 #define NPCX_ESPIIE_BERRIE               2
 #define NPCX_ESPIIE_OOBRXIE              3
 #define NPCX_ESPIIE_FLASHRXIE            4
-#define NPCX_ESPIIE_SFLASHRDIE           5
+#define NPCX_ESPIIE_FLNACSIE             5
 #define NPCX_ESPIIE_PERACCIE             6
 #define NPCX_ESPIIE_DFRDIE               7
 #define NPCX_ESPIIE_VWUPDIE              8
@@ -733,6 +763,7 @@ struct espi_reg {
 #define NPCX_ESPIWE_BERRWE               2
 #define NPCX_ESPIWE_OOBRXWE              3
 #define NPCX_ESPIWE_FLASHRXWE            4
+#define NPCX_ESPIWE_FLNACSWE             5
 #define NPCX_ESPIWE_PERACCWE             6
 #define NPCX_ESPIWE_DFRDWE               7
 #define NPCX_ESPIWE_VWUPDWE              8
@@ -744,6 +775,7 @@ struct espi_reg {
 #define NPCX_ESPISTS_BERR                2
 #define NPCX_ESPISTS_OOBRX               3
 #define NPCX_ESPISTS_FLASHRX             4
+#define NPCX_ESPISTS_FLNACS              5
 #define NPCX_ESPISTS_PERACC              6
 #define NPCX_ESPISTS_DFRD                7
 #define NPCX_ESPISTS_VWUPD               8
@@ -758,6 +790,14 @@ struct espi_reg {
 #define NPCX_ESPISTS_BMBURSTERR          22
 #define NPCX_ESPISTS_BMBURSTDONE         23
 #define NPCX_ESPISTS_ESPIRST_LVL         24
+#define NPCX_VWSWIRQ_IRQ_NUM             FIELD(0, 7)
+#define NPCX_VWSWIRQ_IRQ_LVL             7
+#define NPCX_VWSWIRQ_INDEX               FIELD(8, 7)
+#define NPCX_VWSWIRQ_INDEX_EN            15
+#define NPCX_VWSWIRQ_DIRTY               16
+#define NPCX_VWSWIRQ_ENPLTRST            17
+#define NPCX_VWSWIRQ_ENCDRST             19
+#define NPCX_VWSWIRQ_EDGE_IRQ            28
 #define NPCX_VWEVMS_WIRE                 FIELD(0, 4)
 #define NPCX_VWEVMS_VALID                FIELD(4, 4)
 #define NPCX_VWEVMS_IE                   18
@@ -774,6 +814,9 @@ struct espi_reg {
 #define NPCX_FLASHCFG_FLASHBLERSSIZE     FIELD(7, 3)
 #define NPCX_FLASHCFG_FLASHPLSIZE        FIELD(10, 3)
 #define NPCX_FLASHCFG_FLASHREQSIZE       FIELD(13, 3)
+#define NPCX_FLASHCFG_FLCAPA             FIELD(16, 2)
+#define NPCX_FLASHCFG_TRGFLEBLKSIZE      FIELD(18, 8)
+#define NPCX_FLASHCFG_FLREQSUP           FIELD(0, 3)
 #define NPCX_FLASHCTL_FLASH_NP_FREE      0
 #define NPCX_FLASHCTL_FLASH_TX_AVAIL     1
 #define NPCX_FLASHCTL_STRPHDR            2
@@ -783,10 +826,20 @@ struct espi_reg {
 #define NPCX_FLASHCTL_CRCEN              14
 #define NPCX_FLASHCTL_CHKSUMSEL          15
 #define NPCX_FLASHCTL_AMTEN              16
-
+#define NPCX_FLASHCTL_SAF_AUTO_READ      18
+#define NPCX_FLASHCTL_AUTO_RD_DIS_CTL    19
+#define NPCX_FLASHCTL_BLK_FLASH_NP_FREE  20
+#define NPCX_FLASHBASE_FLBASE_ADDR       FIELD(16, 13)
+#define NPCX_FLASH_PRTR_BADDR            FIELD(12, 17)
+#define NPCX_FRGN_WPR                    31
+#define NPCX_FRGN_RPR                    30
+#define NPCX_FLASH_PRTR_HADDR            FIELD(12, 17)
+#define NPCX_FLASH_TAG_OVR_RPR           FIELD(16, 16)
+#define NPCX_FLASH_TAG_OVR_WPR           FIELD(0, 16)
 #define NPCX_ONLY_ESPI_REG1_UNLOCK_REG2         0x55
 #define NPCX_ONLY_ESPI_REG1_LOCK_REG2           0
 #define NPCX_ONLY_ESPI_REG2_TRANS_END_CONFIG    4
+
 /*
  * Mobile System Wake-Up Control (MSWC) device registers
  */
@@ -955,6 +1008,7 @@ struct shm_reg {
 #define NPCX_DP80CTL_RFIFO               4
 #define NPCX_DP80CTL_CIEN                5
 #define NPCX_DP80CTL_DP80_HF_CFG         7
+#define NPCX_DP80BUF_OFFS_FIELD          FIELD(8, 3)
 
 /*
  * Keyboard and Mouse Controller (KBC) device registers
@@ -1110,89 +1164,99 @@ struct smb_reg {
 	volatile uint8_t reserved7;
 	/* 0x00E: SMB Control 3 */
 	volatile uint8_t SMBCTL3;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+	/* 0x00F: DMA Control */
+	volatile uint8_t DMA_CTRL;
+#else
 	/* 0x00F: SMB Bus Timeout */
 	volatile uint8_t SMBT_OUT;
-	/* 0x010: SMB Own Address 3 */
-	volatile uint8_t SMBADDR3;
-	/* 0x011: SMB Own Address 7 */
-	volatile uint8_t SMBADDR7;
-	/* 0x012: SMB Own Address 4 */
-	volatile uint8_t SMBADDR4;
-	/* 0x013: SMB Own Address 8 */
-	volatile uint8_t SMBADDR8;
-	/* 0x014: SMB Own Address 5 */
-	volatile uint8_t SMBADDR5;
-	volatile uint8_t reserved8;
-	/* 0x016: SMB Own Address 6 */
-	volatile uint8_t SMBADDR6;
-	volatile uint8_t reserved9;
-	/* 0x018: SMB Control Status 2 */
-	volatile uint8_t SMBCST2;
-	/* 0x019: SMB Control Status 3 */
-	volatile uint8_t SMBCST3;
-	/* 0x01A: SMB Control 4 */
-	volatile uint8_t SMBCTL4;
-	volatile uint8_t reserved10;
-	/* 0x01C: SMB SCL Low Time */
-	volatile uint8_t SMBSCLLT;
-	/* 0x01D: SMB FIFO Control */
-	volatile uint8_t SMBFIF_CTL;
-	/* 0x01E: SMB SCL High Time */
-	volatile uint8_t SMBSCLHT;
-	volatile uint8_t reserved11;
-};
-
-/*
- * SMBUS (SMB) FIFO device registers
- */
-struct smb_fifo_reg {
-	/* 0x000: SMB Serial Data */
-	volatile uint8_t SMBSDA;
-	volatile uint8_t reserved1;
-	/* 0x002: SMB Status */
-	volatile uint8_t SMBST;
-	volatile uint8_t reserved2;
-	/* 0x004: SMB Control Status */
-	volatile uint8_t SMBCST;
-	volatile uint8_t reserved3;
-	/* 0x006: SMB Control 1 */
-	volatile uint8_t SMBCTL1;
-	volatile uint8_t reserved4;
-	/* 0x008: SMB Own Address */
-	volatile uint8_t SMBADDR1;
-	volatile uint8_t reserved5;
-	/* 0x00A: SMB Control 2 */
-	volatile uint8_t SMBCTL2;
-	volatile uint8_t reserved6;
-	/* 0x00C: SMB Own Address */
-	volatile uint8_t SMBADDR2;
-	volatile uint8_t reserved7;
-	/* 0x00E: SMB Control 3 */
-	volatile uint8_t SMBCTL3;
-	/* 0x00F: SMB Bus Timeout */
-	volatile uint8_t SMBT_OUT;
-	/* 0x010: SMB FIFO Control */
-	volatile uint8_t SMBFIF_CTS;
-	volatile uint8_t reserved8;
-	/* 0x012: SMB Tx-FIFO Control */
-	volatile uint8_t SMBTXF_CTL;
-	volatile uint8_t reserved9;
-	/* 0x014: SMB Bus Timeout */
-	volatile uint8_t SMB_T_OUT;
-	volatile uint8_t reserved10[3];
-	/* 0x018: SMB Control Status 2 */
-	volatile uint8_t SMBCST2;
-	/* 0x019: SMB Control Status 3 */
-	volatile uint8_t SMBCST3;
-	/* 0x01A: SMB Tx-FIFO Status */
-	volatile uint8_t SMBTXF_STS;
-	volatile uint8_t reserved11;
-	/* 0x01C: SMB Rx-FIFO Status */
-	volatile uint8_t SMBRXF_STS;
-	volatile uint8_t reserved12;
-	/* 0x01E: SMB Rx-FIFO Control */
-	volatile uint8_t SMBRXF_CTL;
-	volatile uint8_t reserved13;
+#endif
+	union {
+		/* Bank 0 */
+		struct {
+			/* 0x010: SMB Own Address 3 */
+			volatile uint8_t SMBADDR3;
+			/* 0x011: SMB Own Address 7 */
+			volatile uint8_t SMBADDR7;
+			/* 0x012: SMB Own Address 4 */
+			volatile uint8_t SMBADDR4;
+			/* 0x013: SMB Own Address 8 */
+			volatile uint8_t SMBADDR8;
+			/* 0x014: SMB Own Address 5 */
+			volatile uint8_t SMBADDR5;
+			volatile uint8_t reserved8;
+			/* 0x016: SMB Own Address 6 */
+			volatile uint8_t SMBADDR6;
+			volatile uint8_t reserved9;
+			/* 0x018: SMB Control Status 2 */
+			volatile uint8_t SMBCST2;
+			/* 0x019: SMB Control Status 3 */
+			volatile uint8_t SMBCST3;
+			/* 0x01A: SMB Control 4 */
+			volatile uint8_t SMBCTL4;
+			volatile uint8_t reserved10;
+			/* 0x01C: SMB SCL Low Time */
+			volatile uint8_t SMBSCLLT;
+			/* 0x01D: SMB FIFO Control */
+			volatile uint8_t SMBFIF_CTL;
+			/* 0x01E: SMB SCL High Time */
+			volatile uint8_t SMBSCLHT;
+			volatile uint8_t reserved11;
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+			/* 0x20h DMA Address Byte 1 */
+			volatile uint8_t DMA_ADDR1;
+			/* 0x21h DMA Address Byte 2 */
+			volatile uint8_t DMA_ADDR2;
+			/* 0x22h DMA Address Byte 3 */
+			volatile uint8_t DMA_ADDR3;
+			/* 0x23h DMA Address Byte 4 */
+			volatile uint8_t DMA_ADDR4;
+			/* 0x24h Data Length Byte 1 */
+			volatile uint8_t DATA_LEN1;
+			/* 0x25h Data Length Byte 2 */
+			volatile uint8_t DATA_LEN2;
+			/* 0x26h Data Counter Byte 1 */
+			volatile uint8_t DATA_CNT1;
+			/* 0x27h Data Counter Byte 2 */
+			volatile uint8_t DATA_CNT2;
+			volatile uint8_t reserved18;
+			/* 0x29h Timeout Control 1 Byte */
+			volatile uint8_t TIMEOUT_CTL1;
+			/* 0x2Ah Timeout Control 2 Byte */
+			volatile uint8_t TIMEOUT_CTL2;
+			/* 0x2Bh SMB PEC Data */
+			volatile uint8_t SMBnPEC;
+			volatile uint8_t reserved19[4];
+#else
+			volatile uint8_t reserved20[16];
+#endif /* CONFIG_I2C_NPCX_DMA_DRIVEN */
+		};
+		/* Bank 1 */
+		struct {
+			/* 0x010: SMB FIFO Control */
+			volatile uint8_t SMBFIF_CTS;
+			volatile uint8_t reserved12;
+			/* 0x012: SMB Tx-FIFO Control */
+			volatile uint8_t SMBTXF_CTL;
+			volatile uint8_t reserved13;
+			/* 0x014: SMB Bus Timeout */
+			volatile uint8_t SMB_T_OUT;
+			volatile uint8_t reserved14[3];
+			/* 0x018: SMB Control Status 2 (FIFO) */
+			volatile uint8_t SMBCST2_FIFO;
+			/* 0x019: SMB Control Status 3 (FIFO) */
+			volatile uint8_t SMBCST3_FIFO;
+			/* 0x01A: SMB Tx-FIFO Status */
+			volatile uint8_t SMBTXF_STS;
+			volatile uint8_t reserved15;
+			/* 0x01C: SMB Rx-FIFO Status */
+			volatile uint8_t SMBRXF_STS;
+			volatile uint8_t reserved16;
+			/* 0x01E: SMB Rx-FIFO Control */
+			volatile uint8_t SMBRXF_CTL;
+			volatile uint8_t reserved17[1];
+		};
+	};
 };
 
 /* SMB register fields */
@@ -1257,6 +1321,13 @@ struct smb_fifo_reg {
 #define NPCX_SMBFIF_CTL_FIFO_EN          4
 #define NPCX_SMBRXF_STS_RX_THST          6
 
+/* DMA_CTRL  register fields */
+#define NPCX_DMA_CTL_INTCLR              0
+#define NPCX_DMA_CTL_ENABLE              1
+#define NPCX_DMA_CTL_LAST_PEC            2
+#define NPCX_DMA_CTL_DMA_STALL           3
+#define NPCX_DMA_CTL_IRQSTS              7
+
 /* RX FIFO threshold */
 #define NPCX_SMBRXF_CTL_RX_THR           FIELD(0, 6)
 #define NPCX_SMBRXF_CTL_LAST             7
@@ -1495,11 +1566,53 @@ struct fiu_reg {
 	volatile uint8_t FIU_DMM_CYC;
 	/* 0x033: FIU Extended Configuration */
 	volatile uint8_t FIU_EXT_CFG;
+#if defined(CONFIG_SOC_SERIES_NPCX9)
+	/* 0x034: UMA address byte 0-3 */
+	volatile uint32_t UMA_AB0_3;
+	/* 0x038-0x3C */
+	volatile uint8_t reserved8[5];
+	/* 0x03D: SPI Device */
+	volatile uint8_t SPI1_DEV;
+	/* 0x03E-0x3F */
+	volatile uint8_t reserved9[2];
+#elif defined(CONFIG_SOC_SERIES_NPCX4)
+	/* 0x034: UMA address byte 0-3 */
+	volatile uint32_t UMA_AB0_3;
+	/* 0x038-0x3B */
+	volatile uint8_t reserved8[4];
+	/* 0x03C: SPI Device */
+	volatile uint8_t SPI_DEV;
+	/* 0x03D */
+	volatile uint8_t reserved9;
+	/* 0x03E */
+	volatile uint8_t SPI_DEV_SIZE;
+	/* 0x03F */
+	volatile uint8_t reserved10;
+#elif defined(CONFIG_SOC_SERIES_NPCK3)
+	/* 0x034: UMA address byte 0-3 */
+	volatile uint32_t UMA_AB0_3;
+	volatile uint8_t reserved8[4];
+	/* 0x03C: Set command enable in 4 byte address mode */
+	volatile uint8_t SET_CMD_EN;
+	/* 0x03D: 4 byte address mode enable */
+	volatile uint8_t FIU_4B_EN;
+	/* 0x03E-0x040*/
+	volatile uint8_t reserved9[3];
+	/* 0x041: Master Inactive Counter Threshold */
+	volatile uint8_t MI_CNT_THRSH;
+	/* 0x042: FIU Matser Status */
+	volatile uint8_t FIU_MSR_STS;
+	/* 0x043: FIU Master Interrupt Enable and Configuration */
+	volatile uint8_t FIU_MSR_IE_CFG;
+#endif
 };
 
 /* FIU register fields */
+#define NPCX_BURST_CFG_SPI_DEV_SEL       FIELD(4, 2)
 #define NPCX_RESP_CFG_IAD_EN             0
 #define NPCX_RESP_CFG_DEV_SIZE_EX        2
+#define NPCX_RESP_CFG_QUAD_EN            3
+#define NPCX_SPI_FL_CFG_RD_MODE          FIELD(6, 2)
 #define NPCX_UMA_CTS_A_SIZE              3
 #define NPCX_UMA_CTS_C_SIZE              4
 #define NPCX_UMA_CTS_RD_WR               5
@@ -1509,6 +1622,20 @@ struct fiu_reg {
 #define NPCX_UMA_ECTS_SW_CS1             1
 #define NPCX_UMA_ECTS_SEC_CS             2
 #define NPCX_UMA_ECTS_UMA_LOCK           3
+#define NPCX_UMA_ECTS_UMA_ADDR_SIZE      FIELD(4, 3)
+#define NPCX_SPI1_DEV_FOUR_BADDR_CS10    6
+#define NPCX_SPI1_DEV_FOUR_BADDR_CS11    7
+#define NPCX_SPI1_DEV_SPI1_LO_DEV_SIZE   FIELD(0, 4)
+#define NPCX_FIU_EXT_CFG_SET_DMM_EN      2
+#define NPCX_FIU_EXT_CFG_SET_CMD_EN      1
+#define NPCX_SPI_DEV_NADDRB              FIELD(5, 3)
+
+#define NPCX_UMA_ECTS_UMA_DEV_BKP        3
+#define NPCX_MSR_IE_CFG_UMA_BLOCK        3
+
+#define NPCX_MSR_FIU_4B_EN_PVT_4B        4
+#define NPCX_MSR_FIU_4B_EN_SHD_4B        5
+#define NPCX_MSR_FIU_4B_EN_BKP_4B        6
 
 /* UMA fields selections */
 #define UMA_FLD_ADDR     BIT(NPCX_UMA_CTS_A_SIZE)  /* 3-bytes ADR field */
@@ -1590,4 +1717,130 @@ struct peci_reg {
 #define PECI_HIGH_SPEED_MIN_VAL          0x07
 
 #define NPCX_PECI_RATE_EHSP              6
+
+/* KBS (Keyboard Scan) device registers */
+struct kbs_reg {
+	volatile uint8_t reserved1[4];
+	/* 0x004: Keyboard Scan In */
+	volatile uint8_t KBSIN;
+	/* 0x005: Keyboard Scan In Pull-Up Enable */
+	volatile uint8_t KBSINPU;
+	/* 0x006: Keyboard Scan Out 0 */
+	volatile uint16_t KBSOUT0;
+	/* 0x008: Keyboard Scan Out 1 */
+	volatile uint16_t KBSOUT1;
+	/* 0x00A: Keyboard Scan Buffer Index */
+	volatile uint8_t KBS_BUF_INDX;
+	/* 0x00B: Keyboard Scan Buffer Data */
+	volatile uint8_t KBS_BUF_DATA;
+	/* 0x00C: Keyboard Scan Event */
+	volatile uint8_t KBSEVT;
+	/* 0x00D: Keyboard Scan Control */
+	volatile uint8_t KBSCTL;
+	/* 0x00E: Keyboard Scan Configuration Index */
+	volatile uint8_t KBS_CFG_INDX;
+	/* 0x00F: Keyboard Scan Configuration Data */
+	volatile uint8_t KBS_CFG_DATA;
+};
+
+/* KBS register fields */
+#define NPCX_KBSBUFINDX                  0
+#define NPCX_KBSEVT_KBSDONE              0
+#define NPCX_KBSEVT_KBSERR               1
+#define NPCX_KBSCTL_START                0
+#define NPCX_KBSCTL_KBSMODE              1
+#define NPCX_KBSCTL_KBSIEN               2
+#define NPCX_KBSCTL_KBSINC               3
+#define NPCX_KBSCTL_KBHDRV_FIELD         FIELD(6, 2)
+#define NPCX_KBSCFGINDX                  0
+/* Index of 'Automatic Scan' configuration register */
+#define KBS_CFG_INDX_DLY1                0 /* Keyboard Scan Delay T1 Byte */
+#define KBS_CFG_INDX_DLY2                1 /* Keyboard Scan Delay T2 Byte */
+#define KBS_CFG_INDX_RTYTO               2 /* Keyboard Scan Retry Timeout */
+#define KBS_CFG_INDX_CNUM                3 /* Keyboard Scan Columns Number */
+#define KBS_CFG_INDX_CDIV                4 /* Keyboard Scan Clock Divisor */
+
+/* SHI (Serial Host Interface) registers */
+struct shi_reg {
+	volatile uint8_t reserved1;
+	/* 0x001: SHI Configuration 1 */
+	volatile uint8_t SHICFG1;
+	/* 0x002: SHI Configuration 2 */
+	volatile uint8_t SHICFG2;
+	volatile uint8_t reserved2[2];
+	/* 0x005: Event Enable */
+	volatile uint8_t EVENABLE;
+	/* 0x006: Event Status */
+	volatile uint8_t EVSTAT;
+	/* 0x007: SHI Capabilities */
+	volatile uint8_t CAPABILITY;
+	/* 0x008: Status */
+	volatile uint8_t STATUS;
+	volatile uint8_t reserved3;
+	/* 0x00A: Input Buffer Status */
+	volatile uint8_t IBUFSTAT;
+	/* 0x00B: Output Buffer Status */
+	volatile uint8_t OBUFSTAT;
+	/* 0x00C: SHI Configuration 3 */
+	volatile uint8_t SHICFG3;
+	/* 0x00D: SHI Configuration 4 */
+	volatile uint8_t SHICFG4;
+	/* 0x00E: SHI Configuration 5 */
+	volatile uint8_t SHICFG5;
+	/* 0x00F: Event Status 2 */
+	volatile uint8_t EVSTAT2;
+	/* 0x010: Event Enable 2 */
+	volatile uint8_t EVENABLE2;
+	volatile uint8_t reserved4[15];
+	/* 0x20~0x9F: Output Buffer */
+	volatile uint8_t OBUF[128];
+	/* 0xA0~0x11F: Input Buffer */
+	volatile uint8_t IBUF[128];
+};
+
+/* SHI register fields */
+#define NPCX_SHICFG1_EN                  0
+#define NPCX_SHICFG1_MODE                1
+#define NPCX_SHICFG1_WEN                 2
+#define NPCX_SHICFG1_AUTIBF              3
+#define NPCX_SHICFG1_AUTOBE              4
+#define NPCX_SHICFG1_DAS                 5
+#define NPCX_SHICFG1_CPOL                6
+#define NPCX_SHICFG1_IWRAP               7
+#define NPCX_SHICFG2_SIMUL               0
+#define NPCX_SHICFG2_BUSY                1
+#define NPCX_SHICFG2_ONESHOT             2
+#define NPCX_SHICFG2_SLWU                3
+#define NPCX_SHICFG2_REEN                4
+#define NPCX_SHICFG2_RESTART             5
+#define NPCX_SHICFG2_REEVEN              6
+#define NPCX_EVENABLE_OBEEN              0
+#define NPCX_EVENABLE_OBHEEN             1
+#define NPCX_EVENABLE_IBFEN              2
+#define NPCX_EVENABLE_IBHFEN             3
+#define NPCX_EVENABLE_EOREN              4
+#define NPCX_EVENABLE_EOWEN              5
+#define NPCX_EVENABLE_STSREN             6
+#define NPCX_EVENABLE_IBOREN             7
+#define NPCX_EVSTAT_OBE                  0
+#define NPCX_EVSTAT_OBHE                 1
+#define NPCX_EVSTAT_IBF                  2
+#define NPCX_EVSTAT_IBHF                 3
+#define NPCX_EVSTAT_EOR                  4
+#define NPCX_EVSTAT_EOW                  5
+#define NPCX_EVSTAT_STSR                 6
+#define NPCX_EVSTAT_IBOR                 7
+#define NPCX_STATUS_OBES                 6
+#define NPCX_STATUS_IBFS                 7
+#define NPCX_SHICFG3_OBUFLVLDIS          7
+#define NPCX_SHICFG4_IBUFLVLDIS          7
+#define NPCX_SHICFG5_IBUFLVL2            FIELD(0, 6)
+#define NPCX_SHICFG5_IBUFLVL2DIS         7
+#define NPCX_EVSTAT2_IBHF2               0
+#define NPCX_EVSTAT2_CSNRE               1
+#define NPCX_EVSTAT2_CSNFE               2
+#define NPCX_EVENABLE2_IBHF2EN           0
+#define NPCX_EVENABLE2_CSNREEN           1
+#define NPCX_EVENABLE2_CSNFEEN           2
+
 #endif /* _NUVOTON_NPCX_REG_DEF_H */
diff --git a/soc/arm/nuvoton_npcx/common/registers.c b/soc/arm/nuvoton_npcx/common/registers.c
index 566a063abb..61438078f9 100644
--- a/soc/arm/nuvoton_npcx/common/registers.c
+++ b/soc/arm/nuvoton_npcx/common/registers.c
@@ -27,17 +27,30 @@ NPCX_REG_OFFSET_CHECK(scfg_reg, DEVALT0, 0x010);
 NPCX_REG_OFFSET_CHECK(scfg_reg, LV_GPIO_CTL0, 0x02a);
 
 /* GLUE register structure check */
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_SIZE_CHECK(glue_reg, 0x03b);
+#else
 NPCX_REG_SIZE_CHECK(glue_reg, 0x028);
+#endif
 NPCX_REG_OFFSET_CHECK(glue_reg, SMB_EEN, 0x003);
 NPCX_REG_OFFSET_CHECK(glue_reg, SDPD0, 0x010);
 NPCX_REG_OFFSET_CHECK(glue_reg, SMB_SEL, 0x021);
 NPCX_REG_OFFSET_CHECK(glue_reg, PSL_CTS, 0x027);
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_OFFSET_CHECK(glue_reg, EPURST_CTL, 0x030);
+NPCX_REG_OFFSET_CHECK(glue_reg, PSL_CTS3, 0x038);
+#endif
 
 /* UART register structure check */
 NPCX_REG_SIZE_CHECK(uart_reg, 0x027);
 NPCX_REG_OFFSET_CHECK(uart_reg, UPSR, 0x00e);
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_OFFSET_CHECK(uart_reg, UFCTRL, 0x016);
+NPCX_REG_OFFSET_CHECK(uart_reg, URXFLV, 0x01A);
+#else
 NPCX_REG_OFFSET_CHECK(uart_reg, UFTSTS, 0x020);
 NPCX_REG_OFFSET_CHECK(uart_reg, UFRCTL, 0x026);
+#endif
 
 /* GPIO register structure check */
 NPCX_REG_SIZE_CHECK(gpio_reg, 0x008);
@@ -62,7 +75,7 @@ NPCX_REG_OFFSET_CHECK(twd_reg, TWMWD, 0x00e);
 NPCX_REG_OFFSET_CHECK(twd_reg, WDCP, 0x010);
 
 /* ESPI register structure check */
-NPCX_REG_SIZE_CHECK(espi_reg, 0x500);
+NPCX_REG_SIZE_CHECK(espi_reg, 0x900);
 NPCX_REG_OFFSET_CHECK(espi_reg, FLASHCFG, 0x034);
 NPCX_REG_OFFSET_CHECK(espi_reg, NPCX_ONLY_ESPI_REG1, 0x0f0);
 NPCX_REG_OFFSET_CHECK(espi_reg, VWEVMS, 0x140);
@@ -117,17 +130,20 @@ NPCX_REG_OFFSET_CHECK(c2h_reg, CRSMAE, 0x008);
 NPCX_REG_OFFSET_CHECK(c2h_reg, SIBCTRL, 0x00a);
 
 /* SMB register structure check */
-NPCX_REG_SIZE_CHECK(smb_reg, 0x020);
+NPCX_REG_SIZE_CHECK(smb_reg, 0x030);
 NPCX_REG_OFFSET_CHECK(smb_reg, SMBCTL1, 0x006);
-NPCX_REG_OFFSET_CHECK(smb_reg, SMBT_OUT, 0x00f);
 NPCX_REG_OFFSET_CHECK(smb_reg, SMBADDR6, 0x016);
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBCST2, 0x018);
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBTXF_STS, 0x01a);
 NPCX_REG_OFFSET_CHECK(smb_reg, SMBSCLHT, 0x01e);
-
-NPCX_REG_SIZE_CHECK(smb_fifo_reg, 0x020);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBT_OUT, 0x00f);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBCST2, 0x018);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBTXF_STS, 0x01a);
-NPCX_REG_OFFSET_CHECK(smb_fifo_reg, SMBRXF_CTL, 0x01e);
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBRXF_CTL, 0x01e);
+#if defined(CONFIG_I2C_NPCX_DMA_DRIVEN)
+NPCX_REG_OFFSET_CHECK(smb_reg, DMA_CTRL, 0x00f);
+NPCX_REG_OFFSET_CHECK(smb_reg, DMA_ADDR3, 0x022);
+NPCX_REG_OFFSET_CHECK(smb_reg, TIMEOUT_CTL1, 0x029);
+#else
+NPCX_REG_OFFSET_CHECK(smb_reg, SMBT_OUT, 0x00f);
+#endif /* CONFIG_I2C_NPCX_DMA_DRIVEN */
 
 /* ITIM register structure check */
 NPCX_REG_SIZE_CHECK(itim32_reg, 0x00c);
@@ -165,7 +181,13 @@ NPCX_REG_OFFSET_CHECK(ps2_reg, PSISIG, 0x008);
 NPCX_REG_OFFSET_CHECK(ps2_reg, PSIEN, 0x00a);
 
 /* FIU register structure check */
+#if defined(CONFIG_SOC_SERIES_NPCX9) || defined(CONFIG_SOC_SERIES_NPCX4)
+NPCX_REG_SIZE_CHECK(fiu_reg, 0x040);
+#elif defined(CONFIG_SOC_SERIES_NPCK3)
+NPCX_REG_SIZE_CHECK(fiu_reg, 0x044);
+#else
 NPCX_REG_SIZE_CHECK(fiu_reg, 0x034);
+#endif
 NPCX_REG_OFFSET_CHECK(fiu_reg, BURST_CFG, 0x001);
 NPCX_REG_OFFSET_CHECK(fiu_reg, SPI_FL_CFG, 0x014);
 NPCX_REG_OFFSET_CHECK(fiu_reg, UMA_CTS, 0x01e);
@@ -178,3 +200,9 @@ NPCX_REG_SIZE_CHECK(peci_reg, 0x050);
 NPCX_REG_OFFSET_CHECK(peci_reg, PECI_ADDR, 0x002);
 NPCX_REG_OFFSET_CHECK(peci_reg, PECI_WR_LENGTH, 0x007);
 NPCX_REG_OFFSET_CHECK(peci_reg, PECI_WR_FCS, 0x00b);
+
+/* KBS register structure check */
+NPCX_REG_SIZE_CHECK(kbs_reg, 0x010);
+NPCX_REG_OFFSET_CHECK(kbs_reg, KBSIN, 0x004);
+NPCX_REG_OFFSET_CHECK(kbs_reg, KBSOUT0, 0x006);
+NPCX_REG_OFFSET_CHECK(kbs_reg, KBS_BUF_INDX, 0x00a);
diff --git a/soc/arm/nuvoton_npcx/common/scfg.c b/soc/arm/nuvoton_npcx/common/scfg.c
index 8641676266..7f44cc52b3 100644
--- a/soc/arm/nuvoton_npcx/common/scfg.c
+++ b/soc/arm/nuvoton_npcx/common/scfg.c
@@ -4,7 +4,7 @@
  * SPDX-License-Identifier: Apache-2.0
  */
 
-#include <zephyr/device.h>
+#include <zephyr/init.h>
 #include <zephyr/drivers/gpio.h>
 #include <zephyr/dt-bindings/pinctrl/npcx-pinctrl.h>
 #include <zephyr/kernel.h>
@@ -19,6 +19,7 @@ LOG_MODULE_REGISTER(pimux_npcx, LOG_LEVEL_ERR);
 struct npcx_scfg_config {
 	/* scfg device base address */
 	uintptr_t base_scfg;
+	uintptr_t base_dbg;
 	uintptr_t base_glue;
 };
 
@@ -45,6 +46,7 @@ static const struct npcx_alt def_alts[] = {
 
 static const struct npcx_scfg_config npcx_scfg_cfg = {
 	.base_scfg = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), scfg),
+	.base_dbg = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), dbg),
 	.base_glue = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), glue),
 };
 
@@ -94,23 +96,42 @@ bool npcx_lvol_get_detect_level(int lvol_ctrl, int lvol_bit)
 
 void npcx_pinctrl_i2c_port_sel(int controller, int port)
 {
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	const uint32_t scfg_base = npcx_scfg_cfg.base_scfg;
+
+	/* Set DEVALTC bit to select port b, otherwise select port a */
+	if (port != 0) {
+		NPCX_DEVALT(scfg_base, 0x0c) |= BIT(7 - controller);
+	} else {
+		NPCX_DEVALT(scfg_base, 0x0c) &= ~BIT(7 - controller);
+	}
+#else
 	struct glue_reg *const inst_glue = HAL_GLUE_INST();
 
+	/* Set SMB_SEL bit to select port 1, otherwise select port 0 */
 	if (port != 0) {
 		inst_glue->SMB_SEL |= BIT(controller);
 	} else {
 		inst_glue->SMB_SEL &= ~BIT(controller);
 	}
+#endif
 }
 
 int npcx_pinctrl_flash_write_protect_set(void)
 {
 	struct scfg_reg *inst_scfg = HAL_SFCG_INST();
 
+#if defined(CONFIG_SOC_SERIES_NPCK3)
+	inst_scfg->DEV_CTL3 |= BIT(NPCk_DEV_CTL3_WP_IF);
+	if (!IS_BIT_SET(inst_scfg->DEV_CTL3, NPCk_DEV_CTL3_WP_IF)) {
+		return -EIO;
+	}
+#else
 	inst_scfg->DEV_CTL4 |= BIT(NPCX_DEV_CTL4_WP_IF);
 	if (!IS_BIT_SET(inst_scfg->DEV_CTL4, NPCX_DEV_CTL4_WP_IF)) {
 		return -EIO;
 	}
+#endif
 
 	return 0;
 }
@@ -129,19 +150,20 @@ void npcx_host_interface_sel(enum npcx_hif_type hif_type)
 	SET_FIELD(inst_scfg->DEVCNT, NPCX_DEVCNT_HIF_TYP_SEL_FIELD, hif_type);
 }
 
-/* Pin-control driver registration */
-static int npcx_scfg_init(const struct device *dev)
+void npcx_dbg_freeze_enable(bool enable)
 {
-	struct scfg_reg *inst_scfg = HAL_SFCG_INST();
+	const uintptr_t dbg_base = npcx_scfg_cfg.base_dbg;
 
-	/*
-	 * Set bit 7 of DEVCNT again for npcx7 series. Please see Errata
-	 * for more information. It will be fixed in next chip.
-	 */
-	if (IS_ENABLED(CONFIG_SOC_SERIES_NPCX7)) {
-		inst_scfg->DEVCNT |= BIT(7);
+	if (enable) {
+		NPCX_DBGFRZEN3(dbg_base) &= ~BIT(NPCX_DBGFRZEN3_GLBL_FRZ_DIS);
+	} else {
+		NPCX_DBGFRZEN3(dbg_base) |= BIT(NPCX_DBGFRZEN3_GLBL_FRZ_DIS);
 	}
+}
 
+/* Pin-control driver registration */
+static int npcx_scfg_init(void)
+{
 	/* Change all pads whose default functionality isn't IO to GPIO */
 	for (int i = 0; i < ARRAY_SIZE(def_alts); i++) {
 		npcx_pinctrl_alt_sel(&def_alts[i], 0);
diff --git a/soc/arm/nuvoton_npcx/common/soc_clock.h b/soc/arm/nuvoton_npcx/common/soc_clock.h
index 99656d38c8..eb3a3cee52 100644
--- a/soc/arm/nuvoton_npcx/common/soc_clock.h
+++ b/soc/arm/nuvoton_npcx/common/soc_clock.h
@@ -44,31 +44,38 @@ struct npcx_clk_cfg {
 #define APB3DIV_VAL (DT_PROP(DT_NODELABEL(pcc), apb3_prescaler) - 1)
 /* APB4 clock divider if supported */
 #if DT_NODE_HAS_PROP(DT_NODELABEL(pcc), apb4_prescaler)
-#if defined(CONFIG_SOC_SERIES_NPCX9)
+#if defined(CONFIG_CLOCK_CONTROL_NPCX_SUPP_APB4) /* Supported in NPCX9 and later series */
 #define APB4DIV_VAL (DT_PROP(DT_NODELABEL(pcc), apb4_prescaler) - 1)
 #else
 #error "APB4 clock divider is not supported but defined in pcc node!"
+#endif /* CONFIG_CLOCK_CONTROL_NPCX_SUPP_APB4 */
 #endif
-#endif
+
+/* Construct a uint8_t array from 'pwdwn-ctl-val' prop for PWDWN_CTL initialization. */
+#define NPCX_PWDWN_CTL_ITEMS_INIT(node, prop, idx) DT_PROP_BY_IDX(node, prop, idx),
+#define NPCX_PWDWN_CTL_INIT DT_FOREACH_PROP_ELEM(DT_NODELABEL(pcc), \
+				pwdwn_ctl_val, NPCX_PWDWN_CTL_ITEMS_INIT)
 
 /*
  * NPCX7 and later series clock tree macros:
  * (Please refer Figure 58. for more information.)
  *
- * Suggestion:
- * - OFMCLK > 50MHz, XF_RANGE should be 1, else 0.
- * - CORE_CLK > 50MHz, AHB6DIV should be 1, else 0.
- * - CORE_CLK > 50MHz, FIUDIV should be 1, else 0.
+ * Maximum OFMCLK in npcx7/9 series is 100MHz,
+ * Maximum OFMCLK in npcx4 series is 120MHz,
+ *
+ * Suggestion for npcx series:
+ * - OFMCLK   > MAX_OFMCLK/2, XF_RANGE should be 1, else 0.
+ * - CORE_CLK > MAX_OFMCLK/2, AHB6DIV should be 1, else 0.
+ * - CORE_CLK > MAX_OFMCLK/2, FIUDIV should be 1, else 0.
  */
-
 /* Core domain clock */
 #define CORE_CLK (OFMCLK / DT_PROP(DT_NODELABEL(pcc), core_prescaler))
 /* Low Frequency clock */
 #define LFCLK 32768
 
 /* FMUL clock */
-#if (OFMCLK > 50000000)
-#define FMCLK (OFMCLK / 2) /* FMUL clock = OFMCLK/2 if OFMCLK > 50MHz */
+#if (OFMCLK > (MAX_OFMCLK / 2))
+#define FMCLK (OFMCLK / 2) /* FMUL clock = OFMCLK/2 */
 #else
 #define FMCLK OFMCLK /* FMUL clock = OFMCLK */
 #endif
@@ -77,18 +84,27 @@ struct npcx_clk_cfg {
 #define APBSRC_CLK OFMCLK
 
 /* AHB6 clock */
-#if (CORE_CLK > 50000000)
-#define AHB6DIV_VAL 1 /* AHB6_CLK = CORE_CLK/2 if CORE_CLK > 50MHz */
+#if (CORE_CLK > (MAX_OFMCLK / 2))
+#define AHB6DIV_VAL 1 /* AHB6_CLK = CORE_CLK/2 */
 #else
 #define AHB6DIV_VAL 0 /* AHB6_CLK = CORE_CLK */
 #endif
+
 /* FIU clock divider */
-#if (CORE_CLK > 50000000)
+#if (CORE_CLK > (MAX_OFMCLK / 2))
 #define FIUDIV_VAL 1 /* FIU_CLK = CORE_CLK/2 */
 #else
 #define FIUDIV_VAL 0 /* FIU_CLK = CORE_CLK */
 #endif
 
+#if defined(CONFIG_CLOCK_CONTROL_NPCX_SUPP_FIU1)
+#if (CORE_CLK > (MAX_OFMCLK / 2))
+#define FIU1DIV_VAL 1 /* FIU1_CLK = CORE_CLK/2 */
+#else
+#define FIU1DIV_VAL 0 /* FIU1_CLK = CORE_CLK */
+#endif
+#endif /* CONFIG_CLOCK_CONTROL_NPCX_SUPP_FIU1 */
+
 /* Get APB clock freq */
 #define NPCX_APB_CLOCK(no) (APBSRC_CLK / (APB##no##DIV_VAL + 1))
 
@@ -96,12 +112,15 @@ struct npcx_clk_cfg {
  * Frequency multiplier M/N value definitions according to the requested
  * OFMCLK (Unit:Hz).
  */
-#if (OFMCLK > 50000000)
-#define HFCGN_VAL    0x82 /* Set XF_RANGE as 1 if OFMCLK > 50MHz */
+#if (OFMCLK > (MAX_OFMCLK / 2))
+#define HFCGN_VAL    0x82 /* Set XF_RANGE as 1 */
 #else
 #define HFCGN_VAL    0x02
 #endif
-#if   (OFMCLK == 100000000)
+#if   (OFMCLK == 120000000)
+#define HFCGMH_VAL   0x0E
+#define HFCGML_VAL   0x4E
+#elif (OFMCLK == 100000000)
 #define HFCGMH_VAL   0x0B
 #define HFCGML_VAL   0xEC
 #elif (OFMCLK == 96000000)
@@ -122,12 +141,6 @@ struct npcx_clk_cfg {
 #elif (OFMCLK == 48000000)
 #define HFCGMH_VAL   0x0B
 #define HFCGML_VAL   0x72
-#elif (OFMCLK == 40000000)
-#define HFCGMH_VAL   0x09
-#define HFCGML_VAL   0x89
-#elif (OFMCLK == 33000000)
-#define HFCGMH_VAL   0x07
-#define HFCGML_VAL   0xDE
 #else
 #error "Unsupported OFMCLK Frequency"
 #endif
diff --git a/soc/arm/nuvoton_npcx/common/soc_dbg.h b/soc/arm/nuvoton_npcx/common/soc_dbg.h
new file mode 100644
index 0000000000..dc8f2ce120
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/common/soc_dbg.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _NUVOTON_NPCX_SOC_DBG_H_
+#define _NUVOTON_NPCX_SOC_DBG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Configure the Automatic Freeze mode. If this mode is enabled, whenever
+ * the Core is halted, various modules’ clocks, counters are stopped and
+ * destructive reads are disabled, pending the respective module enable bit for
+ * debugging.
+ */
+void npcx_dbg_freeze_enable(bool enable);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NUVOTON_NPCX_SOC_DBG_H_ */
diff --git a/soc/arm/nuvoton_npcx/common/soc_espi_taf.h b/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
new file mode 100644
index 0000000000..6c5b9adbd2
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/common/soc_espi_taf.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _NUVOTON_NPCX_SOC_ESPI_TAF_H_
+#define _NUVOTON_NPCX_SOC_ESPI_TAF_H_
+
+#include <zephyr/device.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* data operation for eSPI TAF packet */
+#define MSN(var8)        ((uint8_t)((uint8_t)(var8) >> 4))
+#define LSN(var8)        ((uint8_t)((uint8_t)(var8) & 0x0F))
+
+#define MSB0(var32)      ((uint8_t)(((uint32_t)(var32) & 0xFF000000) >> 24))
+#define MSB1(var32)      ((uint8_t)(((uint32_t)(var32) & 0xFF0000) >> 16))
+#define MSB2(var32)      ((uint8_t)(((uint16_t)(var32) & 0xFF00) >> 8))
+#define MSB3(var32)      ((uint8_t)((var32) & 0xFF))
+
+#define MAKE8(nlo, nhi)  ((uint8_t)(((uint8_t)(nlo)) | (((uint8_t)(nhi)) << 4)))
+
+/* Successful Completion Without Data     */
+#define CYC_SCS_CMP_WITHOUT_DATA                   0x06
+/* Successful middle Completion With Data */
+#define CYC_SCS_CMP_WITH_DATA_MIDDLE               0x09
+/* Successful first Completion With Data  */
+#define CYC_SCS_CMP_WITH_DATA_FIRST                0x0B
+/* Successful last Completion With Data   */
+#define CYC_SCS_CMP_WITH_DATA_LAST                 0x0D
+/* Successful only Completion With Data   */
+#define CYC_SCS_CMP_WITH_DATA_ONLY                 0x0F
+/* Unsuccessful Completion Without Data   */
+#define CYC_UNSCS_CMP_WITHOUT_DATA                 0x08
+/* Unsuccessful Last Completion Without Data */
+#define CYC_UNSCS_CMP_WITHOUT_DATA_LAST            0x0C
+/* Unsuccessful Only Completion Without Data */
+#define CYC_UNSCS_CMP_WITHOUT_DATA_ONLY            0x0E
+
+/* TAF EC Portal read/write flash access limited to 1-64 bytes*/
+#define MAX_FLASH_REQUEST                          64u
+
+/* Clear RSTBUFHEADS, FLASH_ACC_TX_AVAIL, and FLASH_ACC_NP_FREE */
+#define FLASHCTL_ACCESS_MASK                       (~0x00002003)
+
+/* Flash Sharing Capability Support */
+#define ESPI_FLASH_SHARING_CAP_SUPP_CAF_DEF        0
+#define ESPI_FLASH_SHARING_CAP_SUPP_CAF            1
+#define ESPI_FLASH_SHARING_CAP_SUPP_TAF            2
+#define ESPI_FLASH_SHARING_CAP_SUPP_TAF_AND_CAF    3
+
+#define _4KB_                                      (4 * 1024)
+#define _32KB_                                     (32 * 1024)
+#define _64KB_                                     (64 * 1024)
+#define _128KB_                                    (128 * 1024)
+
+enum ESPI_TAF_MODE {
+	ESPI_TAF_STANDARD_MODE                     = 0,
+	ESPI_TAF_AUTO_MODE                         = 1,
+};
+
+enum ESPI_FLASH_TAF_REQ {
+	ESPI_FLASH_TAF_REQ_READ                    = 0,
+	ESPI_FLASH_TAF_REQ_WRITE                   = 1,
+	ESPI_FLASH_TAF_REQ_ERASE                   = 2,
+	ESPI_FLASH_TAF_REQ_RPMC_OP1                = 3,
+	ESPI_FLASH_TAF_REQ_RPMC_OP2                = 4,
+	ESPI_FLASH_TAF_REQ_UNKNOWN                 = 5,
+};
+
+/* ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_4KB is default */
+enum ESPI_FLASH_TAF_ERASE_BLOCK_SIZE {
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_1KB        = 0,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_2KB        = 1,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_4KB        = 2,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_8KB        = 3,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_16KB       = 4,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_32KB       = 5,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_64KB       = 6,
+	ESPI_FLASH_TAF_ERASE_BLOCK_SIZE_128KB      = 7,
+};
+
+/* ESPI_FLASH_TAF_MAX_READ_REQ_64B is default */
+enum ESPI_FLASH_TAF_MAX_READ_REQ {
+	ESPI_FLASH_TAF_MAX_READ_REQ_64B            = 1,
+	ESPI_FLASH_TAF_MAX_READ_REQ_128B           = 2,
+	ESPI_FLASH_TAF_MAX_READ_REQ_256B           = 3,
+	ESPI_FLASH_TAF_MAX_READ_REQ_512B           = 4,
+	ESPI_FLASH_TAF_MAX_READ_REQ_1024B          = 5,
+	ESPI_FLASH_TAF_MAX_READ_REQ_2048B          = 6,
+	ESPI_FLASH_TAF_MAX_READ_REQ_4096B          = 7,
+};
+
+struct espi_saf_hw_cfg {
+	uint8_t  version;
+	enum ESPI_TAF_MODE mode;
+};
+
+struct espi_saf_pr {
+	uint32_t start;
+	uint32_t end;
+	uint16_t override_r;
+	uint16_t override_w;
+	uint8_t  master_bm_we;
+	uint8_t  master_bm_rd;
+	uint8_t  pr_num;
+	uint8_t  flags;
+};
+
+struct espi_saf_protection {
+	size_t nregions;
+	const struct espi_saf_pr *pregions;
+};
+
+struct espi_taf_npcx_pckt {
+	uint8_t tag;
+	uint8_t *data;
+};
+
+struct espi_saf_packet;
+
+struct espi_taf_pckt {
+	uint8_t  type;
+	uint8_t  tag;
+	uint32_t addr;
+	uint16_t len;
+	uint32_t src[16];
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/soc/arm/nuvoton_npcx/common/soc_miwu.h b/soc/arm/nuvoton_npcx/common/soc_miwu.h
index c7b51b4f21..2284e9d619 100644
--- a/soc/arm/nuvoton_npcx/common/soc_miwu.h
+++ b/soc/arm/nuvoton_npcx/common/soc_miwu.h
@@ -50,6 +50,12 @@ enum miwu_int_trig {
 	NPCX_MIWU_TRIG_BOTH, /** Both edge rising and failing detection */
 };
 
+/* NPCX miwu driver callback type */
+enum {
+	NPCX_MIWU_CALLBACK_GPIO,
+	NPCX_MIWU_CALLBACK_DEV,
+};
+
 /**
  * @brief NPCX wake-up input source structure
  *
@@ -79,46 +85,50 @@ typedef void (*miwu_dev_callback_handler_t)(const struct device *source,
  */
 struct miwu_io_params {
 	uint8_t pin_mask; /** A mask of pins the callback is interested in. */
-	uint8_t reserved;
 	uint8_t gpio_port; /** GPIO device index */
+	uint8_t cb_type; /** Callback type */
 	struct npcx_wui wui; /** Wake-up input source of GPIO */
 };
 
 /**
- * @brief MIWU callback structure for a GPIO input
+ * @brief MIWU/generic device information structure
  *
- * Used to register a GPIO callback in the driver instance callback list.
- * Beware such structure should not be allocated on stack and its size must
- * equal struct gpio_callback.
- *
- * Note: To help setting it, see npcx_miwu_init_gpio_callback() below
+ * It contains the information used for MIWU generic device event. Please notice
+ * the offset of cb_type must be the same as cb_type in struct miwu_io_params.
  */
-struct miwu_io_callback {
-	/** Node of single-linked list */
-	sys_snode_t node;
-	/** Callback function being called when GPIO event occurred */
-	gpio_callback_handler_t handler;
-	/** GPIO callback parameters used in MIWU ISR */
-	struct miwu_io_params params;
+struct miwu_dev_params {
+	uint8_t reserve1;
+	uint8_t reserve2;
+	uint8_t cb_type; /** Callback type */
+	struct npcx_wui wui; /** Device instance register callback function */
+	const struct device *source; /** Wake-up input source */
 };
 
 /**
- * @brief MIWU callback structure for a device input
+ * @brief MIWU callback structure for a gpio or device input
  *
- * Used to register a generic hardware device callback in the driver instance
+ * Used to register a generic gpio/device callback in the driver instance
  * callback list. Beware such structure should not be allocated on stack.
  *
- * Note: To help setting it, see npcx_miwu_init_dev_callback() below
+ * Note: To help setting it, see npcx_miwu_init_dev_callback() and
+ *       npcx_miwu_manage_callback() below
  */
-struct miwu_dev_callback {
+struct miwu_callback {
 	/** Node of single-linked list */
 	sys_snode_t node;
-	/** Callback function being called when device event occurred */
-	miwu_dev_callback_handler_t handler;
-	/** Device instance register callback function */
-	const struct device *source;
-	/* Wake-up input source */
-	struct npcx_wui wui;
+	union {
+		struct {
+			/** Callback function being called when GPIO event occurred */
+			gpio_callback_handler_t handler;
+			struct miwu_io_params params;
+		} io_cb;
+
+		struct {
+			/** Callback function being called when device event occurred */
+			miwu_dev_callback_handler_t handler;
+			struct miwu_dev_params params;
+		} dev_cb;
+	};
 };
 
 /**
@@ -181,50 +191,38 @@ int npcx_miwu_interrupt_configure(const struct npcx_wui *wui,
 		enum miwu_int_mode mode, enum miwu_int_trig trig);
 
 /**
- * @brief Function to initialize a struct miwu_io_callback properly
+ * @brief Function to initialize a struct miwu_callback with gpio properly
  *
  * @param callback Pointer to io callback structure for initialization
  * @param io_wui Pointer to wake-up input IO source
  * @param port GPIO port issued a callback function
  */
-void npcx_miwu_init_gpio_callback(struct miwu_io_callback *callback,
+void npcx_miwu_init_gpio_callback(struct miwu_callback *callback,
 				const struct npcx_wui *io_wui, int port);
 
 /**
- * @brief Function to initialize a struct miwu_dev_callback properly
+ * @brief Function to initialize a struct miwu_callback with device properly
  *
  * @param callback Pointer to device callback structure for initialization
  * @param dev_wui Pointer to wake-up input device source
  * @param handler A function called when its device input event issued
  * @param source Pointer to device instance issued a callback function
  */
-void npcx_miwu_init_dev_callback(struct miwu_dev_callback *callback,
+void npcx_miwu_init_dev_callback(struct miwu_callback *callback,
 				const struct npcx_wui *dev_wui,
 				miwu_dev_callback_handler_t handler,
 				const struct device *source);
 
 /**
- * @brief Function to insert or remove a IO callback from a callback list
- *
- * @param callback Pointer to io callback structure
- * @param set A boolean indicating insertion or removal of the callback
- *
- * @retval 0 If successful.
- * @retval -EINVAL Invalid parameters
- */
-int npcx_miwu_manage_gpio_callback(struct miwu_io_callback *callback, bool set);
-
-
-/**
- * @brief Function to insert or remove a device callback from a callback list
+ * @brief Function to insert or remove a miwu callback from a callback list
  *
- * @param callback Pointer to device callback structure
+ * @param callback Pointer to miwu callback structure
  * @param set A boolean indicating insertion or removal of the callback
  *
  * @retval 0 If successful.
  * @retval -EINVAL Invalid parameters
  */
-int npcx_miwu_manage_dev_callback(struct miwu_dev_callback *cb, bool set);
+int npcx_miwu_manage_callback(struct miwu_callback *cb, bool set);
 
 #ifdef __cplusplus
 }
diff --git a/soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt b/soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt
new file mode 100644
index 0000000000..f78735512f
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/CMakeLists.txt
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: Apache-2.0
+
+zephyr_include_directories(${ZEPHYR_BASE}/drivers)
+
+zephyr_sources(
+  soc.c
+)
+
+# set(SOC_LINKER_SCRIPT ${ZEPHYR_BASE}/include/zephyr/arch/arm/aarch32/cortex_m/scripts/linker.ld CACHE INTERNAL "")
+
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f
new file mode 100644
index 0000000000..d56b4fac92
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m3f
@@ -0,0 +1,11 @@
+# Nuvoton Cortex-M4 Embedded Controller
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_NPCX4M3F
+
+config SOC
+	default "npcx4m3f"
+
+endif # SOC_NPCX4M3F
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f
new file mode 100644
index 0000000000..00ba5b3b62
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4m8f
@@ -0,0 +1,11 @@
+# Nuvoton Cortex-M4 Embedded Controller
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_NPCX4M8F
+
+config SOC
+	default "npcx4m8f"
+
+endif # SOC_NPCX4M8F
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series
new file mode 100644
index 0000000000..171489c0d1
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.series
@@ -0,0 +1,28 @@
+# Nuvoton Cortex-M4 Embedded Controller
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+if SOC_SERIES_NPCX4
+
+config SOC_SERIES
+	default "npcx4"
+
+config NUM_IRQS
+	default 128
+
+config CORTEX_M_SYSTICK
+	default !NPCX_ITIM_TIMER
+
+config ESPI_NPCX
+	default y
+	depends on ESPI
+
+config ESPI_TAF_NPCX
+    bool "ESPI TAF configuration option"
+	default y
+	depends on ESPI_SAF
+
+source "soc/arm/nuvoton_npcx/npcx4/Kconfig.defconfig.npcx4*"
+
+endif # SOC_SERIES_NPCX4
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.series b/soc/arm/nuvoton_npcx/npcx4/Kconfig.series
new file mode 100644
index 0000000000..1585ace4e9
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.series
@@ -0,0 +1,16 @@
+# Nuvoton Cortex-M4 Embedded Controller NPCX4 series
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+config SOC_SERIES_NPCX4
+	bool "Nuvoton NPCX4 Series"
+	select ARM
+	select CPU_CORTEX_M4
+	select CPU_CORTEX_M_HAS_DWT
+	select CPU_HAS_FPU
+	select CPU_HAS_ARM_MPU
+	select SOC_FAMILY_NPCX
+	select HAS_PM
+	help
+	  Enable support for Nuvoton NPCX4 series
diff --git a/soc/arm/nuvoton_npcx/npcx4/Kconfig.soc b/soc/arm/nuvoton_npcx/npcx4/Kconfig.soc
new file mode 100644
index 0000000000..3e5f5e1d19
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/Kconfig.soc
@@ -0,0 +1,16 @@
+# Nuvoton NPCX4 EC series
+
+# Copyright (c) 2023 Nuvoton Technology Corporation.
+# SPDX-License-Identifier: Apache-2.0
+
+choice
+	prompt "NPCX4 Selection"
+	depends on SOC_SERIES_NPCX4
+
+config SOC_NPCX4M3F
+	bool "NPCX4M3F"
+
+config SOC_NPCX4M8F
+	bool "NPCX4M8F"
+
+endchoice
diff --git a/soc/arm/nuvoton_npcx/npcx4/linker.ld b/soc/arm/nuvoton_npcx/npcx4/linker.ld
new file mode 100644
index 0000000000..4856bf0a71
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/linker.ld
@@ -0,0 +1,9 @@
+/* linker.ld - Linker command/script file */
+
+/*
+ * Copyright (c) 2020 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/arch/arm/aarch32/cortex_m/scripts/linker.ld>
diff --git a/soc/arm/nuvoton_npcx/npcx4/soc.c b/soc/arm/nuvoton_npcx/npcx4/soc.c
new file mode 100644
index 0000000000..28b868bda6
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/soc.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include <zephyr/kernel.h>
+#include <zephyr/device.h>
+#include <zephyr/init.h>
+#include <soc.h>
+#include <zephyr/logging/log.h>
+
+LOG_MODULE_REGISTER(soc, CONFIG_SOC_LOG_LEVEL);
+
+#define NPCX_FIU_INST_INIT(node_id) DT_REG_ADDR(node_id),
+
+static uintptr_t fiu_insts[] = {
+	DT_FOREACH_STATUS_OKAY(nuvoton_npcx_fiu_qspi, NPCX_FIU_INST_INIT)
+};
+
+static int soc_npcx4_init(void)
+{
+	/*
+	 * Make sure UMA_ADDR_SIZE field of UMA_ECTS register is zero in npcx4
+	 * series. There should be no address field in UMA mode by default.
+	 */
+	for (int i = 0; i < ARRAY_SIZE(fiu_insts); i++) {
+		struct fiu_reg *const inst = (struct fiu_reg *)(fiu_insts[i]);
+
+		SET_FIELD(inst->UMA_ECTS, NPCX_UMA_ECTS_UMA_ADDR_SIZE, 0);
+	}
+
+	return 0;
+}
+
+SYS_INIT(soc_npcx4_init, PRE_KERNEL_1, 0);
diff --git a/soc/arm/nuvoton_npcx/npcx4/soc.h b/soc/arm/nuvoton_npcx/npcx4/soc.h
new file mode 100644
index 0000000000..c1614169f1
--- /dev/null
+++ b/soc/arm/nuvoton_npcx/npcx4/soc.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2023 Nuvoton Technology Corporation.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef _NUVOTON_NPCX_SOC_H_
+#define _NUVOTON_NPCX_SOC_H_
+
+/* CMSIS required definitions */
+#define __FPU_PRESENT  CONFIG_CPU_HAS_FPU
+#define __MPU_PRESENT  CONFIG_CPU_HAS_ARM_MPU
+
+/* NPCX4 SCFG multi-registers */
+#define NPCX_DEVALT_OFFSET(n)		(0x010 + n)
+#define NPCX_PUPD_EN_OFFSET(n)		(0x02b + n)
+#define NPCX_LV_GPIO_CTL_OFFSET(n)	(0x150 + n)
+#define NPCX_DEVALT_LK_OFFSET(n)	(0x210 + n)
+
+/* NPCX4 MIWU multi-registers */
+#define NPCX_WKEDG_OFFSET(n)		(0x000 + (n * 0x010))
+#define NPCX_WKAEDG_OFFSET(n)		(0x001 + (n * 0x010))
+#define NPCX_WKMOD_OFFSET(n)		(0x002 + (n * 0x010))
+#define NPCX_WKPND_OFFSET(n)		(0x003 + (n * 0x010))
+#define NPCX_WKPCL_OFFSET(n)		(0x004 + (n * 0x010))
+#define NPCX_WKEN_OFFSET(n)		(0x005 + (n * 0x010))
+#define NPCX_WKST_OFFSET(n)		(0x006 + (n * 0x010))
+#define NPCX_WKINEN_OFFSET(n)		(0x007 + (n * 0x010))
+
+/* NPCX4 PMC multi-registers */
+#define NPCX_PWDWN_CTL_OFFSET(n)	((n < 6) ? (0x008 + n) : (0x01e + n))
+
+/* NPCX4 ADC multi-registers */
+#define NPCX_CHNDAT_OFFSET(n)		(0x040 + n * 2)
+#define NPCX_THRCTL_OFFSET(n)		(0x080 + n * 2)
+#define NPCX_THEN_OFFSET		0x090
+#define THEN(base)			(*(volatile uint16_t *)(base + NPCX_THEN_OFFSET))
+
+/* NPCX4 ADC register fields */
+#define NPCX_THRCTL_L_H			15
+#define NPCX_THRCTL_CHNSEL		FIELD(10, 5)
+#define NPCX_THRCTL_THRVAL		FIELD(0, 10)
+
+/* NPCX4 FIU register fields */
+#define NPCX_FIU_EXT_CFG_SPI1_2DEV	6
+
+/* NPCX4 supported group mask of DEVALT_LK */
+#define NPCX_DEVALT_LK_GROUP_MASK \
+	(BIT(0) | BIT(2) | BIT(3) | BIT(4) | \
+	 BIT(5) | BIT(6) | BIT(11) | BIT(13) | \
+	 BIT(15) | BIT(16) | BIT(17) | BIT(18) | \
+	 BIT(19) | BIT(21))	/* DEVALT0_LK - DEVALTN_LK */
+
+/* NPCX4 Clock Configuration */
+#define MAX_OFMCLK 120000000
+
+#include <reg/reg_access.h>
+#include <reg/reg_def.h>
+#include <soc_dt.h>
+#include <soc_clock.h>
+#include <soc_pins.h>
+#include <soc_power.h>
+
+/* NPCX4 Clock prescaler configurations */
+#define VAL_HFCGP   ((FPRED_VAL << 4) | AHB6DIV_VAL)
+#define VAL_HFCBCD  ((FIU1DIV_VAL << 4) | (FIUDIV_VAL << 2))
+#define VAL_HFCBCD1 (APB1DIV_VAL | (APB2DIV_VAL << 4))
+#define VAL_HFCBCD2 (APB3DIV_VAL | (APB4DIV_VAL << 4))
+
+#endif /* _NUVOTON_NPCX_SOC_H_ */
-- 
2.41.0

